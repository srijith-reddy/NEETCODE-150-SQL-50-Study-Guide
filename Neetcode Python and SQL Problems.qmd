---
title: "NeetCode Python & SQL Problems"
format:
  html:
    toc: true
    toc-depth: 3
    code-tools: true
    code-fold: true
    smooth-scroll: true
    anchor-sections: true
---


# ðŸ§  NeetCode 150+ Problems

## Problem 1: Two Sum

**Category/Pattern:** Array | Hashmap

**Difficulty:** Easy

**Problem:**
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. Each input has exactly one solution, and you cannot use the same element twice.

**Examples:**
- Input: nums = [2,7,11,15], target = 9
Output: [0,1]
- Input: nums = [3,2,4], target = 6
Output: [1,2]
- Input: nums = [3,3], target = 6
Output: [0,1]

**Approach:**
Use a HashMap to store seen numbers. For each number, check if (target - num) is already in the map. If so, return [map[target - num], current_index].

**Code:**
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}
        for i, num in enumerate(nums):
            diff = target - num
            if diff in seen:
                return [seen[diff], i]
            seen[num] = i
```

## Problem 2: Best Time to Buy and Sell Stock

**Category/Pattern:** Array | One-Pass | Prefix Min

**Difficulty:** Easy

**Problem:**
Given prices[i] = stock price on day i, find the max profit from one buy and one sell (buy before sell). If no profit is possible, return 0.

**Examples:**
- Input: prices = [7,1,5,3,6,4]
Output: 5
- Input: prices = [7,6,4,3,1]
Output: 0

**Approach:**
Track minimum price so far. For each price, calculate potential profit (price - min_price). Update max_profit if potential is higher.

**Code:**
```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = float('inf')
        max_profit = 0
        for price in prices:
            potential = price - min_price
            if potential > max_profit:
                max_profit = potential
            if price < min_price:
                min_price = price
        return max_profit
```

## Problem 3: Binary Search

**Category/Pattern:** Binary Search

**Difficulty:** Easy

**Problem:**
Given a sorted array of integers and a target value, return the index if the target is found. Otherwise, return -1.

**Examples:**
- Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
- Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1

**Approach:**
Standard binary search using left, right, and mid pointers.

**Code:**
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

## Problem 4: 3Sum

**Category/Pattern:** Array | Two Pointers | Sorting

**Difficulty:** Medium

**Problem:**
Given an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that they sum to zero.

**Examples:**
- Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

**Approach:**
Sort array, use two pointers to fix first element and find remaining two in a while loop.

**Code:**
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        for i, a in enumerate(nums):
            if i > 0 and a == nums[i - 1]:
                continue
            l, r = i + 1, len(nums) - 1
            while l < r:
                three = a + nums[l] + nums[r]
                if three > 0:
                    r -= 1
                elif three < 0:
                    l += 1
                else:
                    res.append([a, nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while nums[l] == nums[l - 1] and l < r:
                        l += 1
        return res
```

## Problem 5: Container With Most Water

**Category/Pattern:** Array | Two Pointers

**Difficulty:** Medium

**Problem:**
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai), find two lines that together with the x-axis form a container, such that the container contains the most water.

**Examples:**
- Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49

**Approach:**
Use two pointers, move the pointer pointing to the smaller height inward. Track max area.

**Code:**
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        max_area = 0
        while l < r:
            max_area = max(max_area, min(height[l], height[r]) * (r - l))
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return max_area
```

## Problem 6: Valid Parentheses

**Category/Pattern:** Stack

**Difficulty:** Easy

**Problem:**
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

**Examples:**
- Input: s = "()"
Output: true
- Input: s = "()[]{}"
Output: true
- Input: s = "(]"
Output: false

**Approach:**
Use a stack to track open brackets. Match with correct closing brackets as you go.

**Code:**
```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {')': '(', '}': '{', ']': '['}
        for char in s:
            if char in mapping:
                top = stack.pop() if stack else '#'
                if mapping[char] != top:
                    return False
            else:
                stack.append(char)
        return not stack
```

## Problem 7: Merge Two Sorted Lists

**Category/Pattern:** Linked List | Recursion | Iteration

**Difficulty:** Easy

**Problem:**
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Examples:**
- Input: l1 = [1,2,4], l2 = [1,3,4]
Output: [1,1,2,3,4,4]

**Approach:**
Use recursion or dummy node with iteration to merge in-place.

**Code:**
```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode()
        tail = dummy
        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next
```

## Problem 8: Valid Anagram

**Category/Pattern:** Hash Table

**Difficulty:** Easy

**Problem:**
Given two strings s and t, return true if t is an anagram of s, and false otherwise.

**Examples:**
- Input: s = "anagram", t = "nagaram"
Output: true
- Input: s = "rat", t = "car"
Output: false

**Approach:**
Count character frequency using dictionaries or collections.Counter.

**Code:**
```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
```

## Problem 9: Group Anagrams

**Category/Pattern:** Hash Table | Sorting

**Difficulty:** Medium

**Problem:**
Given an array of strings strs, group the anagrams together.

**Examples:**
- Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

**Approach:**
Use a dictionary with sorted string as key. Append anagrams to list mapped to that key.

**Code:**
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = defaultdict(list)
        for s in strs:
            key = tuple(sorted(s))
            res[key].append(s)
        return list(res.values())
```

## Problem 10: Top K Frequent Elements

**Category/Pattern:** Heap | Bucket Sort

**Difficulty:** Medium

**Problem:**
Given an integer array nums and an integer k, return the k most frequent elements.

**Examples:**
- Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

**Approach:**
Use Counter to count frequency. Use heapq.nlargest or bucket sort to find top k.

**Code:**
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = Counter(nums)
        return heapq.nlargest(k, count.keys(), key=count.get)
```

## Problem 11: Longest Consecutive Sequence

**Category/Pattern:** Set | Linear Scan

**Difficulty:** Medium

**Problem:**
Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

**Examples:**
- Input: nums = [100,4,200,1,3,2]
Output: 4

**Approach:**
Use a set. For each number, only start counting if it's the beginning of a sequence.

**Code:**
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        num_set = set(nums)
        longest = 0
        for n in num_set:
            if n - 1 not in num_set:
                length = 1
                while n + length in num_set:
                    length += 1
                longest = max(longest, length)
        return longest
```

## Problem 12: Sliding Window Maximum

**Category/Pattern:** Deque | Sliding Window

**Difficulty:** Hard

**Problem:**
You are given an array of integers nums, and there is a sliding window of size k. Return the maximum value in each window.

**Examples:**
- Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

**Approach:**
Use a deque to keep indexes of useful elements. Maintain max at the front.

**Code:**
```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        q = deque()
        res = []
        for i, n in enumerate(nums):
            while q and q[0] <= i - k:
                q.popleft()
            while q and nums[q[-1]] < n:
                q.pop()
            q.append(i)
            if i >= k - 1:
                res.append(nums[q[0]])
        return res
```

## Problem 13: Invert Binary Tree

**Category/Pattern:** Binary Tree | DFS | BFS

**Difficulty:** Easy

**Problem:**
Given the root of a binary tree, invert the tree, and return its root.

**Examples:**
- Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]

**Approach:**
Use DFS or BFS to swap the left and right child of every node recursively or iteratively.

**Code:**
```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
        return root
```

## Problem 14: Maximum Depth of Binary Tree

**Category/Pattern:** Binary Tree | DFS | Recursion

**Difficulty:** Easy

**Problem:**
Given the root of a binary tree, return its maximum depth.

**Examples:**
- Input: root = [3,9,20,null,null,15,7]
Output: 3

**Approach:**
Recursively compute depth of left and right subtree. Return max of both + 1.

**Code:**
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

## Problem 15: Same Tree

**Category/Pattern:** Binary Tree | Recursion

**Difficulty:** Easy

**Problem:**
Given two binary trees, check if they are the same (structure and node values).

**Examples:**
- Input: p = [1,2,3], q = [1,2,3]
Output: true
- Input: p = [1,2], q = [1,null,2]
Output: false

**Approach:**
Use recursion. If roots are same and left/right subtrees match, return True.

**Code:**
```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if not p or not q or p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

## Problem 16: Subtree of Another Tree

**Category/Pattern:** Binary Tree | DFS | Recursion

**Difficulty:** Medium

**Problem:**
Check if a binary tree 'subRoot' is a subtree of binary tree 'root'.

**Examples:**
- Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true

**Approach:**
Use recursion to compare every subtree of root with subRoot using sameTree function.

**Code:**
```python
class Solution:
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        if not root:
            return False
        if self.isSameTree(root, subRoot):
            return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
    
    def isSameTree(self, s, t):
        if not s and not t:
            return True
        if not s or not t or s.val != t.val:
            return False
        return self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)
```

## Problem 17: Lowest Common Ancestor of a Binary Search Tree

**Category/Pattern:** BST | DFS | Recursion

**Difficulty:** Medium

**Problem:**
Given a BST, find the lowest common ancestor (LCA) of two nodes.

**Examples:**
- Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6

**Approach:**
Use BST property. If both p and q are smaller, go left; if both larger, go right. Otherwise, current is LCA.

**Code:**
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            if p.val < root.val and q.val < root.val:
                root = root.left
            elif p.val > root.val and q.val > root.val:
                root = root.right
            else:
                return root
```

## Problem 18: Binary Tree Level Order Traversal

**Category/Pattern:** Binary Tree | BFS

**Difficulty:** Medium

**Problem:**
Return the level order traversal of a binary tree (i.e., from left to right, level by level).

**Examples:**
- Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]

**Approach:**
Use a queue (BFS) and process each level by counting its size.

**Code:**
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        if not root:
            return res
        q = deque([root])
        while q:
            level = []
            for _ in range(len(q)):
                node = q.popleft()
                level.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            res.append(level)
        return res
```

## Problem 19: Binary Tree Right Side View

**Category/Pattern:** Binary Tree | BFS | DFS

**Difficulty:** Medium

**Problem:**
Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom.

**Examples:**
- Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]

**Approach:**
Use BFS and capture the last node value at each level.

**Code:**
```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if not root:
            return res
        q = deque([root])
        while q:
            right = None
            for _ in range(len(q)):
                node = q.popleft()
                right = node
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if right:
                res.append(right.val)
        return res
```

## Problem 20: Count Good Nodes in Binary Tree

**Category/Pattern:** Binary Tree | DFS

**Difficulty:** Medium

**Problem:**
A node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes.

**Examples:**
- Input: root = [3,1,4,3,null,1,5]
Output: 4

**Approach:**
Use DFS and pass the max seen so far down the tree.

**Code:**
```python
class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        def dfs(node, max_val):
            if not node:
                return 0
            good = 1 if node.val >= max_val else 0
            max_val = max(max_val, node.val)
            return good + dfs(node.left, max_val) + dfs(node.right, max_val)
        return dfs(root, root.val)
```

## Problem 21: Validate Binary Search Tree

**Category/Pattern:** BST | Recursion | Inorder

**Difficulty:** Medium

**Problem:**
Determine if a binary tree is a valid binary search tree (BST).

**Examples:**
- Input: root = [2,1,3]
Output: true
- Input: root = [5,1,4,null,null,3,6]
Output: false

**Approach:**
Use recursion with min/max bounds or use inorder traversal to verify ascending order.

**Code:**
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def helper(node, low, high):
            if not node:
                return True
            if not (low < node.val < high):
                return False
            return helper(node.left, low, node.val) and helper(node.right, node.val, high)
        return helper(root, float('-inf'), float('inf'))
```

## Problem 22: Kth Smallest Element in a BST

**Category/Pattern:** BST | Inorder Traversal

**Difficulty:** Medium

**Problem:**
Given the root of a BST, and an integer k, return the kth smallest value in the tree.

**Examples:**
- Input: root = [3,1,4,null,2], k = 1
Output: 1

**Approach:**
Inorder traversal of BST gives sorted order. Use counter to track kth element.

**Code:**
```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.k = k
        self.res = None
        
        def inorder(node):
            if not node or self.res is not None:
                return
            inorder(node.left)
            self.k -= 1
            if self.k == 0:
                self.res = node.val
                return
            inorder(node.right)
        
        inorder(root)
        return self.res
```

## Problem 23: Lowest Common Ancestor of a Binary Tree

**Category/Pattern:** Binary Tree | DFS

**Difficulty:** Medium

**Problem:**
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes p and q.

**Examples:**
- Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3

**Approach:**
Use recursion. If root is either p or q or null, return root. Recurse left and right. If both sides return non-null, root is LCA.

**Code:**
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        return left or right
```

## Problem 24: Construct Binary Tree from Preorder and Inorder Traversal

**Category/Pattern:** Binary Tree | Recursion

**Difficulty:** Medium

**Problem:**
Given preorder and inorder traversal of a tree, construct the binary tree.

**Examples:**
- Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

**Approach:**
Preorder gives root, inorder gives left/right split. Recursively build left and right subtrees.

**Code:**
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None
        root = TreeNode(preorder[0])
        mid = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])
        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])
        return root
```

## Problem 25: Binary Tree Maximum Path Sum

**Category/Pattern:** Binary Tree | DFS

**Difficulty:** Medium

**Problem:**
Find the path in the binary tree which gives the maximum sum (can start and end at any node).

**Examples:**
- Input: root = [-10,9,20,null,null,15,7]
Output: 42

**Approach:**
Use DFS to calculate the max path through each node. Track global max.

**Code:**
```python
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.max_sum = float('-inf')
        def dfs(node):
            if not node:
                return 0
            left = max(0, dfs(node.left))
            right = max(0, dfs(node.right))
            self.max_sum = max(self.max_sum, left + right + node.val)
            return max(left, right) + node.val
        dfs(root)
        return self.max_sum
```

## Problem 26: Serialize and Deserialize Binary Tree

**Category/Pattern:** Binary Tree | BFS | Design

**Difficulty:** Hard

**Problem:**
Design an algorithm to serialize and deserialize a binary tree.

**Examples:**
- Input: root = [1,2,3,null,null,4,5]
Output: same tree

**Approach:**
Use BFS. Serialize to string with null markers. Deserialize using a queue and position logic.

**Code:**
```python
class Codec:
    def serialize(self, root):
        if not root:
            return ""
        q, res = deque([root]), []
        while q:
            node = q.popleft()
            if node:
                res.append(str(node.val))
                q.append(node.left)
                q.append(node.right)
            else:
                res.append('N')
        return ','.join(res)

    def deserialize(self, data):
        if not data:
            return None
        vals = data.split(',')
        root = TreeNode(int(vals[0]))
        q = deque([root])
        i = 1
        while q:
            node = q.popleft()
            if vals[i] != 'N':
                node.left = TreeNode(int(vals[i]))
                q.append(node.left)
            i += 1
            if vals[i] != 'N':
                node.right = TreeNode(int(vals[i]))
                q.append(node.right)
            i += 1
        return root
```

## Problem 27: Clone Graph

**Category/Pattern:** Graph | DFS | BFS

**Difficulty:** Medium

**Problem:**
Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.

**Examples:**
- Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]

**Approach:**
Use DFS with a hashmap to track cloned nodes and prevent infinite loops.

**Code:**
```python
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        oldToNew = {}
        def dfs(n):
            if not n:
                return None
            if n in oldToNew:
                return oldToNew[n]
            copy = Node(n.val)
            oldToNew[n] = copy
            for neighbor in n.neighbors:
                copy.neighbors.append(dfs(neighbor))
            return copy
        return dfs(node)
```

## Problem 28: Number of Islands

**Category/Pattern:** Graph | DFS | BFS | Union Find

**Difficulty:** Medium

**Problem:**
Given a 2D grid map of '1's (land) and '0's (water), count the number of islands.

**Examples:**
- Input: grid = [["1","1","1","1","0"],["1","1","0","1","0"],["1","1","0","0","0"],["0","0","0","0","0"]]
Output: 1

**Approach:**
Use DFS to mark all connected land. Increment island count each time you find unvisited land.

**Code:**
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        rows, cols = len(grid), len(grid[0])
        visit = set()
        def dfs(r, c):
            if (r < 0 or c < 0 or r >= rows or c >= cols or 
                grid[r][c] == "0" or (r, c) in visit):
                return
            visit.add((r, c))
            dfs(r+1, c)
            dfs(r-1, c)
            dfs(r, c+1)
            dfs(r, c-1)
        islands = 0
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == "1" and (r, c) not in visit:
                    dfs(r, c)
                    islands += 1
        return islands
```

## Problem 29: Max Area of Island

**Category/Pattern:** Graph | DFS

**Difficulty:** Medium

**Problem:**
Return the area of the largest island in the given 2D grid.

**Examples:**
- Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0]]
Output: 6

**Approach:**
DFS to calculate area for each island and track maximum encountered.

**Code:**
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        seen = set()
        def dfs(r, c):
            if (r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or 
                grid[r][c] == 0 or (r, c) in seen):
                return 0
            seen.add((r, c))
            return (1 + dfs(r+1, c) + dfs(r-1, c) +
                    dfs(r, c+1) + dfs(r, c-1))
        return max(dfs(r, c) for r in range(len(grid)) for c in range(len(grid[0])))
```

## Problem 30: Pacific Atlantic Water Flow

**Category/Pattern:** Graph | DFS | Matrix

**Difficulty:** Medium

**Problem:**
Find cells where water can flow to both the Pacific and Atlantic oceans.

**Examples:**
- Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]

**Approach:**
DFS from ocean borders and mark visited cells. Return intersection of visited sets.

**Code:**
```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        if not heights:
            return []
        rows, cols = len(heights), len(heights[0])
        pac, atl = set(), set()
        def dfs(r, c, visited, prevHeight):
            if (r < 0 or c < 0 or r >= rows or c >= cols or
                (r, c) in visited or heights[r][c] < prevHeight):
                return
            visited.add((r, c))
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                dfs(r+dr, c+dc, visited, heights[r][c])
        for c in range(cols):
            dfs(0, c, pac, heights[0][c])
            dfs(rows-1, c, atl, heights[rows-1][c])
        for r in range(rows):
            dfs(r, 0, pac, heights[r][0])
            dfs(r, cols-1, atl, heights[r][cols-1])
        return list(pac & atl)
```

## Problem 31: Surrounded Regions

**Category/Pattern:** Graph | DFS

**Difficulty:** Medium

**Problem:**
Capture all regions that are surrounded by 'X'.

**Examples:**
- Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]

**Approach:**
DFS from border 'O's and mark as safe. Flip all remaining 'O' to 'X'.

**Code:**
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board or not board[0]:
            return
        rows, cols = len(board), len(board[0])
        def dfs(r, c):
            if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != 'O':
                return
            board[r][c] = 'S'
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                dfs(r+dr, c+dc)
        for r in range(rows):
            for c in [0, cols-1]:
                dfs(r, c)
        for c in range(cols):
            for r in [0, rows-1]:
                dfs(r, c)
        for r in range(rows):
            for c in range(cols):
                if board[r][c] == 'O':
                    board[r][c] = 'X'
                elif board[r][c] == 'S':
                    board[r][c] = 'O'
```

## Problem 32: Rotting Oranges

**Category/Pattern:** BFS | Matrix

**Difficulty:** Medium

**Problem:**
Given a grid, each cell can be empty (0), fresh orange (1), or rotten (2). Every minute, any fresh orange adjacent to a rotten one becomes rotten. Return the minimum number of minutes until no cell has a fresh orange.

**Examples:**
- Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4

**Approach:**
Use BFS to simulate the spread. Track time and count fresh oranges.

**Code:**
```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        q = deque()
        fresh = 0
        rows, cols = len(grid), len(grid[0])
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 2:
                    q.append((r, c))
                elif grid[r][c] == 1:
                    fresh += 1
        minutes = 0
        while q and fresh:
            for _ in range(len(q)):
                r, c = q.popleft()
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                        grid[nr][nc] = 2
                        q.append((nr, nc))
                        fresh -= 1
            minutes += 1
        return minutes if fresh == 0 else -1
```

## Problem 33: Walls and Gates

**Category/Pattern:** BFS | Matrix

**Difficulty:** Medium

**Problem:**
You are given an m Ã— n grid of rooms initialized with -1 (wall), 0 (gate), or INF (empty room). Fill each empty room with the distance to its nearest gate.

**Examples:**
- Input: rooms = [[INF,-1,0,INF],[INF,INF,INF,-1],[INF,-1,INF,-1],[0,-1,INF,INF]]
Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]

**Approach:**
Use multi-source BFS from all gates simultaneously.

**Code:**
```python
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        if not rooms:
            return
        q = deque()
        for r in range(len(rooms)):
            for c in range(len(rooms[0])):
                if rooms[r][c] == 0:
                    q.append((r, c))
        while q:
            r, c = q.popleft()
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < len(rooms) and 0 <= nc < len(rooms[0]) and rooms[nr][nc] == 2147483647:
                    rooms[nr][nc] = rooms[r][c] + 1
                    q.append((nr, nc))
```

## Problem 34: Course Schedule

**Category/Pattern:** Graph | Topological Sort | Cycle Detection

**Difficulty:** Medium

**Problem:**
There are a total of numCourses you have to take, labeled from 0 to numCourses - 1. Some courses have prerequisites. Determine if it's possible to finish all courses.

**Examples:**
- Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
- Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false

**Approach:**
Use DFS with cycle detection (visited and path set), or Kahnâ€™s algorithm for topological sort.

**Code:**
```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = defaultdict(list)
        for crs, pre in prerequisites:
            graph[crs].append(pre)
        visit = set()
        cycle = set()
        def dfs(crs):
            if crs in cycle:
                return False
            if crs in visit:
                return True
            cycle.add(crs)
            for pre in graph[crs]:
                if not dfs(pre):
                    return False
            cycle.remove(crs)
            visit.add(crs)
            return True
        return all(dfs(c) for c in range(numCourses))
```

## Problem 35: Course Schedule II

**Category/Pattern:** Graph | Topological Sort

**Difficulty:** Medium

**Problem:**
Return the ordering of courses to finish all courses or an empty array if impossible.

**Examples:**
- Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]

**Approach:**
Topological sort using DFS with post-order append and cycle detection.

**Code:**
```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        for crs, pre in prerequisites:
            graph[crs].append(pre)
        visit, cycle = set(), set()
        res = []
        def dfs(crs):
            if crs in cycle:
                return False
            if crs in visit:
                return True
            cycle.add(crs)
            for pre in graph[crs]:
                if not dfs(pre):
                    return False
            cycle.remove(crs)
            visit.add(crs)
            res.append(crs)
            return True
        for c in range(numCourses):
            if not dfs(c):
                return []
        return res
```

## Problem 36: Alien Dictionary

**Category/Pattern:** Graph | Topological Sort

**Difficulty:** Medium

**Problem:**
Given a list of words sorted lexicographically by alien dictionary order, return the order of letters in the alien language.

**Examples:**
- Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"

**Approach:**
Build graph of letters from word pairs, topologically sort.

**Code:**
```python
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        graph = defaultdict(set)
        indegree = {c: 0 for word in words for c in word}
        for i in range(len(words) - 1):
            w1, w2 = words[i], words[i+1]
            min_len = min(len(w1), len(w2))
            if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:
                return ""
            for c1, c2 in zip(w1, w2):
                if c1 != c2:
                    if c2 not in graph[c1]:
                        graph[c1].add(c2)
                        indegree[c2] += 1
                    break
        q = deque([c for c in indegree if indegree[c] == 0])
        res = []
        while q:
            c = q.popleft()
            res.append(c)
            for nei in graph[c]:
                indegree[nei] -= 1
                if indegree[nei] == 0:
                    q.append(nei)
        return "".join(res) if len(res) == len(indegree) else ""
```

## Problem 37: Reconstruct Itinerary

**Category/Pattern:** Graph | Hierholzer's Algorithm

**Difficulty:** Medium

**Problem:**
Given a list of airline tickets represented as pairs of departure and arrival airports, reconstruct the itinerary starting at JFK and using all tickets exactly once.

**Examples:**
- Input: [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]

**Approach:**
Use DFS + backtracking or Hierholzer's algorithm to find Eulerian path.

**Code:**
```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = defaultdict(list)
        for src, dst in sorted(tickets)[::-1]:
            graph[src].append(dst)
        res = []
        def dfs(airport):
            while graph[airport]:
                dfs(graph[airport].pop())
            res.append(airport)
        dfs("JFK")
        return res[::-1]
```

## Problem 38: Word Ladder

**Category/Pattern:** Graph | BFS

**Difficulty:** Medium

**Problem:**
Given beginWord and endWord, and a wordList, return the length of shortest transformation sequence.

**Examples:**
- Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5

**Approach:**
Use BFS and word pattern adjacency (wildcard transformations) to traverse valid changes.

**Code:**
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordSet = set(wordList)
        if endWord not in wordSet:
            return 0
        q = deque([(beginWord, 1)])
        while q:
            word, length = q.popleft()
            if word == endWord:
                return length
            for i in range(len(word)):
                for c in string.ascii_lowercase:
                    nextWord = word[:i] + c + word[i+1:]
                    if nextWord in wordSet:
                        wordSet.remove(nextWord)
                        q.append((nextWord, length + 1))
        return 0
```

## Problem 39: Word Search

**Category/Pattern:** Matrix | DFS | Backtracking

**Difficulty:** Hard

**Problem:**
Given a 2D board and a word, return true if the word exists in the grid.

**Examples:**
- Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true

**Approach:**
DFS + backtracking on each cell, mark visited to avoid reuse.

**Code:**
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        rows, cols = len(board), len(board[0])
        def dfs(r, c, i):
            if i == len(word):
                return True
            if r < 0 or c < 0 or r >= rows or c >= cols or word[i] != board[r][c]:
                return False
            temp, board[r][c] = board[r][c], '#'
            found = (dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or
                     dfs(r, c+1, i+1) or dfs(r, c-1, i+1))
            board[r][c] = temp
            return found
        for r in range(rows):
            for c in range(cols):
                if dfs(r, c, 0):
                    return True
        return False
```

## Problem 40: Longest Substring Without Repeating Characters

**Category/Pattern:** Sliding Window | HashSet

**Difficulty:** Medium

**Problem:**
Given a string, find the length of the longest substring without repeating characters.

**Examples:**
- Input: s = "abcabcbb"
Output: 3

**Approach:**
Use sliding window with set. Move left pointer when duplicate is found.

**Code:**
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        seen = set()
        l = res = 0
        for r in range(len(s)):
            while s[r] in seen:
                seen.remove(s[l])
                l += 1
            seen.add(s[r])
            res = max(res, r - l + 1)
        return res
```

## Problem 41: Longest Repeating Character Replacement

**Category/Pattern:** Sliding Window | Frequency Count

**Difficulty:** Medium

**Problem:**
Given a string s and an integer k, return the length of the longest substring containing the same letter you can get after performing at most k replacements.

**Examples:**
- Input: s = "ABAB", k = 2
Output: 4

**Approach:**
Use sliding window. Track the count of the most frequent character and shrink window when more than k replacements are needed.

**Code:**
```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = {}
        res = 0
        l = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            while (r - l + 1) - max(count.values()) > k:
                count[s[l]] -= 1
                l += 1
            res = max(res, r - l + 1)
        return res
```

## Problem 42: Permutation in String

**Category/Pattern:** Sliding Window | Frequency Count

**Difficulty:** Medium

**Problem:**
Given two strings s1 and s2, return true if s2 contains a permutation of s1.

**Examples:**
- Input: s1 = "ab", s2 = "eidbaooo"
Output: true

**Approach:**
Compare character counts in a sliding window of s2 with the count of s1.

**Code:**
```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False
        s1_count, s2_count = [0] * 26, [0] * 26
        for i in range(len(s1)):
            s1_count[ord(s1[i]) - ord('a')] += 1
            s2_count[ord(s2[i]) - ord('a')] += 1
        matches = 0
        for i in range(26):
            if s1_count[i] == s2_count[i]:
                matches += 1
        l = 0
        for r in range(len(s1), len(s2)):
            if matches == 26:
                return True
            index = ord(s2[r]) - ord('a')
            s2_count[index] += 1
            if s1_count[index] == s2_count[index]:
                matches += 1
            elif s1_count[index] + 1 == s2_count[index]:
                matches -= 1
            index = ord(s2[l]) - ord('a')
            s2_count[index] -= 1
            if s1_count[index] == s2_count[index]:
                matches += 1
            elif s1_count[index] - 1 == s2_count[index]:
                matches -= 1
            l += 1
        return matches == 26
```

## Problem 43: Minimum Window Substring

**Category/Pattern:** Sliding Window | HashMap

**Difficulty:** Hard

**Problem:**
Given strings s and t, return the minimum window in s which contains all the characters in t.

**Examples:**
- Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

**Approach:**
Use sliding window and track character frequencies. Expand until valid, then try shrinking.

**Code:**
```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if not t or not s:
            return ""
        countT, window = Counter(t), {}
        have, need = 0, len(countT)
        res, resLen = [-1, -1], float("inf")
        l = 0
        for r in range(len(s)):
            c = s[r]
            window[c] = 1 + window.get(c, 0)
            if c in countT and window[c] == countT[c]:
                have += 1
            while have == need:
                if (r - l + 1) < resLen:
                    res = [l, r]
                    resLen = r - l + 1
                window[s[l]] -= 1
                if s[l] in countT and window[s[l]] < countT[s[l]]:
                    have -= 1
                l += 1
        l, r = res
        return s[l:r+1] if resLen != float("inf") else ""
```

## Problem 44: Find All Anagrams in a String

**Category/Pattern:** Sliding Window | Frequency Count

**Difficulty:** Medium

**Problem:**
Return all starting indices of p's anagrams in s.

**Examples:**
- Input: s = "cbaebabacd", p = "abc"
Output: [0,6]

**Approach:**
Use frequency counter and sliding window of same length as p.

**Code:**
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        if len(p) > len(s):
            return []
        res = []
        p_count = Counter(p)
        s_count = Counter(s[:len(p)-1])
        for i in range(len(p)-1, len(s)):
            s_count[s[i]] += 1
            if s_count == p_count:
                res.append(i - len(p) + 1)
            s_count[s[i - len(p) + 1]] -= 1
            if s_count[s[i - len(p) + 1]] == 0:
                del s_count[s[i - len(p) + 1]]
        return res
```

## Problem 45: Longest Palindromic Substring

**Category/Pattern:** DP | Expand Around Center

**Difficulty:** Medium

**Problem:**
Return the longest palindromic substring in s.

**Examples:**
- Input: s = "babad"
Output: "bab"

**Approach:**
Expand around each character and center between two chars. Track max length.

**Code:**
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ""
        for i in range(len(s)):
            res = max(res, self.helper(s, i, i), self.helper(s, i, i+1), key=len)
        return res

    def helper(self, s, l, r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1
            r += 1
        return s[l+1:r]
```

## Problem 46: Palindromic Substrings

**Category/Pattern:** DP | Expand Around Center

**Difficulty:** Medium

**Problem:**
Return the number of palindromic substrings in s.

**Examples:**
- Input: s = "abc"
Output: 3

**Approach:**
Expand around every character and count valid palindromes.

**Code:**
```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        def countPalindromes(l, r):
            res = 0
            while l >= 0 and r < len(s) and s[l] == s[r]:
                res += 1
                l -= 1
                r += 1
            return res
        res = 0
        for i in range(len(s)):
            res += countPalindromes(i, i)
            res += countPalindromes(i, i+1)
        return res
```

## Problem 47: Encode and Decode Strings

**Category/Pattern:** String | Design

**Difficulty:** Medium

**Problem:**
Design an algorithm to encode a list of strings to a single string, and decode it back.

**Examples:**
- Input: ["lint","code","love","you"]
Output: same after encode/decode

**Approach:**
Encode each string with its length followed by a special character (e.g. '#'), then the string. Decode by parsing length and extracting that many characters.

**Code:**
```python
class Codec:
    def encode(self, strs: List[str]) -> str:
        return ''.join([str(len(s)) + '#' + s for s in strs])
    
    def decode(self, s: str) -> List[str]:
        res, i = [], 0
        while i < len(s):
            j = i
            while s[j] != '#':
                j += 1
            length = int(s[i:j])
            res.append(s[j+1:j+1+length])
            i = j + 1 + length
        return res
```

## Problem 48: Valid Palindrome

**Category/Pattern:** Two Pointers | String

**Difficulty:** Medium

**Problem:**
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

**Examples:**
- Input: s = "A man, a plan, a canal: Panama"
Output: true

**Approach:**
Use two pointers to skip non-alphanumeric characters and compare lowercased letters.

**Code:**
```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        l, r = 0, len(s) - 1
        while l < r:
            while l < r and not s[l].isalnum():
                l += 1
            while l < r and not s[r].isalnum():
                r -= 1
            if s[l].lower() != s[r].lower():
                return False
            l += 1
            r -= 1
        return True
```

## Problem 49: Valid Palindrome II

**Category/Pattern:** Two Pointers

**Difficulty:** Medium

**Problem:**
Return true if the string can be a palindrome after deleting at most one character.

**Examples:**
- Input: s = "abca"
Output: true

**Approach:**
Use two pointers. When mismatch occurs, skip either side and check if either half is a palindrome.

**Code:**
```python
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def isPali(l, r):
            while l < r:
                if s[l] != s[r]:
                    return False
                l += 1
                r -= 1
            return True
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] != s[r]:
                return isPali(l+1, r) or isPali(l, r-1)
            l += 1
            r -= 1
        return True
```

## Problem 50: Trapping Rain Water

**Category/Pattern:** Array | Two Pointers | Stack

**Difficulty:** Hard

**Problem:**
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

**Examples:**
- Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

**Approach:**
Use two pointers to track left max and right max. Water trapped = min(left_max, right_max) - height[i].

**Code:**
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        l, r = 0, len(height) - 1
        leftMax, rightMax = height[l], height[r]
        res = 0
        while l < r:
            if leftMax < rightMax:
                l += 1
                leftMax = max(leftMax, height[l])
                res += leftMax - height[l]
            else:
                r -= 1
                rightMax = max(rightMax, height[r])
                res += rightMax - height[r]
        return res
```

## Problem 51: Backspace String Compare

**Category/Pattern:** Stack | Two Pointers

**Difficulty:** Medium

**Problem:**
Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

**Examples:**
- Input: s = "ab#c", t = "ad#c"
Output: true

**Approach:**
Simulate typing with a stack or compare from the end with a skip counter.

**Code:**
```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def build(string):
            stack = []
            for c in string:
                if c != '#':
                    stack.append(c)
                elif stack:
                    stack.pop()
            return stack
        return build(s) == build(t)
```

## Problem 52: Evaluate Reverse Polish Notation

**Category/Pattern:** Stack | Math

**Difficulty:** Medium

**Problem:**
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

**Examples:**
- Input: tokens = ["2","1","+","3","*"]
Output: 9

**Approach:**
Use a stack. Push operands and apply operations as you go. Handle division carefully.

**Code:**
```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token not in "+-*/":
                stack.append(int(token))
            else:
                b, a = stack.pop(), stack.pop()
                if token == "+":
                    stack.append(a + b)
                elif token == "-":
                    stack.append(a - b)
                elif token == "*":
                    stack.append(a * b)
                else:
                    stack.append(int(a / b))
        return stack[0]
```

## Problem 53: Generate Parentheses

**Category/Pattern:** Backtracking

**Difficulty:** Medium

**Problem:**
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

**Examples:**
- Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]

**Approach:**
Use backtracking. Add '(' if open < n. Add ')' if close < open.

**Code:**
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def backtrack(s="", open=0, close=0):
            if len(s) == 2 * n:
                res.append(s)
                return
            if open < n:
                backtrack(s + "(", open + 1, close)
            if close < open:
                backtrack(s + ")", open, close + 1)
        backtrack()
        return res
```

## Problem 54: Daily Temperatures

**Category/Pattern:** Stack | Monotonic Stack

**Difficulty:** Medium

**Problem:**
Given a list of daily temperatures, return a list such that each element tells you how many days until a warmer temperature.

**Examples:**
- Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]

**Approach:**
Use a stack to track indices. For each temp, pop until current is warmer, calculate wait.

**Code:**
```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        res = [0] * len(temperatures)
        stack = []
        for i, t in enumerate(temperatures):
            while stack and temperatures[stack[-1]] < t:
                idx = stack.pop()
                res[idx] = i - idx
            stack.append(i)
        return res
```

## Problem 55: Car Fleet

**Category/Pattern:** Monotonic Stack | Greedy

**Difficulty:** Medium

**Problem:**
Given target and arrays of position and speed, return the number of car fleets that will arrive at the destination.

**Examples:**
- Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3

**Approach:**
Sort cars by position descending. Compute time to reach target and use stack to merge fleets.

**Code:**
```python
class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = sorted(zip(position, speed), reverse=True)
        stack = []
        for p, s in pair:
            time = (target - p) / s
            if not stack or time > stack[-1]:
                stack.append(time)
        return len(stack)
```

## Problem 56: Largest Rectangle in Histogram

**Category/Pattern:** Monotonic Stack

**Difficulty:** Medium

**Problem:**
Given an array of integers heights representing the histogram's bar height, return the area of the largest rectangle in the histogram.

**Examples:**
- Input: heights = [2,1,5,6,2,3]
Output: 10

**Approach:**
Use a stack to track increasing bars. Pop and compute area when current bar is smaller.

**Code:**
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        max_area = 0
        heights.append(0)
        for i, h in enumerate(heights):
            while stack and h < heights[stack[-1]]:
                height = heights[stack.pop()]
                width = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, height * width)
            stack.append(i)
        return max_area
```

## Problem 57: Asteroid Collision

**Category/Pattern:** Stack | Simulation

**Difficulty:** Medium

**Problem:**
Simulate asteroid collisions. If two meet, smaller explodes; same size both explode. Return remaining asteroids.

**Examples:**
- Input: asteroids = [5,10,-5]
Output: [5,10]

**Approach:**
Use stack. Compare incoming asteroid with top and resolve collisions until stable.

**Code:**
```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for a in asteroids:
            while stack and a < 0 < stack[-1]:
                if stack[-1] < -a:
                    stack.pop()
                    continue
                elif stack[-1] == -a:
                    stack.pop()
                break
            else:
                stack.append(a)
        return stack
```

## Problem 58: Minimum Remove to Make Valid Parentheses

**Category/Pattern:** Stack | String

**Difficulty:** Medium

**Problem:**
Given a string s of '(' , ')' and lowercase English characters. Remove the minimum number of parentheses to make the input string valid.

**Examples:**
- Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"

**Approach:**
Use a stack to track indices of open parentheses. Remove unmatched open and close parentheses.

**Code:**
```python
class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        s = list(s)
        stack = []
        for i, c in enumerate(s):
            if c == '(':
                stack.append(i)
            elif c == ')':
                if stack:
                    stack.pop()
                else:
                    s[i] = ''
        while stack:
            s[stack.pop()] = ''
        return ''.join(s)
```

## Problem 59: Merge Intervals

**Category/Pattern:** Sorting | Intervals

**Difficulty:** Medium

**Problem:**
Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals.

**Examples:**
- Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]

**Approach:**
Sort intervals by start. Merge if current start <= previous end.

**Code:**
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        merged = [intervals[0]]
        for start, end in intervals[1:]:
            if start <= merged[-1][1]:
                merged[-1][1] = max(merged[-1][1], end)
            else:
                merged.append([start, end])
        return merged
```

## Problem 60: Insert Interval

**Category/Pattern:** Intervals

**Difficulty:** Medium

**Problem:**
Given a list of non-overlapping intervals and a new interval, insert and merge if necessary.

**Examples:**
- Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

**Approach:**
Iterate and add intervals before, merging as needed, then add the rest.

**Code:**
```python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []
        for i in range(len(intervals)):
            if newInterval[1] < intervals[i][0]:
                res.append(newInterval)
                return res + intervals[i:]
            elif newInterval[0] > intervals[i][1]:
                res.append(intervals[i])
            else:
                newInterval = [
                    min(newInterval[0], intervals[i][0]),
                    max(newInterval[1], intervals[i][1])
                ]
        res.append(newInterval)
        return res
```

## Problem 61: Non-overlapping Intervals

**Category/Pattern:** Greedy | Sorting

**Difficulty:** Medium

**Problem:**
Find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

**Examples:**
- Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1

**Approach:**
Sort by end. Greedily select non-overlapping intervals by keeping track of last end.

**Code:**
```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        res = 0
        prevEnd = intervals[0][1]
        for i in range(1, len(intervals)):
            if intervals[i][0] < prevEnd:
                res += 1
            else:
                prevEnd = intervals[i][1]
        return res
```

## Problem 62: Meeting Rooms

**Category/Pattern:** Intervals

**Difficulty:** Medium

**Problem:**
Given an array of meeting time intervals, determine if a person could attend all meetings.

**Examples:**
- Input: intervals = [[0,30],[5,10],[15,20]]
Output: false

**Approach:**
Sort by start time and check for any overlap.

**Code:**
```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals.sort()
        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[i - 1][1]:
                return False
        return True
```

## Problem 63: Meeting Rooms II

**Category/Pattern:** Heap | Intervals

**Difficulty:** Medium

**Problem:**
Given meeting time intervals, find the minimum number of conference rooms required.

**Examples:**
- Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2

**Approach:**
Sort by start time. Use a min-heap to track end times and determine room reuse.

**Code:**
```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        heap = []
        for interval in intervals:
            if heap and heap[0] <= interval[0]:
                heapq.heappop(heap)
            heapq.heappush(heap, interval[1])
        return len(heap)
```

## Problem 64: Merge k Sorted Lists

**Category/Pattern:** Heap | Linked List | Divide and Conquer

**Difficulty:** Medium

**Problem:**
Merge k sorted linked lists and return it as one sorted list.

**Examples:**
- Input: [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]

**Approach:**
Use a heap to keep track of the smallest current node among all lists.

**Code:**
```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        heap = []
        for i, node in enumerate(lists):
            if node:
                heapq.heappush(heap, (node.val, i, node))
        dummy = ListNode()
        curr = dummy
        while heap:
            val, i, node = heapq.heappop(heap)
            curr.next = node
            curr = curr.next
            if node.next:
                heapq.heappush(heap, (node.next.val, i, node.next))
        return dummy.next
```

## Problem 65: Find Median from Data Stream

**Category/Pattern:** Heap | Two Heaps

**Difficulty:** Medium

**Problem:**
Design a data structure that supports adding numbers and finding median efficiently.

**Examples:**
- Input: ["MedianFinder","addNum","addNum","findMedian"], [[],[1],[2],[]]
Output: [null,null,null,1.5]

**Approach:**
Use two heaps: max-heap for lower half and min-heap for upper half. Balance heaps on insert.

**Code:**
```python
class MedianFinder:
    def __init__(self):
        self.small = []  # Max heap
        self.large = []  # Min heap

    def addNum(self, num: int) -> None:
        heapq.heappush(self.small, -num)
        heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.small) < len(self.large):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    def findMedian(self) -> float:
        if len(self.small) == len(self.large):
            return (-self.small[0] + self.large[0]) / 2
        return -self.small[0]
```

## Problem 66: Kth Largest Element in an Array

**Category/Pattern:** Heap

**Difficulty:** Medium

**Problem:**
Find the kth largest element in an unsorted array.

**Examples:**
- Input: nums = [3,2,1,5,6,4], k = 2
Output: 5

**Approach:**
Use a min-heap of size k to maintain the top k elements.

**Code:**
```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return heapq.nlargest(k, nums)[-1]
```

## Problem 67: Task Scheduler

**Category/Pattern:** Greedy | Heap | Counting

**Difficulty:** Medium

**Problem:**
Given a list of tasks with cooling interval n, find the least number of units of times that the CPU will take to finish all tasks.

**Examples:**
- Input: tasks = ['A','A','A','B','B','B'], n = 2
Output: 8

**Approach:**
Count task frequencies, use a max heap. Greedily schedule most frequent tasks with idle time.

**Code:**
```python
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        count = Counter(tasks)
        max_heap = [-cnt for cnt in count.values()]
        heapq.heapify(max_heap)
        time = 0
        q = deque()  # (cnt, avail_time)

        while max_heap or q:
            time += 1
            if max_heap:
                cnt = heapq.heappop(max_heap) + 1
                if cnt:
                    q.append((cnt, time + n))
            if q and q[0][1] == time:
                heapq.heappush(max_heap, q.popleft()[0])
        return time
```

## Problem 68: Reorganize String

**Category/Pattern:** Greedy | Heap

**Difficulty:** Medium

**Problem:**
Rearrange characters of string so that no two adjacent characters are the same. If not possible, return ''.

**Examples:**
- Input: s = "aab"
Output: "aba"

**Approach:**
Use max heap for character frequencies. Alternate characters with highest frequency.

**Code:**
```python
class Solution:
    def reorganizeString(self, s: str) -> str:
        count = Counter(s)
        max_heap = [(-cnt, char) for char, cnt in count.items()]
        heapq.heapify(max_heap)
        prev = None
        res = []

        while max_heap or prev:
            if prev and not max_heap:
                return ""
            cnt, char = heapq.heappop(max_heap)
            res.append(char)
            if prev:
                heapq.heappush(max_heap, prev)
                prev = None
            if cnt + 1 < 0:
                prev = (cnt + 1, char)
        return ''.join(res)
```

## Problem 69: Minimum Number of Arrows to Burst Balloons

**Category/Pattern:** Greedy | Sorting

**Difficulty:** Medium

**Problem:**
Find the minimum number of arrows to burst all balloons represented by intervals.

**Examples:**
- Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2

**Approach:**
Sort by end of intervals. Greedily shoot arrow at earliest end covering max balloons.

**Code:**
```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: x[1])
        arrows = 1
        end = points[0][1]
        for s, e in points[1:]:
            if s > end:
                arrows += 1
                end = e
        return arrows
```

## Problem 70: Network Delay Time

**Category/Pattern:** Dijkstra | Graph

**Difficulty:** Medium

**Problem:**
Find the time it takes for all nodes to receive a signal from node k in a directed, weighted graph.

**Examples:**
- Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2

**Approach:**
Use Dijkstraâ€™s algorithm with a min heap to track shortest time to reach all nodes.

**Code:**
```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))
        min_heap = [(0, k)]
        visited = {}
        while min_heap:
            time, node = heapq.heappop(min_heap)
            if node in visited:
                continue
            visited[node] = time
            for nei, w in graph[node]:
                if nei not in visited:
                    heapq.heappush(min_heap, (time + w, nei))
        return max(visited.values()) if len(visited) == n else -1
```

## Problem 71: Swim in Rising Water

**Category/Pattern:** Heap | Dijkstra | Matrix

**Difficulty:** Hard

**Problem:**
Given a grid of elevations, find the minimum time to reach bottom right such that you can only move when water has risen to that level.

**Examples:**
- Input: grid = [[0,2],[1,3]]
Output: 3

**Approach:**
Use Dijkstra's algorithm (min-heap) where the cost is max(height so far, current cell).

**Code:**
```python
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        visited = set()
        min_heap = [(grid[0][0], 0, 0)]
        directions = [(1,0), (-1,0), (0,1), (0,-1)]

        while min_heap:
            time, r, c = heapq.heappop(min_heap)
            if (r, c) in visited:
                continue
            visited.add((r, c))
            if r == n - 1 and c == n - 1:
                return time
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited:
                    heapq.heappush(min_heap, (max(time, grid[nr][nc]), nr, nc))
```

## Problem 72: Cheapest Flights Within K Stops

**Category/Pattern:** BFS | Dijkstra | Bellman-Ford

**Difficulty:** Medium

**Problem:**
Find the cheapest flight price from src to dst with at most k stops.

**Examples:**
- Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
Output: 200

**Approach:**
Use modified Dijkstra or BFS that tracks steps as well as cost.

**Code:**
```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        graph = defaultdict(list)
        for u, v, w in flights:
            graph[u].append((v, w))
        min_heap = [(0, src, 0)]
        while min_heap:
            cost, u, stops = heapq.heappop(min_heap)
            if u == dst:
                return cost
            if stops <= k:
                for v, w in graph[u]:
                    heapq.heappush(min_heap, (cost + w, v, stops + 1))
        return -1
```

## Problem 73: Dijkstraâ€™s Algorithm (Template)

**Category/Pattern:** Graph | Shortest Path

**Difficulty:** Medium

**Problem:**
Given a graph with weighted edges, return shortest path from source to all nodes.

**Examples:**
- Input: graph = {0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)]}, src = 0
Output: {0:0,1:3,2:1,3:4}

**Approach:**
Use min-heap to pick the closest node at each step and update neighbors.

**Code:**
```python
def dijkstra(graph, start):
    heap = [(0, start)]
    dist = {}
    while heap:
        cost, node = heapq.heappop(heap)
        if node in dist:
            continue
        dist[node] = cost
        for nei, w in graph.get(node, []):
            if nei not in dist:
                heapq.heappush(heap, (cost + w, nei))
    return dist
```

## Problem 74: Bellman-Ford Algorithm (Template)

**Category/Pattern:** Graph | Shortest Path | DP

**Difficulty:** Medium

**Problem:**
Find shortest distances from a source vertex to all vertices in a weighted graph. Handles negative weights.

**Examples:**
- Input: edges = [(0,1,4),(0,2,5),(1,2,-3)], n = 3, src = 0
Output: [0,4,1]

**Approach:**
Relax all edges n-1 times. Detect negative cycle if any edge can still be relaxed.

**Code:**
```python
def bellman_ford(n, edges, src):
    dist = [float("inf")] * n
    dist[src] = 0
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    return dist
```

## Problem 75: Floyd-Warshall Algorithm (All-Pairs Shortest Path)

**Category/Pattern:** Graph | DP

**Difficulty:** Medium

**Problem:**
Find shortest paths between all pairs of nodes. Works with negative weights (no negative cycles).

**Examples:**
- Input: graph = [[0,5,INF],[INF,0,3],[INF,INF,0]]
Output: [[0,5,8],[INF,0,3],[INF,INF,0]]

**Approach:**
Use DP: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for all k.

**Code:**
```python
def floyd_warshall(graph):
    n = len(graph)
    dist = [row[:] for row in graph]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] != float('inf') and dist[k][j] != float('inf'):
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist
```

## Problem 76: Minimum Cost to Connect All Points

**Category/Pattern:** MST | Kruskal | Prim | Graph

**Difficulty:** Medium

**Problem:**
Given coordinates of n points, connect all points with minimum cost (Manhattan distance).

**Examples:**
- Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20

**Approach:**
Use Primâ€™s algorithm with min-heap to grow the MST.

**Code:**
```python
class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        dist = [float("inf")] * n
        dist[0] = 0
        visited = set()
        heap = [(0, 0)]
        total = 0
        while len(visited) < n:
            cost, u = heapq.heappop(heap)
            if u in visited:
                continue
            visited.add(u)
            total += cost
            for v in range(n):
                if v not in visited:
                    new_cost = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])
                    if new_cost < dist[v]:
                        dist[v] = new_cost
                        heapq.heappush(heap, (new_cost, v))
        return total
```

## Problem 77: Redundant Connection

**Category/Pattern:** Graph | Union Find

**Difficulty:** Medium

**Problem:**
In a tree with one extra edge added, find the edge that can be removed so the resulting graph is a tree again.

**Examples:**
- Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]

**Approach:**
Use Union-Find. The edge that connects already-connected nodes is redundant.

**Code:**
```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = [i for i in range(len(edges) + 1)]
        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x, y):
            px, py = find(x), find(y)
            if px == py:
                return False
            parent[py] = px
            return True
        for u, v in edges:
            if not union(u, v):
                return [u, v]
```

## Problem 78: Number of Connected Components in an Undirected Graph

**Category/Pattern:** Graph | Union Find | DFS

**Difficulty:** Medium

**Problem:**
Count how many connected components exist in an undirected graph.

**Examples:**
- Input: n = 5, edges = [[0,1],[1,2],[3,4]]
Output: 2

**Approach:**
Use Union-Find or DFS to track which nodes are connected.

**Code:**
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        parent = [i for i in range(n)]
        def find(x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x
        def union(x, y):
            parent[find(x)] = find(y)
        for u, v in edges:
            union(u, v)
        return len(set(find(i) for i in range(n)))
```

## Problem 79: Graph Valid Tree

**Category/Pattern:** Graph | Union Find | DFS

**Difficulty:** Medium

**Problem:**
Given n nodes and edges, return true if the edges form a valid tree.

**Examples:**
- Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true

**Approach:**
Check that the graph has n-1 edges and is fully connected (DFS or Union-Find).

**Code:**
```python
class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != n - 1:
            return False
        parent = [i for i in range(n)]
        def find(x):
            while x != parent[x]:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x
        def union(x, y):
            px, py = find(x), find(y)
            if px == py:
                return False
            parent[px] = py
            return True
        for u, v in edges:
            if not union(u, v):
                return False
        return True
```

## Problem 80: Accounts Merge

**Category/Pattern:** Graph | Union Find

**Difficulty:** Medium

**Problem:**
Given a list of accounts, merge accounts that have the same email address.

**Examples:**
- Input: [ ["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"] ]
Output: merged accounts

**Approach:**
Use Union-Find on emails. Merge sets and reconstruct from components.

**Code:**
```python
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        parent = {}
        email_to_name = {}
        def find(x):
            if x != parent.setdefault(x, x):
                parent[x] = find(parent[x])
            return parent[x]
        for acc in accounts:
            name = acc[0]
            for email in acc[1:]:
                parent.setdefault(email, email)
                email_to_name[email] = name
                union_email = acc[1]
                parent[find(email)] = find(union_email)
        unions = defaultdict(list)
        for email in parent:
            root = find(email)
            unions[root].append(email)
        return [[email_to_name[root]] + sorted(emails) for root, emails in unions.items()]
```

## Problem 81: Number of Enclaves

**Category/Pattern:** DFS | Matrix

**Difficulty:** Medium

**Problem:**
Return the number of land cells from which we cannot walk off the boundary.

**Examples:**
- Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
Output: 3

**Approach:**
Flood fill boundary-connected lands and count remaining land cells.

**Code:**
```python
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        def dfs(r, c):
            if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0):
                return
            grid[r][c] = 0
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                dfs(r+dr, c+dc)
        for r in range(rows):
            for c in [0, cols - 1]:
                dfs(r, c)
        for r in [0, rows - 1]:
            for c in range(cols):
                dfs(r, c)
        return sum(grid[r][c] == 1 for r in range(rows) for c in range(cols))
```

## Problem 82: Island Perimeter

**Category/Pattern:** Matrix | Simulation

**Difficulty:** Medium

**Problem:**
Return the perimeter of the island in the grid. Grid is surrounded by water and contains one island (one or more connected land cells).

**Examples:**
- Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16

**Approach:**
Count all 4 sides for land cells, subtract for each adjacent land neighbor.

**Code:**
```python
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        perimeter = 0
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 1:
                    perimeter += 4
                    if r > 0 and grid[r-1][c] == 1:
                        perimeter -= 2
                    if c > 0 and grid[r][c-1] == 1:
                        perimeter -= 2
        return perimeter
```

## Problem 83: Word Ladder II

**Category/Pattern:** BFS + Backtracking

**Difficulty:** Hard

**Problem:**
Find all shortest transformation sequences from beginWord to endWord.

**Examples:**
- Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: [["hit","hot","dot","dog","cog"],...]

**Approach:**
Use BFS to build graph and levels, then backtrack to reconstruct paths.

**Code:**
```python
class Solution:
    def findLadders(self, beginWord, endWord, wordList):
        wordSet = set(wordList)
        if endWord not in wordSet:
            return []
        layer = {}
        layer[beginWord] = [[beginWord]]
        while layer:
            new_layer = defaultdict(list)
            for word in layer:
                if word == endWord:
                    return layer[word]
                for i in range(len(word)):
                    for c in 'abcdefghijklmnopqrstuvwxyz':
                        newWord = word[:i] + c + word[i+1:]
                        if newWord in wordSet:
                            new_layer[newWord] += [j + [newWord] for j in layer[word]]
            wordSet -= set(new_layer.keys())
            layer = new_layer
        return []
```

## Problem 84: Minimum Genetic Mutation

**Category/Pattern:** BFS | String

**Difficulty:** Medium

**Problem:**
Return the minimum number of mutations to transform start gene to end gene using only allowed mutations.

**Examples:**
- Input: start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
Output: 1

**Approach:**
BFS where each gene in the queue represents a state. Mutate one letter at a time and check against the bank.

**Code:**
```python
class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        bank_set = set(bank)
        q = deque([(start, 0)])
        while q:
            gene, level = q.popleft()
            if gene == end:
                return level
            for i in range(len(gene)):
                for c in "ACGT":
                    mut = gene[:i] + c + gene[i+1:]
                    if mut in bank_set:
                        bank_set.remove(mut)
                        q.append((mut, level + 1))
        return -1
```

## Problem 85: Graph Valid Tree (Revisited)

**Category/Pattern:** Graph | Union Find

**Difficulty:** Medium

**Problem:**
Repeat for emphasis: check if edges form a valid tree â€” no cycles and full connectivity.

**Examples:**
- Same as Problem 99.

**Approach:**
Reinforced for mastery. Use DFS or Union-Find as needed.

**Code:**
# See Problem 99 for full implementation

## Problem 86: Graph Valid Tree (DFS Variant)

**Category/Pattern:** Graph | DFS

**Difficulty:** Medium

**Problem:**
DFS solution to check if the undirected graph is a valid tree.

**Examples:**
- Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: True

**Approach:**
Start from node 0 and explore using DFS. Ensure all nodes are visited and no cycles exist.

**Code:**
class Solution:
    def validTree(self, n, edges):
        if len(edges) != n - 1:
            return False

        graph = {i: [] for i in range(n)}
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        visited = set()
        def dfs(node, parent):
            if node in visited:
                return False
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor == parent:
                    continue
                if not dfs(neighbor, node):
                    return False
            return True

        return dfs(0, -1) and len(visited) == n

## Problem 87: Graph Valid Tree (BFS Variant)

**Category/Pattern:** Graph | BFS

**Difficulty:** Medium

**Problem:**
BFS approach to validate a graph is a tree: all nodes connected, no cycles.

**Examples:**
- Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: True

**Approach:**
Use a queue and visited set to traverse from node 0. Return False if a cycle is detected or any node is unvisited.

**Code:**
from collections import deque
class Solution:
    def validTree(self, n, edges):
        if len(edges) != n - 1:
            return False

        graph = {i: [] for i in range(n)}
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        visited = set()
        queue = deque([0])

        while queue:
            node = queue.popleft()
            if node in visited:
                return False
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)

        return len(visited) == n

## Problem 88: Is Graph Bipartite?

**Category/Pattern:** Graph | BFS | Coloring

**Difficulty:** Medium

**Problem:**
Determine whether a graph is bipartite (can color with 2 colors without conflict).

**Examples:**
- Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
Output: False

**Approach:**
Use BFS and alternate colors for adjacent nodes. If a neighbor has the same color, it's not bipartite.

**Code:**
class Solution:
    def isBipartite(self, graph):
        color = {}

        for node in range(len(graph)):
            if node not in color:
                stack = [node]
                color[node] = 0

                while stack:
                    curr = stack.pop()
                    for neighbor in graph[curr]:
                        if neighbor not in color:
                            color[neighbor] = 1 - color[curr]
                            stack.append(neighbor)
                        elif color[neighbor] == color[curr]:
                            return False
        return True

## Problem 89: Find Center of Star Graph

**Category/Pattern:** Graph

**Difficulty:** Medium

**Problem:**
Given an undirected star graph represented by its edges, return the center node.

**Examples:**
- Input: edges = [[1,2],[2,3],[4,2]]
Output: 2

**Approach:**
In a star graph, the center appears in every edge. Check the common node in the first two edges.

**Code:**
```python
class Solution:
    def findCenter(self, edges):
        a, b = edges[0]
        c, d = edges[1]
        return a if a == c or a == d else b
```

## Problem 90: Maximum Depth of N-ary Tree

**Category/Pattern:** Tree | DFS

**Difficulty:** Medium

**Problem:**
Given an N-ary tree, return its maximum depth.

**Examples:**
- Input: root = [1,null,3,2,4,null,5,6]
Output: 3

**Approach:**
Use DFS to recursively find the max depth of all children and return the max + 1.

**Code:**
```python
class Solution:
    def maxDepth(self, root):
        if not root:
            return 0
        return 1 + max((self.maxDepth(child) for child in root.children), default=0)
```

## Problem 91: Diameter of N-ary Tree

**Category/Pattern:** Tree | DFS

**Difficulty:** Medium

**Problem:**
Given an N-ary tree, return its diameter â€” the length of the longest path between any two nodes.

**Examples:**
- Input: root = [1,null,2,3,4,null,5,6,null,null,7,8,null,9,10]
Output: 7

**Approach:**
Use DFS to compute the two largest depths for each node and track the maximum path.

**Code:**
```python
class Solution:
    def diameter(self, root):
        self.max_diameter = 0
        def dfs(node):
            if not node:
                return 0
            max1 = max2 = 0
            for child in node.children:
                depth = dfs(child)
                if depth > max1:
                    max1, max2 = depth, max1
                elif depth > max2:
                    max2 = depth
            self.max_diameter = max(self.max_diameter, max1 + max2)
            return 1 + max1
        dfs(root)
        return self.max_diameter
```

## Problem 92: Flatten Binary Tree to Linked List

**Category/Pattern:** Tree | DFS

**Difficulty:** Medium

**Problem:**
Flatten a binary tree into a linked list in-place using the right pointers.

**Examples:**
- Input: root = [1,2,5,3,4,null,6]
Output: [1,null,2,null,3,null,4,null,5,null,6]

**Approach:**
Use post-order DFS to rearrange pointers in-place.

**Code:**
```python
class Solution:
    def flatten(self, root):
        if not root:
            return None
        self.flatten(root.left)
        self.flatten(root.right)

        temp = root.right
        root.right = root.left
        root.left = None

        curr = root
        while curr.right:
            curr = curr.right
        curr.right = temp
```

## Problem 93: Populating Next Right Pointers in Each Node

**Category/Pattern:** Tree | BFS

**Difficulty:** Medium

**Problem:**
Connect next pointers in each node of a perfect binary tree.

**Examples:**
- Input: root = [1,2,3,4,5,6,7]
Output: root with next pointers set

**Approach:**
Use BFS level-order traversal with a queue or connect nodes iteratively level by level.

**Code:**
```python
class Solution:
    def connect(self, root):
        if not root:
            return None
        leftmost = root
        while leftmost.left:
            head = leftmost
            while head:
                head.left.next = head.right
                if head.next:
                    head.right.next = head.next.left
                head = head.next
            leftmost = leftmost.left
        return root
```

## Problem 94: Construct Binary Tree from Inorder and Postorder Traversal

**Category/Pattern:** Tree | Recursion

**Difficulty:** Medium

**Problem:**
Given inorder and postorder traversal of a binary tree, build the tree.

**Examples:**
- Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: root of the tree

**Approach:**
Use recursion by finding the root at the end of postorder and dividing inorder accordingly.

**Code:**
```python
class Solution:
    def buildTree(self, inorder, postorder):
        if not inorder or not postorder:
            return None
        root = TreeNode(postorder.pop())
        mid = inorder.index(root.val)
        root.right = self.buildTree(inorder[mid+1:], postorder)
        root.left = self.buildTree(inorder[:mid], postorder)
        return root
```

## Problem 95: Balanced Binary Tree

**Category/Pattern:** Tree | DFS

**Difficulty:** Easy

**Problem:**
Determine if a binary tree is height-balanced.

**Examples:**
- Input: root = [3,9,20,null,null,15,7]
Output: True

**Approach:**
Use post-order DFS to calculate height. Return -1 if imbalance is found.

**Code:**
```python
class Solution:
    def isBalanced(self, root):
        def dfs(node):
            if not node:
                return 0
            left = dfs(node.left)
            right = dfs(node.right)
            if left == -1 or right == -1 or abs(left - right) > 1:
                return -1
            return 1 + max(left, right)
        return dfs(root) != -1
```

## Problem 96: Path Sum

**Category/Pattern:** Tree | DFS

**Difficulty:** Easy

**Problem:**
Check if a binary tree has a root-to-leaf path summing to a target value.

**Examples:**
- Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: True

**Approach:**
Use DFS to check for remaining sum along each root-to-leaf path.

**Code:**
```python
class Solution:
    def hasPathSum(self, root, targetSum):
        if not root:
            return False
        if not root.left and not root.right:
            return root.val == targetSum
        return (self.hasPathSum(root.left, targetSum - root.val) or 
                self.hasPathSum(root.right, targetSum - root.val))
```

## Problem 97: Right Side View

**Category/Pattern:** Tree | BFS

**Difficulty:** Medium

**Problem:**
Return the values of nodes you can see from the right side of a binary tree.

**Examples:**
- Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]

**Approach:**
Use level-order traversal and store the last node value of each level.

**Code:**
```python
class Solution:
    def rightSideView(self, root):
        if not root:
            return []
        res, q = [], deque([root])
        while q:
            level_size = len(q)
            for i in range(level_size):
                node = q.popleft()
                if i == level_size - 1:
                    res.append(node.val)
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
        return res
```

## Problem 98: Average of Levels in Binary Tree

**Category/Pattern:** Tree | BFS

**Difficulty:** Medium

**Problem:**
Return the average value of nodes on each level.

**Examples:**
- Input: root = [3,9,20,null,null,15,7]
Output: [3.00000,14.50000,11.00000]

**Approach:**
Use level-order traversal to compute sum and count of each level, then average.

**Code:**
```python
class Solution:
    def averageOfLevels(self, root):
        res, q = [], deque([root])
        while q:
            level_sum = 0
            level_size = len(q)
            for _ in range(level_size):
                node = q.popleft()
                level_sum += node.val
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
            res.append(level_sum / level_size)
        return res
```

## Problem 99: Leaf-Similar Trees

**Category/Pattern:** Tree | DFS

**Difficulty:** Easy

**Problem:**
Check if two binary trees have the same leaf node values in left-to-right order.

**Examples:**
- Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
Output: True

**Approach:**
Collect leaves from both trees using DFS and compare the resulting lists.

**Code:**
```python
class Solution:
    def leafSimilar(self, root1, root2):
        def dfs(node):
            if not node: return []
            if not node.left and not node.right:
                return [node.val]
            return dfs(node.left) + dfs(node.right)
        return dfs(root1) == dfs(root2)
```

## Problem 100: Cousins in Binary Tree

**Category/Pattern:** Tree | BFS

**Difficulty:** Easy

**Problem:**
Check if two nodes in a binary tree are cousins (same level, different parents).

**Examples:**
- Input: root = [1,2,3,4], x = 4, y = 3
Output: False

**Approach:**
Use BFS to find depths and parents of both nodes and compare.

**Code:**
```python
class Solution:
    def isCousins(self, root, x, y):
        q = deque([(root, None)])
        while q:
            size = len(q)
            x_parent = y_parent = None
            for _ in range(size):
                node, parent = q.popleft()
                if node.val == x:
                    x_parent = parent
                if node.val == y:
                    y_parent = parent
                if node.left: q.append((node.left, node))
                if node.right: q.append((node.right, node))
            if x_parent and y_parent:
                return x_parent != y_parent
            if x_parent or y_parent:
                return False
        return False
```

## Problem 101: Minimum Depth of Binary Tree

**Category/Pattern:** Tree | BFS

**Difficulty:** Easy

**Problem:**
Find the minimum depth from root to the nearest leaf node.

**Examples:**
- Input: root = [3,9,20,null,null,15,7]
Output: 2

**Approach:**
Use BFS and return the depth when the first leaf node is encountered.

**Code:**
```python
class Solution:
    def minDepth(self, root):
        if not root:
            return 0
        q = deque([(root, 1)])
        while q:
            node, depth = q.popleft()
            if not node.left and not node.right:
                return depth
            if node.left: q.append((node.left, depth + 1))
            if node.right: q.append((node.right, depth + 1))
```

## Problem 102: Diameter of Binary Tree

**Category/Pattern:** Tree | DFS

**Difficulty:** Medium

**Problem:**
Return the length of the diameter of the binary tree.

**Examples:**
- Input: root = [1,2,3,4,5]
Output: 3

**Approach:**
Use DFS to compute depth and update diameter during traversal.

**Code:**
```python
class Solution:
    def diameterOfBinaryTree(self, root):
        self.res = 0
        def dfs(node):
            if not node:
                return 0
            left = dfs(node.left)
            right = dfs(node.right)
            self.res = max(self.res, left + right)
            return 1 + max(left, right)
        dfs(root)
        return self.res
```

## Problem 103: Symmetric Tree

**Category/Pattern:** Tree | DFS

**Difficulty:** Easy

**Problem:**
Check if a tree is symmetric around its center.

**Examples:**
- Input: root = [1,2,2,3,4,4,3]
Output: True

**Approach:**
Use recursive helper to compare left and right subtrees.

**Code:**
```python
class Solution:
    def isSymmetric(self, root):
        def isMirror(t1, t2):
            if not t1 and not t2: return True
            if not t1 or not t2: return False
            return (t1.val == t2.val and
                    isMirror(t1.right, t2.left) and
                    isMirror(t1.left, t2.right))
        return isMirror(root, root)
```

## Problem 104: Populating Next Right Pointers in Each Node II

**Category/Pattern:** Tree | BFS

**Difficulty:** Medium

**Problem:**
Connect each node to its right node in the same level (non-perfect binary tree).

**Examples:**
- Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]

**Approach:**
Use BFS with a queue or dummy node technique for linking.

**Code:**
```python
class Solution:
    def connect(self, root):
        if not root:
            return None
        q = deque([root])
        while q:
            size = len(q)
            prev = None
            for _ in range(size):
                node = q.popleft()
                if prev:
                    prev.next = node
                prev = node
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
        return root
```

## Problem 105: Insert into a Binary Search Tree

**Category/Pattern:** Tree | BST

**Difficulty:** Easy

**Problem:**
Insert a value into a Binary Search Tree (BST) and return the tree's root.

**Examples:**
- Input: root = [4,2,7,1,3], val = 5
Output: [4,2,7,1,3,5]

**Approach:**
Recursively or iteratively traverse the tree to find the correct location to insert the value.

**Code:**
```python
class Solution:
    def insertIntoBST(self, root, val):
        if not root:
            return TreeNode(val)
        if val < root.val:
            root.left = self.insertIntoBST(root.left, val)
        else:
            root.right = self.insertIntoBST(root.right, val)
        return root
```

## Problem 106: Add Two Numbers

**Category/Pattern:** Linked List | Math

**Difficulty:** Medium

**Problem:**
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order. Add the two numbers and return the sum as a linked list.

**Examples:**
- Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]

**Approach:**
Simulate addition digit by digit using a dummy head node and a carry variable.

**Code:**
```python
class Solution:
    def addTwoNumbers(self, l1, l2):
        dummy = ListNode(0)
        current, carry = dummy, 0
        while l1 or l2 or carry:
            val = carry
            if l1:
                val += l1.val
                l1 = l1.next
            if l2:
                val += l2.val
                l2 = l2.next
            carry, val = divmod(val, 10)
            current.next = ListNode(val)
            current = current.next
        return dummy.next
```

## Problem 107: Median of Two Sorted Arrays

**Category/Pattern:** Binary Search | Array

**Difficulty:** Hard

**Problem:**
Given two sorted arrays, return the median of the two sorted arrays.

**Examples:**
- Input: nums1 = [1,3], nums2 = [2]
Output: 2.0

**Approach:**
Use binary search on the smaller array to partition both arrays and find the correct median position.

**Code:**
```python
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        A, B = nums1, nums2
        if len(A) > len(B):
            A, B = B, A
        total = len(A) + len(B)
        half = total // 2

        l, r = 0, len(A) - 1
        while True:
            i = (l + r) // 2
            j = half - i - 2

            Aleft = A[i] if i >= 0 else float('-inf')
            Aright = A[i+1] if i+1 < len(A) else float('inf')
            Bleft = B[j] if j >= 0 else float('-inf')
            Bright = B[j+1] if j+1 < len(B) else float('inf')

            if Aleft <= Bright and Bleft <= Aright:
                if total % 2:
                    return min(Aright, Bright)
                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
            elif Aleft > Bright:
                r = i - 1
            else:
                l = i + 1
```

## Problem 108: Zigzag Conversion

**Category/Pattern:** String | Simulation

**Difficulty:** Medium

**Problem:**
Convert a string to a zigzag pattern on a given number of rows and then read line by line.

**Examples:**
- Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"

**Approach:**
Simulate row-wise traversal in zigzag fashion and concatenate the result rows.

**Code:**
```python
class Solution:
    def convert(self, s, numRows):
        if numRows == 1 or numRows >= len(s):
            return s

        rows = [''] * numRows
        index, step = 0, 1

        for c in s:
            rows[index] += c
            if index == 0:
                step = 1
            elif index == numRows - 1:
                step = -1
            index += step

        return ''.join(rows)
```

## Problem 109: Jump Game

**Category/Pattern:** Greedy | Array

**Difficulty:** Medium

**Problem:**
Given an array of non-negative integers, determine if you can reach the last index.

**Examples:**
- Input: nums = [2,3,1,1,4]
Output: True

**Approach:**
Track the furthest reachable index as you iterate through the array.

**Code:**
```python
class Solution:
    def canJump(self, nums):
        maxReach = 0
        for i, jump in enumerate(nums):
            if i > maxReach:
                return False
            maxReach = max(maxReach, i + jump)
        return True
```

## Problem 110: Jump Game II

**Category/Pattern:** Greedy | Array

**Difficulty:** Medium

**Problem:**
Return the minimum number of jumps to reach the end of the array.

**Examples:**
- Input: nums = [2,3,1,1,4]
Output: 2

**Approach:**
Use greedy window-based strategy to count jumps within current range.

**Code:**
```python
class Solution:
    def jump(self, nums):
        jumps = curEnd = curFarthest = 0
        for i in range(len(nums) - 1):
            curFarthest = max(curFarthest, i + nums[i])
            if i == curEnd:
                jumps += 1
                curEnd = curFarthest
        return jumps
```

## Problem 111: Set Matrix Zeroes

**Category/Pattern:** Matrix | Simulation

**Difficulty:** Medium

**Problem:**
Given an m x n matrix, if an element is 0, set its entire row and column to 0.

**Examples:**
- Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]

**Approach:**
Use first row and column as flags to mark which rows and columns to zero out.

**Code:**
```python
class Solution:
    def setZeroes(self, matrix):
        m, n = len(matrix), len(matrix[0])
        row_zero = any(matrix[0][j] == 0 for j in range(n))
        col_zero = any(matrix[i][0] == 0 for i in range(m))

        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] == 0:
                    matrix[i][0] = matrix[0][j] = 0

        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0

        if row_zero:
            for j in range(n):
                matrix[0][j] = 0
        if col_zero:
            for i in range(m):
                matrix[i][0] = 0
```

## Problem 112: Spiral Matrix

**Category/Pattern:** Matrix | Simulation

**Difficulty:** Easy

**Problem:**
Return all elements of the matrix in spiral order.

**Examples:**
- Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]

**Approach:**
Use four boundary pointers and shrink them inward while traversing the matrix.

**Code:**
```python
class Solution:
    def spiralOrder(self, matrix):
        res = []
        while matrix:
            res += matrix.pop(0)
            if matrix and matrix[0]:
                for row in matrix:
                    res.append(row.pop())
            if matrix:
                res += matrix.pop()[::-1]
            if matrix and matrix[0]:
                for row in matrix[::-1]:
                    res.append(row.pop(0))
        return res
```

## Problem 113: Rotate Image

**Category/Pattern:** Matrix | In-Place

**Difficulty:** Medium

**Problem:**
Rotate the image (2D matrix) by 90 degrees clockwise in-place.

**Examples:**
- Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]

**Approach:**
Transpose the matrix then reverse each row.

**Code:**
```python
class Solution:
    def rotate(self, matrix):
        n = len(matrix)
        for i in range(n):
            for j in range(i+1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        for row in matrix:
            row.reverse()
```

## Problem 114: Word Break

**Category/Pattern:** DP | String

**Difficulty:** Easy

**Problem:**
Return true if the input string can be segmented into space-separated words in the dictionary.

**Examples:**
- Input: s = "leetcode", wordDict = ["leet","code"]
Output: True

**Approach:**
Use dynamic programming to track possible segmentations up to each index.

**Code:**
```python
class Solution:
    def wordBreak(self, s, wordDict):
        wordSet = set(wordDict)
        dp = [False] * (len(s)+1)
        dp[0] = True

        for i in range(1, len(s)+1):
            for j in range(i):
                if dp[j] and s[j:i] in wordSet:
                    dp[i] = True
                    break
        return dp[-1]
```

## Problem 115: Word Break II

**Category/Pattern:** DP | Backtracking

**Difficulty:** Medium

**Problem:**
Return all possible sentences from the string using words in the dictionary.

**Examples:**
- Input: s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
Output: ["cats and dog","cat sand dog"]

**Approach:**
Use backtracking with memoization to build valid word sequences.

**Code:**
```python
class Solution:
    def wordBreak(self, s, wordDict):
        memo = {}
        wordSet = set(wordDict)

        def dfs(s):
            if s in memo:
                return memo[s]
            if not s:
                return [""]
            res = []
            for word in wordSet:
                if s.startswith(word):
                    for sub in dfs(s[len(word):]):
                        res.append(word + (" " + sub if sub else ""))
            memo[s] = res
            return res

        return dfs(s)
```

## Problem 116: LRU Cache

**Category/Pattern:** Design | HashMap | Linked List

**Difficulty:** Medium

**Problem:**
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

**Examples:**
- Input: ["LRUCache","put","put","get","put","get","put","get","get","get"]
       [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
Output: [null,null,null,1,null,-1,null,-1,3,4]

**Approach:**
Use OrderedDict in Python or a hashmap + doubly linked list for O(1) operations.

**Code:**
```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

## Problem 117: LFU Cache

**Category/Pattern:** Design | Heap | HashMap

**Difficulty:** Hard

**Problem:**
Design a data structure that follows the constraints of a Least Frequently Used (LFU) cache.

**Examples:**
- Input: ["LFUCache","put","put","get","put","get","get","put","get","get","get"]
       [[2],[1,1],[2,2],[1],[3,3],[2],[3],[4,4],[1],[3],[4]]
Output: [null,null,null,1,null,-1,3,null,-1,3,4]

**Approach:**
Use two hashmaps to track frequency and values, with an eviction policy based on least freq.

**Code:**
```python
from collections import defaultdict, OrderedDict

class LFUCache:
    def __init__(self, capacity: int):
        self.cap = capacity
        self.key_to_val = {}
        self.key_to_freq = {}
        self.freq_to_keys = defaultdict(OrderedDict)
        self.min_freq = 0

    def update_freq(self, key):
        freq = self.key_to_freq[key]
        del self.freq_to_keys[freq][key]
        if not self.freq_to_keys[freq]:
            del self.freq_to_keys[freq]
            if freq == self.min_freq:
                self.min_freq += 1
        self.key_to_freq[key] = freq + 1
        self.freq_to_keys[freq + 1][key] = None

    def get(self, key: int) -> int:
        if key not in self.key_to_val:
            return -1
        self.update_freq(key)
        return self.key_to_val[key]

    def put(self, key: int, value: int) -> None:
        if self.cap == 0:
            return
        if key in self.key_to_val:
            self.key_to_val[key] = value
            self.update_freq(key)
        else:
            if len(self.key_to_val) >= self.cap:
                evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)
                del self.key_to_val[evict_key]
                del self.key_to_freq[evict_key]
            self.key_to_val[key] = value
            self.key_to_freq[key] = 1
            self.freq_to_keys[1][key] = None
            self.min_freq = 1
```

## Problem 118: Sliding Window Median

**Category/Pattern:** Heap | Sliding Window

**Difficulty:** Hard

**Problem:**
Given an array, find the median of each sliding window of size k.

**Examples:**
- Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1,-1,-1,3,5,6]

**Approach:**
Use two heaps (max-heap and min-heap) to keep balance between lower and upper halves.

**Code:**
```python
import heapq

class DualHeap:
    def __init__(self, k):
        self.small = []
        self.large = []
        self.delayed = {}
        self.k = k
        self.small_size = 0
        self.large_size = 0

    def prune(self, heap):
        while heap and self.delayed.get(heap[0][1], 0):
            val = heap[0][1]
            self.delayed[val] -= 1
            if self.delayed[val] == 0:
                del self.delayed[val]
            heapq.heappop(heap)

    def balance(self):
        if self.small_size > self.large_size + 1:
            val = heapq.heappop(self.small)[1]
            heapq.heappush(self.large, (val, val))
            self.small_size -= 1
            self.large_size += 1
        elif self.small_size < self.large_size:
            val = heapq.heappop(self.large)[1]
            heapq.heappush(self.small, (-val, val))
            self.small_size += 1
            self.large_size -= 1

    def insert(self, num):
        if not self.small or num <= self.small[0][1]:
            heapq.heappush(self.small, (-num, num))
            self.small_size += 1
        else:
            heapq.heappush(self.large, (num, num))
            self.large_size += 1
        self.balance()

    def erase(self, num):
        self.delayed[num] = self.delayed.get(num, 0) + 1
        if num <= self.small[0][1]:
            self.small_size -= 1
            if num == self.small[0][1]:
                self.prune(self.small)
        else:
            self.large_size -= 1
            if num == self.large[0][1]:
                self.prune(self.large)
        self.balance()

    def getMedian(self):
        return float(self.small[0][1]) if self.k % 2 == 1 else (self.small[0][1] + self.large[0][1]) / 2

class Solution:
    def medianSlidingWindow(self, nums, k):
        dh = DualHeap(k)
        res = []
        for i in range(k):
            dh.insert(nums[i])
        res.append(dh.getMedian())

        for i in range(k, len(nums)):
            dh.insert(nums[i])
            dh.erase(nums[i - k])
            res.append(dh.getMedian())

        return res
```

## Problem 119: Design Twitter

**Category/Pattern:** Design | Heap | HashMap

**Difficulty:** Medium

**Problem:**
Design a simplified version of Twitter with basic tweet and follow functionalities.

**Examples:**
- Input: ["Twitter","postTweet","getNewsFeed","follow","getNewsFeed"]
       [[],[1,5],[1],[1,2],[1]]
Output: [null,null,[5],null,[5]]

**Approach:**
Use a global timestamp and per-user heaps for tweet retrieval. Track follow relations with sets.

**Code:**
```python
import heapq
from collections import defaultdict

class Twitter:
    def __init__(self):
        self.timer = 0
        self.user_tweets = defaultdict(list)
        self.following = defaultdict(set)

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.user_tweets[userId].append((self.timer, tweetId))
        self.timer -= 1

    def getNewsFeed(self, userId: int):
        heap = []
        users = self.following[userId] | {userId}
        for uid in users:
            for tweet in self.user_tweets[uid][-10:]:
                heapq.heappush(heap, tweet)
        return [tweet for _, tweet in sorted(heap, reverse=True)[:10]]

    def follow(self, followerId: int, followeeId: int) -> None:
        if followerId != followeeId:
            self.following[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        self.following[followerId].discard(followeeId)
```

## Problem 120: Unique Paths

**Category/Pattern:** Dynamic Programming | Grid

**Difficulty:** Easy

**Problem:**
A robot is located at the top-left corner of a m x n grid. How many unique paths are there to reach the bottom-right corner?

**Examples:**
- Input: m = 3, n = 7
Output: 28

**Approach:**
Use a 2D DP table or optimized 1D array to compute paths from bottom up.

**Code:**
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [1] * n
        for _ in range(1, m):
            for j in range(1, n):
                dp[j] += dp[j - 1]
        return dp[-1]
```

## Problem 121: Unique Paths II

**Category/Pattern:** Dynamic Programming | Grid

**Difficulty:** Medium

**Problem:**
A robot is on a grid with obstacles. Compute how many paths exist from top-left to bottom-right avoiding obstacles.

**Examples:**
- Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2

**Approach:**
Use a 2D DP table accounting for obstacle cells (marked as 1).

**Code:**
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        if obstacleGrid[0][0] == 1: return 0
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[0]*n for _ in range(m)]
        dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1: continue
                if i > 0: dp[i][j] += dp[i-1][j]
                if j > 0: dp[i][j] += dp[i][j-1]
        return dp[-1][-1]
```

## Problem 122: Edit Distance

**Category/Pattern:** Dynamic Programming | String

**Difficulty:** Hard

**Problem:**
Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.

**Examples:**
- Input: word1 = "horse", word2 = "ros"
Output: 3

**Approach:**
Use a 2D DP table with insert, delete, and replace operations.

**Code:**
```python
class Solution:
    def minDistance(self, word1, word2):
        m, n = len(word1), len(word2)
        dp = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m+1):
            for j in range(n+1):
                if i == 0: dp[i][j] = j
                elif j == 0: dp[i][j] = i
                elif word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
        return dp[m][n]
```

## Problem 123: Minimum Path Sum

**Category/Pattern:** Dynamic Programming | Grid

**Difficulty:** Medium

**Problem:**
Find a path from top-left to bottom-right which minimizes the sum of all numbers along its path.

**Examples:**
- Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7

**Approach:**
Update grid in-place using bottom-up DP to track minimum sum to each cell.

**Code:**
```python
class Solution:
    def minPathSum(self, grid):
        m, n = len(grid), len(grid[0])
        for i in range(1, n):
            grid[0][i] += grid[0][i-1]
        for i in range(1, m):
            grid[i][0] += grid[i-1][0]
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
        return grid[-1][-1]
```

## Problem 124: House Robber

**Category/Pattern:** Dynamic Programming | Array

**Difficulty:** Easy

**Problem:**
You are a professional robber planning to rob houses along a street. No two adjacent houses can be robbed.

**Examples:**
- Input: nums = [2,7,9,3,1]
Output: 12

**Approach:**
Use DP with two choices: rob current house or skip it.

**Code:**
```python
class Solution:
    def rob(self, nums):
        rob1, rob2 = 0, 0
        for n in nums:
            rob1, rob2 = rob2, max(n + rob1, rob2)
        return rob2
```

## Problem 125: House Robber II

**Category/Pattern:** Dynamic Programming | Array | Circular

**Difficulty:** Medium

**Problem:**
Houses are arranged in a circle. Cannot rob both the first and last house.

**Examples:**
- Input: nums = [2,3,2]
Output: 3

**Approach:**
Use House Robber logic twice â€” once excluding first house, once excluding last.

**Code:**
```python
class Solution:
    def rob(self, nums):
        if len(nums) == 1:
            return nums[0]
        
        def helper(nums):
            rob1, rob2 = 0, 0
            for n in nums:
                rob1, rob2 = rob2, max(n + rob1, rob2)
            return rob2
        
        return max(helper(nums[1:]), helper(nums[:-1]))
```

## Problem 126: Coin Change

**Category/Pattern:** Dynamic Programming | Greedy

**Difficulty:** Easy

**Problem:**
You are given coins of different denominations. Return the fewest number of coins to make up a given amount.

**Examples:**
- Input: coins = [1,2,5], amount = 11
Output: 3

**Approach:**
Use bottom-up DP to fill in minimum coins required for each amount.

**Code:**
```python
class Solution:
    def coinChange(self, coins, amount):
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1
```

## Problem 127: Combination Sum

**Category/Pattern:** Backtracking | Recursion

**Difficulty:** Easy

**Problem:**
Return all unique combinations in candidates where the candidate numbers sum to target.

**Examples:**
- Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]

**Approach:**
Use DFS recursion with backtracking to try all valid paths.

**Code:**
```python
class Solution:
    def combinationSum(self, candidates, target):
        res = []
        def backtrack(start, path, total):
            if total == target:
                res.append(path[:])
                return
            if total > target:
                return
            for i in range(start, len(candidates)):
                path.append(candidates[i])
                backtrack(i, path, total + candidates[i])
                path.pop()
        backtrack(0, [], 0)
        return res
```

## Problem 128: Combination Sum II

**Category/Pattern:** Backtracking | Recursion | Duplicate Handling

**Difficulty:** Medium

**Problem:**
Each number can only be used once. Return all unique combinations summing to target.

**Examples:**
- Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: [[1,1,6],[1,2,5],[1,7],[2,6]]

**Approach:**
Sort input to skip duplicates. Use backtracking with index increment.

**Code:**
```python
class Solution:
    def combinationSum2(self, candidates, target):
        res = []
        candidates.sort()
        def backtrack(start, path, total):
            if total == target:
                res.append(path[:])
                return
            for i in range(start, len(candidates)):
                if i > start and candidates[i] == candidates[i-1]:
                    continue
                if total + candidates[i] > target:
                    break
                path.append(candidates[i])
                backtrack(i+1, path, total + candidates[i])
                path.pop()
        backtrack(0, [], 0)
        return res
```

## Problem 129: Palindrome Partitioning

**Category/Pattern:** Backtracking | String

**Difficulty:** Medium

**Problem:**
Partition a string such that every substring is a palindrome. Return all possible results.

**Examples:**
- Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]

**Approach:**
Use DFS backtracking and expand partitions where each cut is a palindrome.

**Code:**
```python
class Solution:
    def partition(self, s):
        res = []
        def backtrack(start, path):
            if start == len(s):
                res.append(path[:])
                return
            for end in range(start + 1, len(s) + 1):
                if self.isPalindrome(s[start:end]):
                    path.append(s[start:end])
                    backtrack(end, path)
                    path.pop()
        backtrack(0, [])
        return res
    
    def isPalindrome(self, s):
        return s == s[::-1]
```

## Problem 130: Search a 2D Matrix

**Category/Pattern:** Binary Search | Matrix

**Difficulty:** Easy

**Problem:**
Write an efficient algorithm to search for a target value in a 2D matrix with sorted rows and columns.

**Examples:**
- Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true

**Approach:**
Treat the 2D matrix as a 1D sorted array and perform binary search.

**Code:**
```python
class Solution:
    def searchMatrix(self, matrix, target):
        if not matrix or not matrix[0]:
            return False
        m, n = len(matrix), len(matrix[0])
        left, right = 0, m * n - 1
        while left <= right:
            mid = (left + right) // 2
            mid_val = matrix[mid // n][mid % n]
            if mid_val == target:
                return True
            elif mid_val < target:
                left = mid + 1
            else:
                right = mid - 1
        return False
```

## Problem 131: Search in Rotated Sorted Array

**Category/Pattern:** Binary Search | Array

**Difficulty:** Medium

**Problem:**
Search target in a rotated sorted array with no duplicates.

**Examples:**
- Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

**Approach:**
Use modified binary search to identify the sorted half and narrow down.

**Code:**
```python
class Solution:
    def search(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

## Problem 132: Find Minimum in Rotated Sorted Array

**Category/Pattern:** Binary Search | Array

**Difficulty:** Medium

**Problem:**
Find the minimum element in a rotated sorted array with no duplicates.

**Examples:**
- Input: nums = [3,4,5,1,2]
Output: 1

**Approach:**
Use binary search to find the point of rotation (minimum).

**Code:**
```python
class Solution:
    def findMin(self, nums):
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

## Problem 133: Search in Rotated Sorted Array II

**Category/Pattern:** Binary Search | Duplicates

**Difficulty:** Medium

**Problem:**
Search target in a rotated sorted array that may contain duplicates.

**Examples:**
- Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true

**Approach:**
Same as regular rotated binary search, but skip duplicates when needed.

**Code:**
```python
class Solution:
    def search(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return True
            if nums[left] == nums[mid] == nums[right]:
                left += 1
                right -= 1
            elif nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return False
```

## Problem 134: Pow(x, n)

**Category/Pattern:** Math | Divide and Conquer

**Difficulty:** Easy

**Problem:**
Implement pow(x, n), which calculates x raised to the power n (x^n).

**Examples:**
- Input: x = 2.00000, n = 10
Output: 1024.00000

**Approach:**
Use fast exponentiation by squaring with recursion or iteration.

**Code:**
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0: return 1
        if n < 0: return 1 / self.myPow(x, -n)
        if n % 2:
            return x * self.myPow(x * x, n // 2)
        else:
            return self.myPow(x * x, n // 2)
```

## Problem 135: Implement Trie (Prefix Tree)

**Category/Pattern:** Trie | Design

**Difficulty:** Medium

**Problem:**
Implement a trie with insert, search, and startsWith methods.

**Examples:**
- Input: ["Trie", "insert", "search", "startsWith"], [[], ["apple"], ["apple"], ["app"]]
Output: [null, null, true, true]

**Approach:**
Use nested dictionaries or node objects to represent children for each character.

**Code:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.endOfWord = True

    def search(self, word):
        node = self.root
        for c in word:
            if c not in node.children:
                return False
            node = node.children[c]
        return node.endOfWord

    def startsWith(self, prefix):
        node = self.root
        for c in prefix:
            if c not in node.children:
                return False
            node = node.children[c]
        return True
```

## Problem 136: Design Add and Search Words Data Structure

**Category/Pattern:** Trie | Backtracking

**Difficulty:** Medium

**Problem:**
Add and search words with support for wildcard '.' character.

**Examples:**
- Input: wordDictionary.add("bad"), wordDictionary.search(".ad")
Output: true

**Approach:**
Use Trie and DFS to handle wildcard search.

**Code:**
```python
class WordDictionary:
    def __init__(self):
        self.root = {}

    def addWord(self, word):
        node = self.root
        for c in word:
            if c not in node:
                node[c] = {}
            node = node[c]
        node['$'] = True

    def search(self, word):
        def dfs(j, node):
            for i in range(j, len(word)):
                if word[i] == '.':
                    for child in node:
                        if child != '$' and dfs(i + 1, node[child]):
                            return True
                    return False
                if word[i] not in node:
                    return False
                node = node[word[i]]
            return '$' in node
        return dfs(0, self.root)
```

## Problem 137: Find Peak Element

**Category/Pattern:** Binary Search

**Difficulty:** Easy

**Problem:**
Find a peak element and return its index. An element is a peak if it is greater than its neighbors.

**Examples:**
- Input: nums = [1,2,3,1]
Output: 2

**Approach:**
Binary search using mid comparison with mid+1 to guide direction.

**Code:**
```python
class Solution:
    def findPeakElement(self, nums):
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1
        return left
```

## Problem 138: Count of Smaller Numbers After Self

**Category/Pattern:** Binary Indexed Tree | Merge Sort

**Difficulty:** Medium

**Problem:**
Given an integer array, return a list of the counts of smaller numbers to the right of each element.

**Examples:**
- Input: nums = [5,2,6,1]
Output: [2,1,1,0]

**Approach:**
Use modified merge sort to count during the merge step.

**Code:**
```python
class Solution:
    def countSmaller(self, nums):
        res = [0] * len(nums)
        indices = list(range(len(nums)))
        def merge_sort(left, right):
            if left >= right:
                return
            mid = (left + right) // 2
            merge_sort(left, mid)
            merge_sort(mid + 1, right)
            temp = []
            i, j = left, mid + 1
            while i <= mid and j <= right:
                if nums[indices[i]] <= nums[indices[j]]:
                    temp.append(indices[j])
                    j += 1
                else:
                    res[indices[i]] += right - j + 1
                    temp.append(indices[i])
                    i += 1
            temp.extend(indices[i:mid+1])
            temp.extend(indices[j:right+1])
            for k in range(left, right + 1):
                indices[k] = temp[k - left]
        merge_sort(0, len(nums) - 1)
        return res
```

## Problem 139: Maximal Square

**Category/Pattern:** Dynamic Programming | Matrix

**Difficulty:** Medium

**Problem:**
Given a binary matrix, find the largest square containing only 1's and return its area.

**Examples:**
- Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 4

**Approach:**
DP with state representing size of square ending at current cell.

**Code:**
```python
class Solution:
    def maximalSquare(self, matrix):
        if not matrix: return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        max_side = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    max_side = max(max_side, dp[i][j])
        return max_side * max_side
```

## Problem 140: Maximal Rectangle

**Category/Pattern:** Dynamic Programming | Stack | Matrix

**Difficulty:** Hard

**Problem:**
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

**Examples:**
- Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 6

**Approach:**
Convert each row into a histogram and apply Largest Rectangle in Histogram.

**Code:**
```python
class Solution:
    def maximalRectangle(self, matrix):
        if not matrix:
            return 0
        max_area = 0
        dp = [0] * len(matrix[0])
        for row in matrix:
            for i in range(len(row)):
                dp[i] = dp[i] + 1 if row[i] == '1' else 0
            max_area = max(max_area, self.largestRectangleArea(dp))
        return max_area

    def largestRectangleArea(self, heights):
        stack = [-1]
        max_area = 0
        for i in range(len(heights)):
            while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:
                h = heights[stack.pop()]
                w = i - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(i)
        while stack[-1] != -1:
            h = heights[stack.pop()]
            w = len(heights) - stack[-1] - 1
            max_area = max(max_area, h * w)
        return max_area
```

## Problem 141: Distinct Subsequences

**Category/Pattern:** Dynamic Programming | String

**Difficulty:** Hard

**Problem:**
Given two strings s and t, return the number of distinct subsequences of s which equals t.

**Examples:**
- Input: s = "rabbbit", t = "rabbit"
Output: 3

**Approach:**
Use 2D DP array where dp[i][j] represents number of ways s[0..i] can form t[0..j].

**Code:**
```python
class Solution:
    def numDistinct(self, s, t):
        m, n = len(s), len(t)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][0] = 1
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[m][n]
```

## Problem 142: Scramble String

**Category/Pattern:** Recursion | DP | String

**Difficulty:** Hard

**Problem:**
Determine if one string is a scramble of another string.

**Examples:**
- Input: s1 = "great", s2 = "rgeat"
Output: true

**Approach:**
Use recursion with memoization to test all possible split points.

**Code:**
```python
class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        memo = {}
        def dfs(x, y):
            if (x, y) in memo:
                return memo[(x, y)]
            if x == y:
                memo[(x, y)] = True
                return True
            if sorted(x) != sorted(y):
                memo[(x, y)] = False
                return False
            for i in range(1, len(x)):
                if dfs(x[:i], y[:i]) and dfs(x[i:], y[i:]) or dfs(x[:i], y[-i:]) and dfs(x[i:], y[:-i]):
                    memo[(x, y)] = True
                    return True
            memo[(x, y)] = False
            return False
        return dfs(s1, s2)
```

## Problem 143: Regular Expression Matching

**Category/Pattern:** DP | String | Regex

**Difficulty:** Hard

**Problem:**
Implement regular expression matching with support for '.' and '*'.

**Examples:**
- Input: s = "aa", p = "a*"
Output: true

**Approach:**
DP where dp[i][j] means s[:i] matches p[:j]. Handle '*' separately.

**Code:**
```python
class Solution:
    def isMatch(self, s, p):
        dp = [[False]*(len(p)+1) for _ in range(len(s)+1)]
        dp[0][0] = True
        for j in range(2, len(p)+1):
            if p[j-1] == '*':
                dp[0][j] = dp[0][j-2]
        for i in range(1, len(s)+1):
            for j in range(1, len(p)+1):
                if p[j-1] == '.' or p[j-1] == s[i-1]:
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == '*':
                    dp[i][j] = dp[i][j-2] or (dp[i-1][j] if p[j-2] == s[i-1] or p[j-2] == '.' else False)
        return dp[-1][-1]
```

## Problem 144: Wildcard Matching

**Category/Pattern:** DP | String | Greedy

**Difficulty:** Hard

**Problem:**
Implement wildcard matching with support for '?' and '*'.

**Examples:**
- Input: s = "adceb", p = "*a*b"
Output: true

**Approach:**
Use 2D DP where '*' can match empty or multiple characters.

**Code:**
```python
class Solution:
    def isMatch(self, s, p):
        dp = [[False] * (len(p)+1) for _ in range(len(s)+1)]
        dp[0][0] = True
        for j in range(1, len(p)+1):
            if p[j-1] == '*':
                dp[0][j] = dp[0][j-1]
        for i in range(1, len(s)+1):
            for j in range(1, len(p)+1):
                if p[j-1] == s[i-1] or p[j-1] == '?':
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == '*':
                    dp[i][j] = dp[i-1][j] or dp[i][j-1]
        return dp[len(s)][len(p)]
```

## Problem 145: Design Hit Counter

**Category/Pattern:** Design | Queue

**Difficulty:** Medium

**Problem:**
Design a hit counter which counts the number of hits received in the past 5 minutes.

**Examples:**
- hitCounter.hit(1)
hitCounter.hit(2)
hitCounter.hit(3)
hitCounter.getHits(4) -> 3

**Approach:**
Use a queue to store timestamps and discard old ones outside the 5-minute window.

**Code:**
```python
from collections import deque
class HitCounter:
    def __init__(self):
        self.hits = deque()

    def hit(self, timestamp: int):
        self.hits.append(timestamp)

    def getHits(self, timestamp: int) -> int:
        while self.hits and timestamp - self.hits[0] >= 300:
            self.hits.popleft()
        return len(self.hits)
```

## Problem 146: Find Duplicate File in System

**Category/Pattern:** String | HashMap

**Difficulty:** Medium

**Problem:**
Given a list of directory info, return all groups of duplicate files in the file system.

**Examples:**
- Input: ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"]
Output: [["root/a/1.txt","root/c/3.txt"],["root/a/2.txt","root/c/d/4.txt","root/4.txt"]]

**Approach:**
Use a hashmap to map file content to a list of paths.

**Code:**
```python
from collections import defaultdict
class Solution:
    def findDuplicate(self, paths):
        content_map = defaultdict(list)
        for path in paths:
            parts = path.split(" ")
            root = parts[0]
            for file in parts[1:]:
                name, content = file.split("(")
                content_map[content[:-1]].append(f"{root}/{name}")
        return [group for group in content_map.values() if len(group) > 1]
```

## Problem 147: Longest Increasing Path in a Matrix

**Category/Pattern:** DFS | DP | Matrix

**Difficulty:** Medium

**Problem:**
Find the longest increasing path in a matrix.

**Examples:**
- Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4

**Approach:**
Use DFS with memoization from each cell.

**Code:**
```python
class Solution:
    def longestIncreasingPath(self, matrix):
        if not matrix:
            return 0
        rows, cols = len(matrix), len(matrix[0])
        memo = [[0]*cols for _ in range(rows)]
        directions = [(0,1),(1,0),(-1,0),(0,-1)]

        def dfs(i, j):
            if memo[i][j]:
                return memo[i][j]
            max_len = 1
            for dx, dy in directions:
                x, y = i+dx, j+dy
                if 0<=x<rows and 0<=y<cols and matrix[x][y] > matrix[i][j]:
                    max_len = max(max_len, 1 + dfs(x, y))
            memo[i][j] = max_len
            return max_len

        return max(dfs(i, j) for i in range(rows) for j in range(cols))
```

## Problem 148: Design Snake Game

**Category/Pattern:** Design | Queue | Simulation

**Difficulty:** Medium

**Problem:**
Design a Snake game on a board with food and self-collision detection.

**Examples:**
- snake.move("R") -> 0
snake.move("D") -> 0
snake.move("R") -> 1

**Approach:**
Use deque to simulate the snake body, and a set to track collision.

**Code:**
```python
from collections import deque
class SnakeGame:
    def __init__(self, width, height, food):
        self.width = width
        self.height = height
        self.food = deque(food)
        self.body = deque([(0, 0)])
        self.positions = {(0, 0)}
        self.score = 0
        self.dirs = {'U': (-1,0), 'D': (1,0), 'L': (0,-1), 'R': (0,1)}

    def move(self, direction):
        head = self.body[-1]
        dx, dy = self.dirs[direction]
        new_head = (head[0]+dx, head[1]+dy)
        if (not 0 <= new_head[0] < self.height or
            not 0 <= new_head[1] < self.width or
            (new_head in self.positions and new_head != self.body[0])):
            return -1
        self.body.append(new_head)
        self.positions.add(new_head)
        if self.food and [new_head[0], new_head[1]] == self.food[0]:
            self.food.popleft()
            self.score += 1
        else:
            tail = self.body.popleft()
            self.positions.remove(tail)
        return self.score
```

## Problem 149: Find the Celebrity

**Category/Pattern:** Graph | Simulation

**Difficulty:** Medium

**Problem:**
There are n people at a party. A celebrity is known by everyone but knows no one. Find the celebrity.

**Examples:**
- Input: knows(a, b) returns True if a knows b
Output: index of celebrity or -1

**Approach:**
Eliminate non-celebrities using the knows() relation.

**Code:**
```python
class Solution:
    def findCelebrity(self, n):
        candidate = 0
        for i in range(1, n):
            if knows(candidate, i):
                candidate = i
        for i in range(n):
            if i != candidate and (knows(candidate, i) or not knows(i, candidate)):
                return -1
        return candidate
```

## Problem 150: Expression Add Operators

**Category/Pattern:** DFS | Backtracking | String

**Difficulty:** Hard

**Problem:**
Given a string num and a target, return all expressions by adding '+', '-', or '*' so that they evaluate to target.

**Examples:**
- Input: num = "123", target = 6
Output: ["1+2+3", "1*2*3"]

**Approach:**
Backtrack by trying all possible splits and operators. Handle precedence for '*'.

**Code:**
```python
class Solution:
    def addOperators(self, num, target):
        res = []
        def dfs(i, expr, prev, curr):
            if i == len(num):
                if curr == target:
                    res.append(expr)
                return
            for j in range(i+1, len(num)+1):
                temp = num[i:j]
                if len(temp) > 1 and temp[0] == '0':
                    continue
                val = int(temp)
                if i == 0:
                    dfs(j, temp, val, val)
                else:
                    dfs(j, expr + '+' + temp, val, curr + val)
                    dfs(j, expr + '-' + temp, -val, curr - val)
                    dfs(j, expr + '*' + temp, prev*val, curr - prev + prev*val)
        dfs(0, '', 0, 0)
        return res
```

# ðŸ’¾ SQL 50 Problems

## SQL Problem 1: Combine Two Tables

**Category/Pattern:** Basic SQL | LEFT JOIN

**Difficulty:** Easy

**Problem:**
Write a SQL query to combine two tables: `Person` and `Address`. Return all the people, and their address if available.

**Examples:**
- Input:
Person table:
| PersonId | FirstName | LastName |
|----------|-----------|----------|
| 1        | Wang      | Allen    |
| 2        | Alice     | Bob      |

Address table:
| AddressId | PersonId | City  | State |
|-----------|----------|-------|-------|
| 1         | 2        | New York | NY |

Output:
| FirstName | LastName | City     | State |
|-----------|----------|----------|-------|
| Wang      | Allen    | null     | null  |
| Alice     | Bob      | New York | NY    |

**Approach:**
Use a LEFT JOIN between `Person` and `Address` on `PersonId`.

**Code:**
```sql
SELECT FirstName, LastName, City, State
FROM Person
LEFT JOIN Address
ON Person.PersonId = Address.PersonId;
```

## SQL Problem 2: Second Highest Salary

**Category/Pattern:** Subquery | Ranking

**Difficulty:** Easy

**Problem:**
Write a SQL query to get the second highest salary from the Employee table.

**Examples:**
- Input:
| Id | Salary |
|----|--------|
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |

Output:
| SecondHighestSalary |
|---------------------|
| 200                 |

**Approach:**
Use a subquery to find the max salary less than the maximum salary.

**Code:**
```sql
SELECT MAX(Salary) AS SecondHighestSalary
FROM Employee
WHERE Salary < (
    SELECT MAX(Salary) FROM Employee
);
```

## SQL Problem 3: Nth Highest Salary

**Category/Pattern:** Subquery | DENSE_RANK

**Difficulty:** Medium

**Problem:**
Write a SQL query to get the N-th highest salary from the Employee table.

**Examples:**
- If N = 2, return the second highest salary.
- Input:
| Id | Salary |
|----|--------|
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |

Output:
| getNthHighestSalary(2) |
|------------------------|
| 200                    |

**Approach:**
Use DENSE_RANK or LIMIT with OFFSET depending on the SQL dialect.

**Code:**
```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      SELECT DISTINCT Salary
      FROM Employee
      ORDER BY Salary DESC
      LIMIT 1 OFFSET N-1
  );
END
```

## SQL Problem 4: Rank Scores

**Category/Pattern:** Window Function | DENSE_RANK

**Difficulty:** Medium

**Problem:**
Write a SQL query to rank scores in descending order. If there is a tie, they should have the same rank.

**Examples:**
- Input:
| Id | Score |
|----|-------|
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |

Output:
| Score | Rank |
|-------|------|
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.50  | 4    |

**Approach:**
Use `DENSE_RANK()` over an `ORDER BY` clause.

**Code:**
```sql
SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank
FROM Scores;
```

## SQL Problem 5: Department Highest Salary

**Category/Pattern:** JOIN | Subquery | Window Function

**Difficulty:** Medium

**Problem:**
Write a SQL query to find the employees who earn the highest salary in each department.

**Examples:**
- Input:
| Id | Name | Salary | DepartmentId |
|----|------|--------|---------------|
| 1  | Joe  | 85000  | 1             |
| 2  | Henry| 80000  | 2             |
| 3  | Sam  | 60000  | 2             |
| 4  | Max  | 90000  | 1             |
| 5  | Janet| 69000  | 1             |

Departments table:
| Id | Name        |
|----|-------------|
| 1  | IT          |
| 2  | Sales       |

Output:
| Department | Employee | Salary |
|------------|----------|--------|
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |

**Approach:**
Use a subquery or window function to partition by department and get max salary.

**Code:**
```sql
SELECT d.Name AS Department, e.Name AS Employee, e.Salary
FROM Employee e
JOIN Department d ON e.DepartmentId = d.Id
WHERE (e.Salary, e.DepartmentId) IN (
    SELECT MAX(Salary), DepartmentId
    FROM Employee
    GROUP BY DepartmentId
);
```

## SQL Problem 6: Duplicate Emails

**Category/Pattern:** Aggregation | HAVING

**Difficulty:** Easy

**Problem:**
Write a SQL query to find all duplicate emails in the Email table.

**Examples:**
- Input:
| Id | Email            |
|----|------------------|
| 1  | a@leetcode.com   |
| 2  | b@leetcode.com   |
| 3  | a@leetcode.com   |

Output:
| Email          |
|----------------|
| a@leetcode.com |

**Approach:**
Group by Email and use `HAVING COUNT(*) > 1`.

**Code:**
```sql
SELECT Email
FROM Person
GROUP BY Email
HAVING COUNT(*) > 1;
```

## SQL Problem 7: Customers Who Never Order

**Category/Pattern:** LEFT JOIN | NOT IN

**Difficulty:** Easy

**Problem:**
Write a SQL query to find all customers who never placed an order.

**Examples:**
- Input:
Customers:
| Id | Name    |
|----|---------|
| 1  | Joe     |
| 2  | Henry   |
| 3  | Sam     |
| 4  | Max     |

Orders:
| Id | CustomerId |
|----|------------|
| 1  | 3          |
| 2  | 1          |

Output:
| Customers |
|-----------|
| Henry     |
| Max       |

**Approach:**
Use `LEFT JOIN` or `NOT IN` to filter out customers with no matching orders.

**Code:**
```sql
SELECT Name AS Customers
FROM Customers
WHERE Id NOT IN (
    SELECT CustomerId FROM Orders
);
```

## SQL Problem 8: Employees Earning More Than Their Managers

**Category/Pattern:** Self JOIN

**Difficulty:** Medium

**Problem:**
Write a SQL query to find employees who earn more than their managers.

**Examples:**
- Input:
| Id | Name | Salary | ManagerId |
|----|------|--------|-----------|
| 1  | Joe  | 70000  | 3         |
| 2  | Henry| 80000  | 4         |
| 3  | Sam  | 60000  | null      |
| 4  | Max  | 90000  | null      |

Output:
| Employee |
|----------|
| Henry    |

**Approach:**
Self join the Employee table to compare salary with manager.

**Code:**
```sql
SELECT e1.Name AS Employee
FROM Employee e1
JOIN Employee e2 ON e1.ManagerId = e2.Id
WHERE e1.Salary > e2.Salary;
```

## SQL Problem 9: Find Duplicate Transactions

**Category/Pattern:** GROUP BY | COUNT

**Difficulty:** Hard

**Problem:**
Find transactions that occur more than once with same details.

**Examples:**
- Input:
| id | amount | account |
|----|--------|---------|
| 1  | 1000   | 1234    |
| 2  | 2000   | 1234    |
| 3  | 1000   | 1234    |

Output:
| amount | account |
|--------|---------|
| 1000   | 1234    |

**Approach:**
Group by relevant columns and filter with `HAVING COUNT(*) > 1`.

**Code:**
```sql
SELECT amount, account
FROM Transactions
GROUP BY amount, account
HAVING COUNT(*) > 1;
```

## SQL Problem 10: Delete Duplicate Emails

**Category/Pattern:** DELETE | Subquery

**Difficulty:** Medium

**Problem:**
Delete all duplicate email entries, keeping only the smallest Id.

**Examples:**
- Input:
| Id | Email          |
|----|----------------|
| 1  | john@example.com |
| 2  | john@example.com |

Output:
| Id | Email          |
|----|----------------|
| 1  | john@example.com |

**Approach:**
Use a subquery to retain the minimum Id and delete the rest.

**Code:**
```sql
DELETE FROM Person
WHERE Id NOT IN (
    SELECT MIN(Id)
    FROM Person
    GROUP BY Email
);
```

## SQL Problem 11: Consecutive Numbers

**Category/Pattern:** Self-Join | Window Function

**Difficulty:** Easy

**Problem:**
Find all numbers that appear at least three times consecutively in a table.

**Examples:**
- Input:
| Id | Num |
|----|-----|
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |

Output:
| ConsecutiveNums |
|-----------------|
| 1               |

**Approach:**
Use self-joins or window functions like `LEAD()` and `LAG()` to compare neighboring rows.

**Code:**
```sql
SELECT DISTINCT l1.Num AS ConsecutiveNums
FROM Logs l1, Logs l2, Logs l3
WHERE l1.Id = l2.Id - 1
  AND l2.Id = l3.Id - 1
  AND l1.Num = l2.Num AND l2.Num = l3.Num;
```

## SQL Problem 12: Exchange Seats

**Category/Pattern:** Modulus | CASE WHEN

**Difficulty:** Easy

**Problem:**
Rearrange seats such that students sitting in even-numbered seats switch places with adjacent odd-numbered seats.

**Examples:**
- Input:
| id | student |
|----|---------|
| 1  | A       |
| 2  | B       |
| 3  | C       |
| 4  | D       |

Output:
| id | student |
|----|---------|
| 1  | B       |
| 2  | A       |
| 3  | D       |
| 4  | C       |

**Approach:**
Use CASE logic with modulo arithmetic to adjust IDs for sorting.

**Code:**
```sql
SELECT
  CASE
    WHEN id % 2 = 1 AND id + 1 <= (SELECT COUNT(*) FROM Seat)
      THEN id + 1
    WHEN id % 2 = 0 THEN id - 1
    ELSE id
  END AS id,
  student
FROM Seat
ORDER BY id;
```

## SQL Problem 13: Rising Temperature

**Category/Pattern:** Self-Join | Date Comparison

**Difficulty:** Easy

**Problem:**
Find all dates where the temperature was higher than the previous day.

**Examples:**
- Input:
| Id | RecordDate | Temperature |
|----|------------|-------------|
| 1  | 2020-01-01 | 10          |
| 2  | 2020-01-02 | 15          |

Output:
| Id |
|----|
| 2  |

**Approach:**
Self join the table with itself and compare dates and temperatures.

**Code:**
```sql
SELECT w1.Id
FROM Weather w1
JOIN Weather w2
  ON DATEDIFF(w1.RecordDate, w2.RecordDate) = 1
WHERE w1.Temperature > w2.Temperature;
```

## SQL Problem 14: Employees With Missing Information

**Category/Pattern:** NULL Check | UNION

**Difficulty:** Medium

**Problem:**
Find employees with missing salary or name information.

**Examples:**
- Input:
| empId | name  |
|-------|--------|
| 1     | John   |
| 2     | Dan    |
| 3     | null   |

| empId | salary |
|-------|--------|
| 1     | 9000   |
| 2     | null   |
| 3     | 3000   |

Output:
| empId |
|-------|
| 2     |
| 3     |

**Approach:**
Use JOIN and check for NULL values, or use `UNION` of separate NULL queries.

**Code:**
```sql
SELECT e1.empId
FROM Employees e1
LEFT JOIN Salaries e2 ON e1.empId = e2.empId
WHERE e1.name IS NULL OR e2.salary IS NULL;
```

## SQL Problem 15: Project Employees I

**Category/Pattern:** JOIN | GROUP BY | HAVING

**Difficulty:** Medium

**Problem:**
Find employees who have worked on more than one project.

**Examples:**
- Input:
| project_id | employee_id |
|------------|-------------|
| 1          | 1           |
| 1          | 2           |
| 2          | 1           |

Output:
| employee_id |
|-------------|
| 1           |

**Approach:**
Group by employee_id and count distinct project_ids.

**Code:**
```sql
SELECT employee_id
FROM Project
GROUP BY employee_id
HAVING COUNT(DISTINCT project_id) > 1;
```

## SQL Problem 16: Not Boring Movies

**Category/Pattern:** Filter | Odd ID | Rating

**Difficulty:** Easy

**Problem:**
Write a SQL query to find all movies with odd IDs and a rating greater than 5.0.

**Examples:**
- Input:
| id | name    | rating |
|----|---------|--------|
| 1  | War     | 8.9    |
| 2  | Science | 8.5    |
| 3  | fiction | 9.0    |
| 4  | fried   | 6.5    |

Output:
| id | name  | rating |
|----|-------|--------|
| 1  | War   | 8.9    |
| 3  | fiction| 9.0   |

**Approach:**
Filter where `id % 2 = 1` and rating > 5.

**Code:**
```sql
SELECT *
FROM Cinema
WHERE id % 2 = 1 AND description != 'boring'
ORDER BY rating DESC;
```

## SQL Problem 17: Game Play Analysis I

**Category/Pattern:** MIN | GROUP BY

**Difficulty:** Easy

**Problem:**
Write a query to find the first login date for each player.

**Examples:**
- Input:
| player_id | event_date | games_played |
|-----------|------------|---------------|
| 1         | 2016-03-01 | 5             |
| 1         | 2016-05-02 | 6             |
| 2         | 2017-06-25 | 1             |
| 3         | 2016-03-02 | 0             |
| 3         | 2018-07-03 | 5             |

Output:
| player_id | first_login |
|-----------|-------------|
| 1         | 2016-03-01  |
| 2         | 2017-06-25  |
| 3         | 2016-03-02  |

**Approach:**
Use GROUP BY and MIN(event_date) to get the first login.

**Code:**
```sql
SELECT player_id, MIN(event_date) AS first_login
FROM Activity
GROUP BY player_id;
```

## SQL Problem 18: Game Play Analysis II

**Category/Pattern:** JOIN | DATEDIFF

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the userâ€™s first login date and whether they played again the next day.

**Examples:**
- Output:
| player_id | device_id | first_login | second_day_login |
|-----------|-----------|-------------|------------------|
| 1         | 2         | 2016-03-01  | 1                |
| 2         | 3         | 2017-06-25  | 0                |

**Approach:**
Use self join or `EXISTS` to check for activity on the next day.

**Code:**
```sql
SELECT a.player_id, a.device_id, a.event_date AS first_login,
       CASE WHEN b.event_date IS NOT NULL THEN 1 ELSE 0 END AS second_day_login
FROM Activity a
LEFT JOIN Activity b 
  ON a.player_id = b.player_id AND DATEDIFF(b.event_date, a.event_date) = 1
WHERE a.event_date = (
    SELECT MIN(event_date)
    FROM Activity a2
    WHERE a2.player_id = a.player_id
);
```

## SQL Problem 19: Customer Placing the Largest Number of Orders

**Category/Pattern:** Aggregation | MAX

**Difficulty:** Medium

**Problem:**
Find the customer who placed the most number of orders.

**Examples:**
- Input:
| customer_number | order_number |
|------------------|---------------|
| 1                | 10            |
| 1                | 11            |
| 2                | 12            |

Output:
| customer_number |
|-----------------|
| 1               |

**Approach:**
Group by customer_number and order by COUNT(*) DESC LIMIT 1.

**Code:**
```sql
SELECT customer_number
FROM Orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1;
```

## SQL Problem 20: Employees With Invalid Salaries

**Category/Pattern:** Filter | Logic

**Difficulty:** Medium

**Problem:**
Find employees whose salary is either less than 100 or more than 100000.

**Examples:**
- Input:
| employee_id | salary |
|--------------|--------|
| 1            | 95     |
| 2            | 50000  |
| 3            | 100001 |

Output:
| employee_id |
|--------------|
| 1           |
| 3           |

**Approach:**
Simple WHERE clause using `OR` for invalid salary bounds.

**Code:**
```sql
SELECT employee_id
FROM Employees
WHERE salary < 100 OR salary > 100000;
```

## SQL Problem 21: Department Highest Salary

**Category/Pattern:** JOIN | Subquery

**Difficulty:** Medium

**Problem:**
Find the highest salary for each department and the employee(s) who earn it.

**Examples:**
- Output:
| Department | Employee | Salary |
|------------|----------|--------|
| IT         | Max      | 90000  |
| Sales      | Joe      | 80000  |

**Approach:**
Join Employee and Department tables. Use subquery to filter employees with the max salary per department.

**Code:**
```sql
SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary
FROM Employee e
JOIN Department d ON e.departmentId = d.id
WHERE (e.departmentId, e.salary) IN (
  SELECT departmentId, MAX(salary)
  FROM Employee
  GROUP BY departmentId
);
```

## SQL Problem 22: Delete Duplicate Emails

**Category/Pattern:** Subquery | DELETE

**Difficulty:** Medium

**Problem:**
Write a SQL query to delete all duplicate email entries in a table, keeping only the smallest id.

**Examples:**
- Input:
| Id | Email             |
|----|--------------------|
| 1  | john@example.com  |
| 2  | bob@example.com   |
| 3  | john@example.com  |

Output:
| Id | Email             |
|----|--------------------|
| 1  | john@example.com  |
| 2  | bob@example.com   |

**Approach:**
Use DELETE with a subquery to filter IDs not equal to MIN(Id) per email.

**Code:**
```sql
DELETE FROM Person
WHERE Id NOT IN (
  SELECT MIN(Id)
  FROM Person
  GROUP BY Email
);
```

## SQL Problem 23: Rank Scores

**Category/Pattern:** Window Function | RANK

**Difficulty:** Medium

**Problem:**
Rank student scores, with ties receiving the same rank and next rank skipped.

**Examples:**
- Input:
| Id | Score |
|----|-------|
| 1  | 87    |
| 2  | 89    |
| 3  | 92    |

Output:
| Score | Rank |
|-------|------|
| 92    | 1    |
| 89    | 2    |
| 87    | 3    |

**Approach:**
Use `RANK()` over `ORDER BY Score DESC`.

**Code:**
```sql
SELECT Score, RANK() OVER (ORDER BY Score DESC) AS Rank
FROM Scores;
```

## SQL Problem 24: Nth Highest Salary

**Category/Pattern:** Subquery | LIMIT | DENSE_RANK

**Difficulty:** Medium

**Problem:**
Return the Nth highest salary from a table.

**Examples:**
- Input:
N = 2

Output:
| getNthHighestSalary(2) |
|------------------------|
| 200                    |

**Approach:**
Use `DISTINCT`, `ORDER BY` with `LIMIT` and `OFFSET`, or `DENSE_RANK()`.

**Code:**
```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      SELECT DISTINCT Salary
      FROM Employee
      ORDER BY Salary DESC
      LIMIT 1 OFFSET N-1
  );
END;
```

## SQL Problem 25: Consecutive Available Seats

**Category/Pattern:** Window Function | Lag | Lead

**Difficulty:** Medium

**Problem:**
Identify consecutive available seats in a row of a cinema.

**Examples:**
- Output:
| seat_id |
|---------|
| 2       |
| 3       |

**Approach:**
Use `LEAD()` and `LAG()` to check if neighbor seats are also available.

**Code:**
```sql
SELECT seat_id
FROM (
  SELECT seat_id,
         LAG(is_available) OVER (ORDER BY seat_id) AS prev,
         is_available,
         LEAD(is_available) OVER (ORDER BY seat_id) AS next
  FROM Cinema
) t
WHERE is_available = 1 AND (prev = 1 OR next = 1);
```

## SQL Problem 26: Employees Earning More Than Their Managers

**Category/Pattern:** Self-Join | Comparison

**Difficulty:** Medium

**Problem:**
Find employees who earn more than their manager.

**Examples:**
- Output:
| Employee |
|----------|
| Joe      |

**Approach:**
Self join on managerId and compare salaries.

**Code:**
```sql
SELECT e1.name AS Employee
FROM Employee e1
JOIN Employee e2 ON e1.managerId = e2.id
WHERE e1.salary > e2.salary;
```

## SQL Problem 27: Second Highest Salary

**Category/Pattern:** Subquery | LIMIT

**Difficulty:** Easy

**Problem:**
Write a SQL query to get the second highest salary from the Employee table.

**Examples:**
- Output:
| SecondHighestSalary |
|----------------------|
| 200                  |

**Approach:**
Use `DISTINCT`, `ORDER BY`, `LIMIT 1 OFFSET 1`.

**Code:**
```sql
SELECT (
  SELECT DISTINCT Salary
  FROM Employee
  ORDER BY Salary DESC
  LIMIT 1 OFFSET 1
) AS SecondHighestSalary;
```

## SQL Problem 28: Duplicate Emails

**Category/Pattern:** GROUP BY | HAVING

**Difficulty:** Easy

**Problem:**
Find all duplicate emails in a table.

**Examples:**
- Output:
| Email           |
|-----------------|
| john@example.com|

**Approach:**
Group by Email and use `HAVING COUNT(*) > 1`.

**Code:**
```sql
SELECT Email
FROM Person
GROUP BY Email
HAVING COUNT(*) > 1;
```

## SQL Problem 29: Customer Who Visited but Did Not Make Any Transactions

**Category/Pattern:** LEFT JOIN | NULL

**Difficulty:** Medium

**Problem:**
Identify customers who visited but made no transactions.

**Examples:**
- Output:
| customer_id |
|-------------|
| 2           |

**Approach:**
Use `LEFT JOIN` and filter where transaction_id IS NULL.

**Code:**
```sql
SELECT v.customer_id
FROM Visits v
LEFT JOIN Transactions t ON v.visit_id = t.visit_id
WHERE t.transaction_id IS NULL;
```

## SQL Problem 30: Product Sales Analysis I

**Category/Pattern:** JOIN | GROUP BY | SUM

**Difficulty:** Medium

**Problem:**
Summarize total units sold per product.

**Examples:**
- Output:
| product_name | unit |
|--------------|------|
| Keyboard     | 10   |
| Mouse        | 15   |

**Approach:**
JOIN Product and Sales, GROUP BY product_id, and SUM(units).

**Code:**
```sql
SELECT p.product_name, SUM(s.unit) AS unit
FROM Sales s
JOIN Product p ON s.product_id = p.product_id
GROUP BY s.product_id;
```

## SQL Problem 31: Department Top Three Salaries

**Category/Pattern:** Window Function | DENSE_RANK | JOIN

**Difficulty:** Medium

**Problem:**
Find top 3 highest salaries in each department.

**Examples:**
- Output:
| Department | Employee | Salary |
|------------|----------|--------|
| IT         | Max      | 90000  |
| IT         | Jim      | 85000  |

**Approach:**
Use DENSE_RANK partitioned by departmentId and filter for rank â‰¤ 3.

**Code:**
```sql
SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary
FROM (
  SELECT *, DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) AS rk
  FROM Employee
) e
JOIN Department d ON e.departmentId = d.id
WHERE rk <= 3;
```

## SQL Problem 32: Employees with Missing Information

**Category/Pattern:** LEFT JOIN | IS NULL | NOT EXISTS

**Difficulty:** Medium

**Problem:**
List employees missing either their name or salary record.

**Examples:**
- Output:
| employee_id |
|-------------|
| 2           |

**Approach:**
Use `FULL OUTER JOIN` or simulate it with `UNION` of left/right joins.

**Code:**
```sql
SELECT employee_id
FROM Employees
WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)
UNION
SELECT employee_id
FROM Salaries
WHERE employee_id NOT IN (SELECT employee_id FROM Employees);
```

## SQL Problem 33: Project Employees I

**Category/Pattern:** JOIN | COUNT | GROUP BY

**Difficulty:** Medium

**Problem:**
Count number of employees per project.

**Examples:**
- Output:
| project_id | employee_count |
|------------|----------------|
| 1          | 2              |

**Approach:**
GROUP BY project_id and COUNT employee_id.

**Code:**
```sql
SELECT project_id, COUNT(employee_id) AS employee_count
FROM Project
GROUP BY project_id;
```

## SQL Problem 34: Project Employees II

**Category/Pattern:** JOIN | GROUP BY | MAX

**Difficulty:** Medium

**Problem:**
Find employees who worked on the most projects.

**Examples:**
- Output:
| employee_id | project_count |
|-------------|----------------|
| 1           | 3              |

**Approach:**
Use GROUP BY and HAVING with subquery for MAX(project count).

**Code:**
```sql
SELECT employee_id, COUNT(project_id) AS project_count
FROM Project
GROUP BY employee_id
HAVING COUNT(project_id) = (
    SELECT MAX(pc) FROM (
        SELECT COUNT(project_id) AS pc
        FROM Project
        GROUP BY employee_id
    ) t
);
```

## SQL Problem 35: Customer Placing the Largest Number of Orders

**Category/Pattern:** GROUP BY | ORDER BY | LIMIT

**Difficulty:** Medium

**Problem:**
Find the customer who placed the most orders.

**Examples:**
- Output:
| customer_number |
|------------------|
| 2                |

**Approach:**
GROUP BY customer_number, ORDER BY COUNT(*) DESC LIMIT 1.

**Code:**
```sql
SELECT customer_number
FROM Orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1;
```

## SQL Problem 36: Monthly Transactions I

**Category/Pattern:** GROUP BY | DATE_FORMAT

**Difficulty:** Hard

**Problem:**
Summarize number of transactions per month and country.

**Examples:**
- Output:
| month | country | transactions_count |

**Approach:**
Use `DATE_FORMAT()` to group by month and country.

**Code:**
```sql
SELECT 
  DATE_FORMAT(trans_date, '%Y-%m') AS month,
  country,
  COUNT(*) AS transactions_count
FROM Transactions
GROUP BY month, country;
```

## SQL Problem 37: Monthly Transactions II

**Category/Pattern:** GROUP BY | SUM | COUNT

**Difficulty:** Hard

**Problem:**
Compute transactions and approved percentages by country per month.

**Examples:**
- Output:
| month | approved_amount | approved_count | country |

**Approach:**
Use `SUM(CASE...)` for conditionals and `DATE_FORMAT` for month.

**Code:**
```sql
SELECT 
  DATE_FORMAT(trans_date, '%Y-%m') AS month,
  country,
  COUNT(CASE WHEN state = 'approved' THEN 1 END) AS approved_count,
  SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_amount
FROM Transactions
GROUP BY month, country;
```

## SQL Problem 38: Immediate Food Delivery I

**Category/Pattern:** JOIN | Aggregation | ROUND

**Difficulty:** Medium

**Problem:**
Calculate the percentage of immediate food deliveries.

**Examples:**
- Output:
| immediate_percentage |
|-----------------------|
| 50.00                 |

**Approach:**
Count where `order_date = customer_pref_delivery_date` and divide by total.

**Code:**
```sql
SELECT 
  ROUND(
    SUM(order_date = customer_pref_delivery_date) * 100.0 / COUNT(*),
    2
  ) AS immediate_percentage
FROM Delivery;
```

## SQL Problem 39: Immediate Food Delivery II

**Category/Pattern:** JOIN | Aggregation | ROUND | FIRST Order

**Difficulty:** Medium

**Problem:**
Calculate immediate delivery percentage for first orders only.

**Examples:**
- Output:
| immediate_percentage |
|-----------------------|
| 33.33                 |

**Approach:**
Find first order per customer and check if delivered on preferred date.

**Code:**
```sql
SELECT 
  ROUND(
    SUM(order_date = customer_pref_delivery_date) * 100.0 / COUNT(*),
    2
  ) AS immediate_percentage
FROM Delivery
WHERE (customer_id, order_date) IN (
  SELECT customer_id, MIN(order_date)
  FROM Delivery
  GROUP BY customer_id
);
```

## SQL Problem 40: Average Selling Price

**Category/Pattern:** JOIN | Aggregation | Division

**Difficulty:** Medium

**Problem:**
Compute the average price per product sold.

**Examples:**
- Output:
| product_id | average_price |
|------------|----------------|
| 1          | 100.00         |

**Approach:**
Use `SUM(price * units)/SUM(units)` formula.

**Code:**
```sql
SELECT 
  p.product_id,
  ROUND(SUM(p.price * u.units)/SUM(u.units), 2) AS average_price
FROM Prices p
JOIN UnitsSold u ON p.product_id = u.product_id
WHERE u.purchase_date BETWEEN p.start_date AND p.end_date
GROUP BY p.product_id;
```

## SQL Problem 41: Product Sales Analysis I

**Category/Pattern:** JOIN | GROUP BY | SUM

**Difficulty:** Medium

**Problem:**
Get total units sold per product.

**Examples:**
- Output:
| product_id | total_units |
|------------|-------------|
| 1          | 450         |

**Approach:**
JOIN products with sales, GROUP BY product_id, SUM units.

**Code:**
```sql
SELECT p.product_id, SUM(s.units) AS total_units
FROM Sales s
JOIN Product p ON s.product_id = p.product_id
GROUP BY p.product_id;
```

## SQL Problem 42: Product Sales Analysis II

**Category/Pattern:** JOIN | GROUP BY | MAX | ORDER BY

**Difficulty:** Medium

**Problem:**
Find most recent sale date and total revenue per product.

**Examples:**
- Output:
| product_id | total_revenue | last_sale |
|------------|----------------|------------|
| 1          | 50000          | 2022-05-01 |

**Approach:**
GROUP BY product_id, use MAX() and SUM() functions.

**Code:**
```sql
SELECT s.product_id,
       SUM(s.units * p.price) AS total_revenue,
       MAX(s.sale_date) AS last_sale
FROM Sales s
JOIN Product p ON s.product_id = p.product_id
GROUP BY s.product_id;
```

## SQL Problem 43: Product Sales Analysis III

**Category/Pattern:** JOIN | GROUP BY | RANK

**Difficulty:** Hard

**Problem:**
Find top selling product(s) by total revenue in each year.

**Examples:**
- Output:
| year | product_id | total_revenue |
|------|------------|----------------|
| 2022 | 2          | 76000          |

**Approach:**
Use `RANK()` or `DENSE_RANK()` within year partitions.

**Code:**
```sql
WITH revenue_per_year AS (
  SELECT YEAR(sale_date) AS year,
         s.product_id,
         SUM(s.units * p.price) AS total_revenue
  FROM Sales s
  JOIN Product p ON s.product_id = p.product_id
  GROUP BY year, s.product_id
),
ranked AS (
  SELECT *, RANK() OVER (PARTITION BY year ORDER BY total_revenue DESC) AS rk
  FROM revenue_per_year
)
SELECT year, product_id, total_revenue
FROM ranked
WHERE rk = 1;
```

## SQL Problem 44: Employees Earning More Than Their Managers

**Category/Pattern:** SELF JOIN | Comparison

**Difficulty:** Medium

**Problem:**
List employees who earn more than their managers.

**Examples:**
- Output:
| name |
|------|
| Joe  |

**Approach:**
Self-join Employee table and compare salaries.

**Code:**
```sql
SELECT e.name
FROM Employee e
JOIN Employee m ON e.managerId = m.id
WHERE e.salary > m.salary;
```

## SQL Problem 45: Second Highest Salary

**Category/Pattern:** Subquery | DISTINCT | LIMIT

**Difficulty:** Easy

**Problem:**
Find the second highest distinct salary.

**Examples:**
- Output:
| SecondHighestSalary |
|----------------------|
| 200                  |

**Approach:**
Use a subquery with `DISTINCT` and `LIMIT`/`OFFSET`.

**Code:**
```sql
SELECT (
  SELECT DISTINCT salary
  FROM Employee
  ORDER BY salary DESC
  LIMIT 1 OFFSET 1
) AS SecondHighestSalary;
```

## SQL Problem 46: Nth Highest Salary

**Category/Pattern:** Subquery | DENSE_RANK | LIMIT

**Difficulty:** Medium

**Problem:**
Return the nth highest salary (or null if not exists).

**Examples:**
- Input: n = 3
Output: 150

**Approach:**
Use `DENSE_RANK()` or `ROW_NUMBER()` to find nth.

**Code:**
```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      SELECT DISTINCT salary
      FROM Employee
      ORDER BY salary DESC
      LIMIT 1 OFFSET N-1
  );
END
```

## SQL Problem 47: Duplicate Emails

**Category/Pattern:** GROUP BY | HAVING

**Difficulty:** Easy

**Problem:**
Find all duplicate emails in the Person table.

**Examples:**
- Output:
| Email |
|-------|
| a@b.com |

**Approach:**
GROUP BY email and use HAVING COUNT(*) > 1.

**Code:**
```sql
SELECT email
FROM Person
GROUP BY email
HAVING COUNT(*) > 1;
```

## SQL Problem 48: Consecutive Numbers

**Category/Pattern:** Self JOIN | LEAD/LAG | Window

**Difficulty:** Easy

**Problem:**
Find 3 or more consecutive rows with same number.

**Examples:**
- Output:
| ConsecutiveNums |
|------------------|
| 1                |

**Approach:**
Use LEAD/LAG or self join on id offsets.

**Code:**
```sql
SELECT DISTINCT l1.num AS ConsecutiveNums
FROM Logs l1, Logs l2, Logs l3
WHERE l1.id = l2.id - 1
  AND l2.id = l3.id - 1
  AND l1.num = l2.num AND l2.num = l3.num;
```

## SQL Problem 49: Customers Who Never Order

**Category/Pattern:** LEFT JOIN | IS NULL

**Difficulty:** Easy

**Problem:**
List all customers who have never placed an order.

**Examples:**
- Output:
| name |
|------|
| Henry |

**Approach:**
LEFT JOIN Customer and Orders, filter NULL order_id.

**Code:**
```sql
SELECT name
FROM Customers c
LEFT JOIN Orders o ON c.id = o.customerId
WHERE o.id IS NULL;
```

## SQL Problem 50: Rising Temperature

**Category/Pattern:** JOIN | Comparison

**Difficulty:** Easy

**Problem:**
Find dates when temperature rose compared to previous day.

**Examples:**
- Output:
| Id |
|----|
| 2  |

**Approach:**
Join on previous day and compare temperatures.

**Code:**
```sql
SELECT w1.id
FROM Weather w1
JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1
WHERE w1.temperature > w2.temperature;
```



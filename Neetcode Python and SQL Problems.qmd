---
title: "NeetCode Python & SQL Problems"
format:
  html:
    toc: true
    toc-depth: 3
    code-tools: true
    code-fold: true
    smooth-scroll: true
    anchor-sections: true
execute:
  echo: true
  output: true
  eval: false
---

## Problem 1: Two Sum

**Category/Pattern:** Array | Hash Table

**Difficulty:** Easy

**Problem:**
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

**Examples:**
```text
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Approach:**
Use a hash map to store each number’s complement (target - num) and its index. If the current number exists in the map, return its index and the current index.

**Code:**
```python
`` `python
def twoSum(nums, target):
    lookup = {}
    for i, num in enumerate(nums):
        if target - num in lookup:
            return [lookup[target - num], i]
        lookup[num] = i
`` `
```

## Problem 2: Best Time to Buy and Sell Stock

**Category/Pattern:** Array | Dynamic Programming

**Difficulty:** Easy

**Problem:**
You are given an array prices where prices[i] is the price of a given stock on the ith day. Maximize profit by choosing a day to buy and a day in the future to sell.

**Examples:**
```text
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price=1) and sell on day 5 (price=6), profit = 6 - 1 = 5.
```

**Approach:**
Track the minimum price seen so far and calculate the profit if sold today. Keep updating the maximum profit.

**Code:**
```python
`` `python
def maxProfit(prices):
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit
`` `
```

## Problem 3: Contains Duplicate

**Category/Pattern:** Array | Hash Table

**Difficulty:** Easy

**Problem:**
Given an integer array nums, return true if any value appears at least twice. Return false if every element is distinct.

**Examples:**
```text
Input: nums = [1,2,3,1]
Output: true
```

**Approach:**
Use a set to track seen numbers. If a number appears again, return true.

**Code:**
```python
`` `python
def containsDuplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False
`` `
```

## Problem 4: Product of Array Except Self

**Category/Pattern:** Array | Prefix Product

**Difficulty:** Medium

**Problem:**
Given an integer array nums, return an array answer such that answer[i] is the product of all the elements of nums except nums[i].

**Examples:**
```text
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
```

**Approach:**
Use two passes to build prefix and postfix products. First pass: left-to-right for prefix. Second pass: right-to-left for postfix multiplication.

**Code:**
```python
`` `python
def productExceptSelf(nums):
    res = [1] * len(nums)
    prefix = 1
    for i in range(len(nums)):
        res[i] = prefix
        prefix *= nums[i]
    postfix = 1
    for i in range(len(nums) - 1, -1, -1):
        res[i] *= postfix
        postfix *= nums[i]
    return res
`` `
```

## Problem 5: Maximum Subarray

**Category/Pattern:** Array | Dynamic Programming

**Difficulty:** Medium

**Problem:**
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

**Examples:**
```text
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

**Approach:**
Use Kadane’s algorithm. Keep a running sum and reset if it goes below 0.

**Code:**
```python
`` `python
def maxSubArray(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum
`` `
```

## Problem 6: Maximum Product Subarray

**Category/Pattern:** Array | Dynamic Programming

**Difficulty:** Medium

**Problem:**
Given an integer array nums, find the contiguous subarray within an array which has the largest product.

**Examples:**
```text
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product = 6.
```

**Approach:**
Track both max and min products due to negative numbers. Swap if current number is negative.

**Code:**
```python
`` `python
def maxProduct(nums):
    res = nums[0]
    cur_max, cur_min = 1, 1
    for num in nums:
        if num == 0:
            cur_max, cur_min = 1, 1
            res = max(res, 0)
            continue
        tmp = cur_max * num
        cur_max = max(num * cur_max, num * cur_min, num)
        cur_min = min(tmp, num * cur_min, num)
        res = max(res, cur_max)
    return res
`` `
```

## Problem 7: Find Minimum in Rotated Sorted Array

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Find the minimum element in a rotated sorted array. The array was originally sorted in ascending order but then rotated.

**Examples:**
```text
Input: nums = [3,4,5,1,2]
Output: 1
```

**Approach:**
Use binary search. Compare mid with right to determine the unsorted portion.

**Code:**
```python
`` `python
def findMin(nums):
    l, r = 0, len(nums) - 1
    while l < r:
        mid = (l + r) // 2
        if nums[mid] > nums[r]:
            l = mid + 1
        else:
            r = mid
    return nums[l]
`` `
```

## Problem 8: Search in Rotated Sorted Array

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Search for a target in a rotated sorted array.

**Examples:**
```text
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Approach:**
Modify binary search to handle rotated parts by checking sorted halves.

**Code:**
```python
`` `python
def search(nums, target):
    l, r = 0, len(nums) - 1
    while l <= r:
        mid = (l + r) // 2
        if nums[mid] == target:
            return mid
        if nums[l] <= nums[mid]:
            if nums[l] <= target < nums[mid]:
                r = mid - 1
            else:
                l = mid + 1
        else:
            if nums[mid] < target <= nums[r]:
                l = mid + 1
            else:
                r = mid - 1
    return -1
`` `
```

## Problem 9: 3Sum

**Category/Pattern:** Array | Two Pointers

**Difficulty:** Medium

**Problem:**
Find all unique triplets in the array which gives the sum of zero.

**Examples:**
```text
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Approach:**
Sort the array. Fix one number and use two pointers for the other two. Skip duplicates.

**Code:**
```python
`` `python
def threeSum(nums):
    res = []
    nums.sort()
    for i, a in enumerate(nums):
        if i > 0 and a == nums[i - 1]:
            continue
        l, r = i + 1, len(nums) - 1
        while l < r:
            total = a + nums[l] + nums[r]
            if total < 0:
                l += 1
            elif total > 0:
                r -= 1
            else:
                res.append([a, nums[l], nums[r]])
                l += 1
                r -= 1
                while l < r and nums[l] == nums[l - 1]:
                    l += 1
    return res
`` `
```

## Problem 10: Container With Most Water

**Category/Pattern:** Two Pointers

**Difficulty:** Medium

**Problem:**
You are given n non-negative integers representing height. Find two lines that together with the x-axis form a container to hold the most water.

**Examples:**
```text
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
```

**Approach:**
Use two pointers from both ends. Move the pointer with the shorter line to try maximizing area.

**Code:**
```python
`` `python
def maxArea(height):
    l, r = 0, len(height) - 1
    res = 0
    while l < r:
        res = max(res, min(height[l], height[r]) * (r - l))
        if height[l] < height[r]:
            l += 1
        else:
            r -= 1
    return res
`` `
```

## Problem 11: Group Anagrams

**Category/Pattern:** Hashmap

**Difficulty:** Medium

**Problem:**
Group strings that are anagrams of each other.

**Examples:**
```text
Input: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
```

```text
Output: [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
```

**Approach:**
Use a hashmap with sorted string as the key and group original strings in lists.

**Code:**
```python
`` `python
from collections import defaultdict

def groupAnagrams(strs):
    anagrams = defaultdict(list)
    for word in strs:
        key = tuple(sorted(word))
        anagrams[key].append(word)
    return list(anagrams.values())
`` `
```

## Problem 12: Top K Frequent Elements

**Category/Pattern:** Heap / Bucket Sort

**Difficulty:** Medium

**Problem:**
Return the k most frequent elements.

**Examples:**
```text
Input: nums = [1,1,1,2,2,3], k = 2
```

```text
Output: [1,2]
```

**Approach:**
Use a hashmap to count frequencies and a heap to extract top k elements.

**Code:**
```python
`` `python
from collections import Counter
import heapq

def topKFrequent(nums, k):
    count = Counter(nums)
    return heapq.nlargest(k, count.keys(), key=count.get)
`` `
```

## Problem 13: Longest Consecutive Sequence

**Category/Pattern:** HashSet

**Difficulty:** Medium

**Problem:**
Find the length of the longest consecutive elements sequence.

**Examples:**
```text
Input: nums = [100, 4, 200, 1, 3, 2]
```

```text
Output: 4 (because the sequence is 1,2,3,4)
```

**Approach:**
Use a set for O(1) lookups and only start counting if the number is the start of a sequence.

**Code:**
```python
`` `python
def longestConsecutive(nums):
    num_set = set(nums)
    longest = 0

    for n in nums:
        if n - 1 not in num_set:
            length = 1
            while n + length in num_set:
                length += 1
            longest = max(longest, length)

    return longest
`` `
```

## Problem 14: Sliding Window Maximum

**Category/Pattern:** Monotonic Queue / Deque

**Difficulty:** Hard

**Problem:**
Find the maximum value in each sliding window of size k.

**Examples:**
```text
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
```

```text
Output: [3,3,5,5,6,7]
```

**Approach:**
Use a deque to keep indexes of the elements in decreasing order.

**Code:**
```python
`` `python
from collections import deque

def maxSlidingWindow(nums, k):
    output = []
    q = deque()
    for i, n in enumerate(nums):
        while q and nums[q[-1]] < n:
            q.pop()
        q.append(i)
        if q[0] == i - k:
            q.popleft()
        if i >= k - 1:
            output.append(nums[q[0]])
    return output
`` `
```

## Problem 15: Invert Binary Tree

**Category/Pattern:** Binary Tree

**Difficulty:** Easy

**Problem:**
Invert a binary tree by swapping left and right children.

**Examples:**
```text
Input: [4,2,7,1,3,6,9]
```

```text
Output: [4,7,2,9,6,3,1]
```

**Approach:**
Recursively swap left and right children of each node.

**Code:**
```python
`` `python
def invertTree(root):
    if not root:
        return None
    root.left, root.right = invertTree(root.right), invertTree(root.left)
    return root
`` `
```

## Problem 16: Maximum Depth of Binary Tree

**Category/Pattern:** Binary Tree

**Difficulty:** Easy

**Problem:**
Find the maximum depth of a binary tree.

**Examples:**
```text
Input: root = [3,9,20,null,null,15,7]
```

```text
Output: 3
```

**Approach:**
Use DFS to traverse and calculate the depth of left and right subtrees.

**Code:**
```python
`` `python
def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
`` `
```

## Problem 17: Same Tree

**Category/Pattern:** Binary Tree

**Difficulty:** Easy

**Problem:**
Check if two binary trees are the same.

**Examples:**
```text
Input: p = [1,2,3], q = [1,2,3]
```

```text
Output: True
```

**Approach:**
Use recursion to compare values and subtrees of both trees.

**Code:**
```python
`` `python
def isSameTree(p, q):
    if not p and not q:
        return True
    if not p or not q or p.val != q.val:
        return False
    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)
`` `
```

## Problem 18: Subtree of Another Tree

**Category/Pattern:** Binary Tree

**Difficulty:** Easy

**Problem:**
Check if one tree is a subtree of another.

**Examples:**
```text
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
```

```text
Output: True
```

**Approach:**
Traverse the main tree and check at each node whether the subtree matches.

**Code:**
```python
`` `python
def isSubtree(root, subRoot):
    if not root:
        return False
    if isSameTree(root, subRoot):
        return True
    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)

def isSameTree(s, t):
    if not s and not t:
        return True
    if not s or not t or s.val != t.val:
        return False
    return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)
`` `
```

## Problem 19: Lowest Common Ancestor of a Binary Search Tree

**Category/Pattern:** Binary Tree

**Difficulty:** Easy

**Problem:**
Find the lowest common ancestor of two nodes in a BST.

**Examples:**
```text
Input: root = [6,2,8,0,4,7,9], p = 2, q = 8
```

```text
Output: 6
```

**Approach:**
Use BST properties to traverse down toward the split point of p and q.

**Code:**
```python
`` `python
def lowestCommonAncestor(root, p, q):
    if p.val < root.val and q.val < root.val:
        return lowestCommonAncestor(root.left, p, q)
    elif p.val > root.val and q.val > root.val:
        return lowestCommonAncestor(root.right, p, q)
    else:
        return root
`` `
```

## Problem 20: Binary Tree Level Order Traversal

**Category/Pattern:** Binary Tree

**Difficulty:** Medium

**Problem:**
Return the level order traversal of a binary tree.

**Examples:**
```text
Input: root = [3,9,20,null,null,15,7]
```

```text
Output: [[3],[9,20],[15,7]]
```

**Approach:**
Use a queue to do a breadth-first traversal and group nodes level-wise.

**Code:**
```python
`` `python
from collections import deque

def levelOrder(root):
    if not root:
        return []
    result = []
    queue = deque([root])

    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)

    return result
`` `
```

## Problem 21: Binary Search

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Given a sorted array of integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

**Examples:**
```text
Input: nums = [1,3,5,6], target = 5
Output: 2
```

```text
Input: nums = [1,3,5,6], target = 2
Output: 1
```

**Approach:**
Use a standard binary search approach. Adjust pointers based on comparisons with the mid-value.

**Code:**
```python
`` `python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left
`` `
```

## Problem 22: Search a 2D Matrix

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.

**Examples:**
```text
Input: matrix = [[1,3,5],[7,9,11],[13,15,17]], target = 9
Output: True
```

```text
Input: matrix = [[1,3,5],[7,9,11],[13,15,17]], target = 10
Output: False
```

**Approach:**
Treat the matrix as a 1D array and apply binary search by calculating row and column indices from the mid index.

**Code:**
```python
`` `python
def searchMatrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1
    while left <= right:
        mid = (left + right) // 2
        mid_val = matrix[mid // n][mid % n]
        if mid_val == target:
            return True
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
`` `
```

## Problem 23: Time Based Key-Value Store

**Category/Pattern:** Hashmap / Binary Search

**Difficulty:** Medium

**Problem:**
Design a time-based key-value data structure that stores multiple values for the same key at different time stamps and retrieves the value for a key at a specific time.

**Examples:**
```text
set("foo", "bar", 1)
get("foo", 1) -> "bar"
get("foo", 3) -> "bar"
set("foo", "bar2", 4)
get("foo", 4) -> "bar2"
get("foo", 5) -> "bar2"
```

**Approach:**
Use a dictionary of lists and binary search on timestamps to efficiently retrieve the latest value <= the given timestamp.

**Code:**
```python
`` `python
import collections
import bisect

class TimeMap:
    def __init__(self):
        self.store = collections.defaultdict(list)

    def set(self, key, value, timestamp):
        self.store[key].append((timestamp, value))

    def get(self, key, timestamp):
        arr = self.store[key]
        i = bisect.bisect_right(arr, (timestamp, chr(127)))
        return arr[i-1][1] if i else ""
`` `
```

## Problem 24: Find Minimum in Rotated Sorted Array

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Find the minimum element.

**Examples:**
```text
Input: nums = [3,4,5,1,2]
Output: 1
```

```text
Input: nums = [4,5,6,7,0,1,2]
Output: 0
```

**Approach:**
Use binary search. If mid element > right, minimum is on the right side; otherwise, it's on the left.

**Code:**
```python
`` `python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
`` `
```

## Problem 25: Search in Rotated Sorted Array

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
You are given an integer array nums sorted in ascending order, and an integer target. Suppose nums is rotated at an unknown pivot. Return the index of target if found, else -1.

**Examples:**
```text
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

```text
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Approach:**
Use binary search and determine which half is sorted to narrow down the target location.

**Code:**
```python
`` `python
def search(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
`` `
```

## Problem 26: Koko Eating Bananas

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Koko loves to eat bananas. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them. Find the minimum k such that she can eat all the bananas within h hours.

**Examples:**
```text
Input: piles = [3,6,7,11], h = 8
Output: 4
```

**Approach:**
Use binary search on k (from 1 to max(piles)). For each k, check if total hours <= h.

**Code:**
```python
`` `python
import math

def minEatingSpeed(piles, h):
    left, right = 1, max(piles)
    while left < right:
        mid = (left + right) // 2
        if sum(math.ceil(p / mid) for p in piles) <= h:
            right = mid
        else:
            left = mid + 1
    return left
`` `
```

## Problem 27: Minimum Limit of Balls in a Bag

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
You are given n bags of balls, each bag contains a positive number of balls. You can perform operations to split any bag into two bags. Find the minimum possible maximum number of balls in a bag after performing at most maxOperations operations.

**Examples:**
```text
Input: nums = [9], maxOperations = 2
Output: 3
```

**Approach:**
Use binary search to minimize the max size. Check how many operations are needed to keep each bag ≤ mid.

**Code:**
```python
`` `python
def minimumSize(nums, maxOperations):
    def canDivide(maxSize):
        ops = 0
        for num in nums:
            ops += (num - 1) // maxSize
        return ops <= maxOperations

    left, right = 1, max(nums)
    while left < right:
        mid = (left + right) // 2
        if canDivide(mid):
            right = mid
        else:
            left = mid + 1
    return left
`` `
```

## Problem 28: Median of Two Sorted Arrays

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Given two sorted arrays nums1 and nums2, return the median of the two sorted arrays.

**Examples:**
```text
Input: nums1 = [1,3], nums2 = [2]
Output: 2.0
```

```text
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.5
```

**Approach:**
Use binary search on the smaller array to find the correct partition such that left half ≤ right half.

**Code:**
```python
`` `python
def findMedianSortedArrays(nums1, nums2):
    A, B = nums1, nums2
    if len(A) > len(B):
        A, B = B, A

    total = len(A) + len(B)
    half = total // 2
    left, right = 0, len(A)

    while True:
        i = (left + right) // 2
        j = half - i

        Aleft = A[i - 1] if i > 0 else float("-inf")
        Aright = A[i] if i < len(A) else float("inf")
        Bleft = B[j - 1] if j > 0 else float("-inf")
        Bright = B[j] if j < len(B) else float("inf")

        if Aleft <= Bright and Bleft <= Aright:
            if total % 2:
                return min(Aright, Bright)
            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
        elif Aleft > Bright:
            right = i - 1
        else:
            left = i + 1
`` `
```

## Problem 29: Kth Smallest Element in a Sorted Matrix

**Category/Pattern:** Heap / Binary Search

**Difficulty:** Medium

**Problem:**
Given an n x n matrix where each row and column is sorted in ascending order, return the kth smallest element.

**Examples:**
```text
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
```

**Approach:**
Use binary search from smallest to largest element. Count how many elements are ≤ mid.

**Code:**
```python
`` `python
def kthSmallest(matrix, k):
    n = len(matrix)

    def countLessEqual(x):
        count, i, j = 0, n - 1, 0
        while i >= 0 and j < n:
            if matrix[i][j] <= x:
                count += i + 1
                j += 1
            else:
                i -= 1
        return count

    left, right = matrix[0][0], matrix[-1][-1]
    while left < right:
        mid = (left + right) // 2
        if countLessEqual(mid) < k:
            left = mid + 1
        else:
            right = mid
    return left
`` `
```

## Problem 30: Minimum in Rotated Sorted Array

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Find the minimum element in a rotated sorted array without duplicates.

**Examples:**
```text
Input: [3,4,5,1,2] → Output: 1
```

```text
Input: [4,5,6,7,0,1,2] → Output: 0
```

**Approach:**
Use binary search. Compare middle element with rightmost to determine the unsorted half.

**Code:**
```python
`` `python
def findMin(nums):
    left, right = 0, len(nums)-1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
`` `
```

## Problem 31: Search in Rotated Sorted Array

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Search a target value in a rotated sorted array.

**Examples:**
```text
Input: nums = [4,5,6,7,0,1,2], target = 0 → Output: 4
```

```text
Input: nums = [4,5,6,7,0,1,2], target = 3 → Output: -1
```

**Approach:**
Use binary search to find pivot, then apply binary search on the correct half.

**Code:**
```python
`` `python
def search(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
`` `
```

## Problem 32: Time Based Key-Value Store

**Category/Pattern:** Hashmap

**Difficulty:** Medium

**Problem:**
Design a time-based key-value data structure that returns values for a key at a given timestamp.

**Examples:**
```text
Input: set('foo', 'bar', 1), get('foo', 1) → Output: 'bar'
```

```text
Input: get('foo', 3) → Output: 'bar'
```

**Approach:**
Use a hashmap with binary search over timestamps.

**Code:**
```python
`` `python
class TimeMap:
    def __init__(self):
        self.store = defaultdict(list)
    
    def set(self, key, value, timestamp):
        self.store[key].append((timestamp, value))
    
    def get(self, key, timestamp):
        values = self.store.get(key, [])
        res = ""
        l, r = 0, len(values) - 1
        while l <= r:
            m = (l + r) // 2
            if values[m][0] <= timestamp:
                res = values[m][1]
                l = m + 1
            else:
                r = m - 1
        return res
`` `
```

## Problem 33: Median of Two Sorted Arrays

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Find the median of two sorted arrays in O(log(min(n, m))) time.

**Examples:**
```text
Input: nums1 = [1,3], nums2 = [2] → Output: 2.0
```

```text
Input: nums1 = [1,2], nums2 = [3,4] → Output: 2.5
```

**Approach:**
Use binary search on the smaller array to find the partition point.

**Code:**
```python
`` `python
def findMedianSortedArrays(nums1, nums2):
    A, B = nums1, nums2
    if len(A) > len(B):
        A, B = B, A
    total = len(A) + len(B)
    half = total // 2
    l, r = 0, len(A) - 1
    while True:
        i = (l + r) // 2
        j = half - i - 2
        Aleft = A[i] if i >= 0 else float('-inf')
        Aright = A[i + 1] if (i + 1) < len(A) else float('inf')
        Bleft = B[j] if j >= 0 else float('-inf')
        Bright = B[j + 1] if (j + 1) < len(B) else float('inf')
        if Aleft <= Bright and Bleft <= Aright:
            if total % 2:
                return min(Aright, Bright)
            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
        elif Aleft > Bright:
            r = i - 1
        else:
            l = i + 1
`` `
```

## Problem 34: Koko Eating Bananas

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Given piles of bananas and an integer h, return the minimum eating speed k such that Koko can eat all the bananas within h hours.

**Examples:**
```text
Input: piles = [3,6,7,11], h = 8 → Output: 4
```

**Approach:**
Use binary search between 1 and max(piles) to find the minimum feasible speed.

**Code:**
```python
`` `python
def minEatingSpeed(piles, h):
    left, right = 1, max(piles)
    res = right
    while left <= right:
        mid = (left + right) // 2
        hours = sum(math.ceil(p / mid) for p in piles)
        if hours <= h:
            res = mid
            right = mid - 1
        else:
            left = mid + 1
    return res
`` `
```

## Problem 35: Find Minimum in Rotated Sorted Array II

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Find the minimum element in a rotated sorted array that may contain duplicates.

**Examples:**
```text
Input: [2,2,2,0,1] → Output: 0
```

**Approach:**
Modified binary search: shrink right if nums[mid] == nums[right].

**Code:**
```python
`` `python
def findMin(nums):
    left, right = 0, len(nums)-1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        elif nums[mid] < nums[right]:
            right = mid
        else:
            right -= 1
    return nums[left]
`` `
```

## Problem 36: Search in Rotated Sorted Array II

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Search target in rotated sorted array that may contain duplicates.

**Examples:**
```text
Input: nums = [2,5,6,0,0,1,2], target = 0 → Output: True
```

```text
Input: nums = [2,5,6,0,0,1,2], target = 3 → Output: False
```

**Approach:**
Same binary search as before, but if nums[left] == nums[mid], increment left.

**Code:**
```python
`` `python
def search(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return True
        if nums[left] == nums[mid]:
            left += 1
            continue
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return False
`` `
```

## Problem 37: Find Peak Element

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
A peak element is greater than its neighbors. Return the index of any peak.

**Examples:**
```text
Input: nums = [1,2,3,1] → Output: 2
```

```text
Input: nums = [1,2,1,3,5,6,4] → Output: 1 or 5
```

**Approach:**
Use binary search: if nums[mid] > nums[mid+1], go left.

**Code:**
```python
`` `python
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1
    return left
`` `
```

## Problem 38: Search a 2D Matrix

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Write an efficient algorithm that searches for a value in an m x n matrix.

**Examples:**
```text
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 → Output: True
```

**Approach:**
Flatten the matrix and perform binary search by calculating row and col from index.

**Code:**
```python
`` `python
def searchMatrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1
    while left <= right:
        mid = (left + right) // 2
        val = matrix[mid // n][mid % n]
        if val == target:
            return True
        elif val < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
`` `
```

## Problem 39: Find Kth Largest Element in an Array

**Category/Pattern:** Heap / Quickselect

**Difficulty:** Medium

**Problem:**
Return the kth largest element in an unsorted array.

**Examples:**
```text
Input: nums = [3,2,1,5,6,4], k = 2 → Output: 5
```

```text
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 → Output: 4
```

**Approach:**
Use a min-heap or quickselect algorithm.

**Code:**
```python
`` `python
def findKthLargest(nums, k):
    return heapq.nlargest(k, nums)[-1]
`` `
```

## Problem 40: Number of 1 Bits

**Category/Pattern:** Bit Manipulation

**Difficulty:** Easy

**Problem:**
Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

**Examples:**
```text
Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string has a total of three '1' bits.
```

**Approach:**
Use bitwise operations to check each bit of the number by ANDing it with 1 and shifting right.

**Code:**
```python
`` `python
class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        while n:
            count += n & 1
            n >>= 1
        return count
`` `
```

## Problem 41: Counting Bits

**Category/Pattern:** Bit Manipulation

**Difficulty:** Easy

**Problem:**
Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

**Examples:**
```text
Input: n = 5
Output: [0,1,1,2,1,2]
```

**Approach:**
Use dynamic programming with the relation: bits[i] = bits[i >> 1] + (i & 1).

**Code:**
```python
`` `python
class Solution:
    def countBits(self, n: int) -> List[int]:
        res = [0] * (n + 1)
        for i in range(1, n + 1):
            res[i] = res[i >> 1] + (i & 1)
        return res
`` `
```

## Problem 42: Reverse Bits

**Category/Pattern:** Bit Manipulation

**Difficulty:** Easy

**Problem:**
Reverse bits of a given 32 bits unsigned integer.

**Examples:**
```text
Input: n = 00000010100101000001111010011100
Output: 964176192
Explanation: The input binary string is reversed to 00111001011110000010100101000000
```

**Approach:**
Iterate over the bits, shifting the result and adding current bit using bitwise operations.

**Code:**
```python
`` `python
class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for _ in range(32):
            res = (res << 1) | (n & 1)
            n >>= 1
        return res
`` `
```

## Problem 43: Missing Number

**Category/Pattern:** Math | Bit Manipulation

**Difficulty:** Easy

**Problem:**
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

**Examples:**
```text
Input: nums = [3,0,1]
Output: 2
```

**Approach:**
Use XOR of all numbers from 0 to n and the array to cancel out and get the missing number.

**Code:**
```python
`` `python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = len(nums)
        for i, num in enumerate(nums):
            res ^= i ^ num
        return res
`` `
```

## Problem 44: Sum of Two Integers

**Category/Pattern:** Bit Manipulation

**Difficulty:** Medium

**Problem:**
Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.

**Examples:**
```text
Input: a = 1, b = 2
Output: 3
```

**Approach:**
Use bitwise operations to simulate addition using XOR and carry using AND and shift.

**Code:**
```python
`` `python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        mask = 0xFFFFFFFF
        while b != 0:
            carry = (a & b) & mask
            a = (a ^ b) & mask
            b = carry << 1
        return a if a <= 0x7FFFFFFF else ~(a ^ mask)
`` `
```

## Problem 45: Reverse Integer

**Category/Pattern:** Math

**Difficulty:** Medium

**Problem:**
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range, return 0.

**Examples:**
```text
Input: x = 123
Output: 321
```

**Approach:**
Pop digits one by one and push to result using modulus and integer division. Check for overflow.

**Code:**
```python
`` `python
class Solution:
    def reverse(self, x: int) -> int:
        res = 0
        sign = -1 if x < 0 else 1
        x = abs(x)
        while x != 0:
            pop = x % 10
            x //= 10
            if res > (2**31 - 1 - pop) // 10:
                return 0
            res = res * 10 + pop
        return sign * res
`` `
```

## Problem 46: Palindrome Number

**Category/Pattern:** Math

**Difficulty:** Medium

**Problem:**
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

**Examples:**
```text
Input: x = 121
Output: True
```

**Approach:**
Reverse the number and compare with the original.

**Code:**
```python
`` `python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        return x == int(str(x)[::-1])
`` `
```

## Problem 47: Fizz Buzz

**Category/Pattern:** Math

**Difficulty:** Medium

**Problem:**
Given an integer n, return a string array answer (1-indexed) where:
- answer[i] == 'FizzBuzz' if i is divisible by 3 and 5.
- answer[i] == 'Fizz' if i is divisible by 3.
- answer[i] == 'Buzz' if i is divisible by 5.
- answer[i] == i (as a string) if none of the above conditions are true.

**Examples:**
```text
Input: n = 3
Output: ["1","2","Fizz"]
```

**Approach:**
Use modulo operator to check for divisibility and append appropriate strings.

**Code:**
```python
`` `python
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        res = []
        for i in range(1, n + 1):
            if i % 15 == 0:
                res.append("FizzBuzz")
            elif i % 3 == 0:
                res.append("Fizz")
            elif i % 5 == 0:
                res.append("Buzz")
            else:
                res.append(str(i))
        return res
`` `
```

## Problem 48: Power of Two

**Category/Pattern:** Bit Manipulation

**Difficulty:** Medium

**Problem:**
Given an integer n, return true if it is a power of two. Otherwise, return false.

**Examples:**
```text
Input: n = 16
Output: true
```

**Approach:**
A power of two has only one bit set. Use n & (n - 1) == 0 to check.

**Code:**
```python
`` `python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0
`` `
```

## Problem 49: Power of Three

**Category/Pattern:** Math

**Difficulty:** Medium

**Problem:**
Given an integer n, return true if it is a power of three. Otherwise, return false.

**Examples:**
```text
Input: n = 27
Output: true
```

**Approach:**
Check if 3^x == n using division. Or check if n divides the largest power of 3 within int range.

**Code:**
```python
`` `python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and 1162261467 % n == 0
`` `
```

## Problem 50: Power of Four

**Category/Pattern:** Math

**Difficulty:** Medium

**Problem:**
Given an integer n, return true if it is a power of four. Otherwise, return false.

**Examples:**
```text
Input: n = 16
Output: true
Explanation: 4^2 = 16
```

**Approach:**
A number is a power of four if it's a power of two and the only 1-bit is in the correct position. Use bitmasking or check using modulus.

**Code:**
```python
`` `python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0
`` `
```

## Problem 51: Roman to Integer

**Category/Pattern:** Hashmap

**Difficulty:** Medium

**Problem:**
Convert a Roman numeral to an integer.

**Examples:**
```text
Input: s = 'MCMXCIV'
Output: 1994
```

**Approach:**
Use a hashmap to store Roman numerals. If a smaller numeral appears before a larger one, subtract it; otherwise, add it.

**Code:**
```python
`` `python
class Solution:
    def romanToInt(self, s: str) -> int:
        roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,
                 'C': 100, 'D': 500, 'M': 1000}
        total = 0
        prev = 0
        for char in reversed(s):
            curr = roman[char]
            if curr < prev:
                total -= curr
            else:
                total += curr
            prev = curr
        return total
`` `
```

## Problem 52: Longest Common Prefix

**Category/Pattern:** Strings

**Difficulty:** Medium

**Problem:**
Write a function to find the longest common prefix string amongst an array of strings.

**Examples:**
```text
Input: strs = ["flower","flow","flight"]
Output: "fl"
```

**Approach:**
Sort the array and compare the first and last string character by character.

**Code:**
```python
`` `python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        strs.sort()
        first = strs[0]
        last = strs[-1]
        i = 0
        while i < len(first) and first[i] == last[i]:
            i += 1
        return first[:i]
`` `
```

## Problem 53: Valid Parentheses

**Category/Pattern:** Stack

**Difficulty:** Easy

**Problem:**
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

**Examples:**
```text
Input: s = "()[]{}"
Output: true
```

**Approach:**
Use a stack to match each opening bracket with its closing counterpart.

**Code:**
```python
`` `python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {')': '(', '}': '{', ']': '['}
        for char in s:
            if char in mapping.values():
                stack.append(char)
            elif char in mapping:
                if not stack or mapping[char] != stack.pop():
                    return False
        return not stack
`` `
```

## Problem 54: Valid Anagram

**Category/Pattern:** Hashmap | Sorting

**Difficulty:** Easy

**Problem:**
Given two strings s and t, return true if t is an anagram of s, and false otherwise.

**Examples:**
```text
Input: s = "anagram", t = "nagaram"
Output: true
```

**Approach:**
Sort both strings and compare, or use a hashmap to count characters.

**Code:**
```python
`` `python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
`` `
```

## Problem 55: Valid Palindrome

**Category/Pattern:** Two Pointers

**Difficulty:** Easy

**Problem:**
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

**Examples:**
```text
Input: s = "A man, a plan, a canal: Panama"
Output: true
```

**Approach:**
Use two pointers to compare characters after cleaning the string.

**Code:**
```python
`` `python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = ''.join(c.lower() for c in s if c.isalnum())
        return s == s[::-1]
`` `
```

## Problem 56: Valid Palindrome II

**Category/Pattern:** Two Pointers

**Difficulty:** Easy

**Problem:**
Given a string s, return true if the s can be palindrome after deleting at most one character from it.

**Examples:**
```text
Input: s = "abca"
Output: true
```

**Approach:**
Use two pointers and a helper function to check if substring is a palindrome when one character is skipped.

**Code:**
```python
`` `python
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def is_palindrome(i, j):
            return s[i:j+1] == s[i:j+1][::-1]

        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                return is_palindrome(left+1, right) or is_palindrome(left, right-1)
            left += 1
            right -= 1
        return True
`` `
```

## Problem 57: Implement strStr()

**Category/Pattern:** Two Pointers | Substring

**Difficulty:** Medium

**Problem:**
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

**Examples:**
```text
Input: haystack = "hello", needle = "ll"
Output: 2
```

**Approach:**
Use built-in `find()` or implement KMP/naive search if needed.

**Code:**
```python
`` `python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        return haystack.find(needle)
`` `
```

## Problem 58: Longest Substring Without Repeating Characters

**Category/Pattern:** Sliding Window

**Difficulty:** Medium

**Problem:**
Given a string s, find the length of the longest substring without repeating characters.

**Examples:**
```text
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Approach:**
Use a sliding window with a set to track characters.

**Code:**
```python
`` `python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        char_set = set()
        l = res = 0
        for r in range(len(s)):
            while s[r] in char_set:
                char_set.remove(s[l])
                l += 1
            char_set.add(s[r])
            res = max(res, r - l + 1)
        return res
`` `
```

## Problem 59: Longest Repeating Character Replacement

**Category/Pattern:** Sliding Window

**Difficulty:** Medium

**Problem:**
Given a string s and an integer k, return the length of the longest substring containing the same letter you can get after performing at most k character replacements.

**Examples:**
```text
Input: s = "ABAB", k = 2
Output: 4
```

**Approach:**
Use a sliding window and maintain the count of the most frequent character. Expand while the window is valid.

**Code:**
```python
`` `python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = {}
        res = maxf = l = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            maxf = max(maxf, count[s[r]])
            while (r - l + 1) - maxf > k:
                count[s[l]] -= 1
                l += 1
            res = max(res, r - l + 1)
        return res
`` `
```

## Problem 60: Minimum Window Substring

**Category/Pattern:** Sliding Window

**Difficulty:** Hard

**Problem:**
Given two strings s and t, return the minimum window in s which will contain all the characters in t.

**Examples:**
```text
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
```

**Approach:**
Use a sliding window and two hashmaps to track character frequencies of s and t. Expand until valid, then try to shrink.

**Code:**
```python
`` `python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if not t or not s:
            return ""
        from collections import Counter

        t_count = Counter(t)
        window = {}
        have, need = 0, len(t_count)
        res, res_len = [-1, -1], float("inf")
        l = 0

        for r, c in enumerate(s):
            window[c] = window.get(c, 0) + 1
            if c in t_count and window[c] == t_count[c]:
                have += 1
            while have == need:
                if (r - l + 1) < res_len:
                    res = [l, r]
                    res_len = r - l + 1
                window[s[l]] -= 1
                if s[l] in t_count and window[s[l]] < t_count[s[l]]:
                    have -= 1
                l += 1
        l, r = res
        return s[l:r+1] if res_len != float("inf") else ""
`` `
```

## Problem 61: Valid Anagram

**Category/Pattern:** Hashmap | Sorting

**Difficulty:** Easy

**Problem:**
Given two strings s and t, return true if t is an anagram of s, and false otherwise.

**Examples:**
```text
Input: s = "anagram", t = "nagaram"
Output: true
```

**Approach:**
Sort both strings and compare, or use a hashmap to count characters.

**Code:**
```python
`` `python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
`` `
```

## Problem 62: Group Anagrams

**Category/Pattern:** Hashmap | Sorting

**Difficulty:** Medium

**Problem:**
Group anagrams from a list of strings. Return the result as a list of grouped anagram lists.

**Examples:**
```text
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**Approach:**
Use a hashmap with the sorted version of the word as key.

**Code:**
```python
`` `python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = defaultdict(list)
        for word in strs:
            key = tuple(sorted(word))
            res[key].append(word)
        return list(res.values())
`` `
```

## Problem 63: Top K Frequent Elements

**Category/Pattern:** Heap | Hashmap

**Difficulty:** Medium

**Problem:**
Return the k most frequent elements in the array.

**Examples:**
```text
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Approach:**
Use a hashmap to count frequencies, then a heap to extract the k most frequent.

**Code:**
```python
`` `python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = Counter(nums)
        return heapq.nlargest(k, count.keys(), key=count.get)
`` `
```

## Problem 64: Product of Array Except Self

**Category/Pattern:** Prefix Product

**Difficulty:** Medium

**Problem:**
Return an array such that each element at index i is the product of all numbers in the array except nums[i], without using division.

**Examples:**
```text
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
```

**Approach:**
Use two passes — one for left prefix product and one for right prefix product.

**Code:**
```python
`` `python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * len(nums)
        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        return res
`` `
```

## Problem 65: Encode and Decode Strings

**Category/Pattern:** Strings | Design

**Difficulty:** Medium

**Problem:**
Design an algorithm to encode a list of strings to a single string and decode it back.

**Examples:**
```text
Input: ["lint","code","love","you"]
Output: encoded string -> decoded list
```

**Approach:**
Encode by prefixing each word with its length and a delimiter. Decode accordingly.

**Code:**
```python
`` `python
class Codec:
    def encode(self, strs):
        return ''.join(f"{len(s)}#{s}" for s in strs)

    def decode(self, s):
        res, i = [], 0
        while i < len(s):
            j = i
            while s[j] != '#':
                j += 1
            length = int(s[i:j])
            res.append(s[j+1:j+1+length])
            i = j + 1 + length
        return res
`` `
```

## Problem 66: Longest Palindrome

**Category/Pattern:** Hashmap

**Difficulty:** Medium

**Problem:**
Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.

**Examples:**
```text
Input: s = "abccccdd"
Output: 7
```

**Approach:**
Count frequencies. Use all even-count characters and at most one odd.

**Code:**
```python
`` `python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        freq = Counter(s)
        res = 0
        odd = False
        for count in freq.values():
            if count % 2 == 0:
                res += count
            else:
                res += count - 1
                odd = True
        return res + 1 if odd else res
`` `
```

## Problem 67: Palindromic Substrings

**Category/Pattern:** DP | Expand Around Center

**Difficulty:** Medium

**Problem:**
Return the number of palindromic substrings in the given string.

**Examples:**
```text
Input: s = "abc"
Output: 3
```

**Approach:**
Expand around every center and count valid palindromes.

**Code:**
```python
`` `python
class Solution:
    def countSubstrings(self, s: str) -> int:
        res = 0
        for i in range(len(s)):
            res += self.count_palindromes(s, i, i)
            res += self.count_palindromes(s, i, i + 1)
        return res

    def count_palindromes(self, s, l, r):
        count = 0
        while l >= 0 and r < len(s) and s[l] == s[r]:
            count += 1
            l -= 1
            r += 1
        return count
`` `
```

## Problem 68: Longest Palindromic Substring

**Category/Pattern:** Expand Around Center

**Difficulty:** Medium

**Problem:**
Find the longest palindromic substring in the given string.

**Examples:**
```text
Input: s = "babad"
Output: "bab" or "aba"
```

**Approach:**
Expand around each center and track the longest.

**Code:**
```python
`` `python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ""
        for i in range(len(s)):
            tmp1 = self.expand(s, i, i)
            tmp2 = self.expand(s, i, i + 1)
            if len(tmp1) > len(res):
                res = tmp1
            if len(tmp2) > len(res):
                res = tmp2
        return res

    def expand(self, s, l, r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1
            r += 1
        return s[l+1:r]
`` `
```

## Problem 69: Reverse String

**Category/Pattern:** Two Pointers

**Difficulty:** Medium

**Problem:**
Write a function that reverses a string. The input string is given as an array of characters.

**Examples:**
```text
Input: ['h','e','l','l','o']
Output: ['o','l','l','e','h']
```

**Approach:**
Use two pointers from both ends to swap characters.

**Code:**
```python
`` `python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        l, r = 0, len(s) - 1
        while l < r:
            s[l], s[r] = s[r], s[l]
            l += 1
            r -= 1
`` `
```

## Problem 70: Find Minimum in Rotated Sorted Array

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Suppose an array of length `n` sorted in ascending order is rotated between 1 and `n` times. Find the minimum element in the array.

**Examples:**
```text
Input: [3,4,5,1,2]
Output: 1
```

```text
Input: [4,5,6,7,0,1,2]
Output: 0
```

**Approach:**
Use binary search to find the pivot where the rotation happens, comparing mid to the rightmost element.

**Code:**
```python
`` `python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
`` `
```

## Problem 71: Search in Rotated Sorted Array

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Search for a target value in a rotated sorted array. Return its index or -1 if not found.

**Examples:**
```text
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

```text
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Approach:**
Use binary search, identifying which side of the array is sorted and narrowing down accordingly.

**Code:**
```python
`` `python
def search(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right)//2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid-1
            else:
                left = mid+1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid+1
            else:
                right = mid-1
    return -1
`` `
```

## Problem 72: Median of Two Sorted Arrays

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

**Examples:**
```text
Input: nums1 = [1,3], nums2 = [2]
Output: 2.0
```

```text
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.5
```

**Approach:**
Use binary search on the smaller array to find the correct partition.

**Code:**
```python
`` `python
def findMedianSortedArrays(nums1, nums2):
    A, B = nums1, nums2
    total = len(A) + len(B)
    half = total // 2
    if len(B) < len(A):
        A, B = B, A

    l, r = 0, len(A) - 1
    while True:
        i = (l + r) // 2
        j = half - i - 2
        Aleft = A[i] if i >= 0 else float("-inf")
        Aright = A[i + 1] if i + 1 < len(A) else float("inf")
        Bleft = B[j] if j >= 0 else float("-inf")
        Bright = B[j + 1] if j + 1 < len(B) else float("inf")

        if Aleft <= Bright and Bleft <= Aright:
            if total % 2:
                return min(Aright, Bright)
            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
        elif Aleft > Bright:
            r = i - 1
        else:
            l = i + 1
`` `
```

## Problem 73: Time Based Key-Value Store

**Category/Pattern:** Binary Search / HashMap

**Difficulty:** Medium

**Problem:**
Design a time-based key-value data structure that can store multiple values for the same key at different timestamps and retrieve the value at a given timestamp.

**Examples:**
```text
Input:
set("foo", "bar", 1)
get("foo", 1) -> "bar"
get("foo", 3) -> "bar"
set("foo", "bar2", 4)
get("foo", 4) -> "bar2"
get("foo", 5) -> "bar2"
```

**Approach:**
Use a dictionary mapping keys to a list of (timestamp, value) pairs. Binary search the list on `get`.

**Code:**
```python
`` `python
from collections import defaultdict
import bisect

class TimeMap:
    def __init__(self):
        self.store = defaultdict(list)

    def set(self, key, value, timestamp):
        self.store[key].append((timestamp, value))

    def get(self, key, timestamp):
        A = self.store[key]
        i = bisect.bisect_right(A, (timestamp, chr(127)))
        return A[i - 1][1] if i else ""
`` `
```

## Problem 74: Koko Eating Bananas

**Category/Pattern:** Binary Search

**Difficulty:** Medium

**Problem:**
Koko loves to eat bananas. There are `n` piles of bananas. Determine the minimum integer speed `k` such that she can eat all the bananas within `h` hours.

**Examples:**
```text
Input: piles = [3,6,7,11], h = 8
Output: 4
```

**Approach:**
Use binary search on k from 1 to max(piles), and check if she can eat all bananas at that speed.

**Code:**
```python
`` `python
import math

def minEatingSpeed(piles, h):
    l, r = 1, max(piles)
    res = r
    while l <= r:
        k = (l + r) // 2
        hours = sum(math.ceil(p / k) for p in piles)
        if hours <= h:
            res = k
            r = k - 1
        else:
            l = k + 1
    return res
`` `
```

## Problem 75: Minimum Absolute Difference in BST

**Category/Pattern:** Binary Search Tree

**Difficulty:** Medium

**Problem:**
Given a Binary Search Tree, return the minimum absolute difference between values of any two nodes.

**Examples:**
```text
Input: root = [4,2,6,1,3]
Output: 1
```

**Approach:**
Perform in-order traversal to get sorted values, and compute the minimum adjacent difference.

**Code:**
```python
`` `python
def getMinimumDifference(root):
    prev = None
    res = float('inf')

    def inorder(node):
        nonlocal prev, res
        if not node:
            return
        inorder(node.left)
        if prev:
            res = min(res, abs(node.val - prev.val))
        prev = node
        inorder(node.right)

    inorder(root)
    return res
`` `
```

## Problem 76: Diameter of Binary Tree

**Category/Pattern:** DFS / Binary Tree

**Difficulty:** Easy

**Problem:**
Return the length of the diameter of the binary tree. The diameter is the length of the longest path between any two nodes.

**Examples:**
```text
Input: [1,2,3,4,5]
Output: 3
```

**Approach:**
Use DFS to compute the height of each subtree and track the maximum path length through each node.

**Code:**
```python
`` `python
def diameterOfBinaryTree(root):
    res = [0]

    def dfs(node):
        if not node:
            return 0
        left = dfs(node.left)
        right = dfs(node.right)
        res[0] = max(res[0], left + right)
        return 1 + max(left, right)

    dfs(root)
    return res[0]
`` `
```

## Problem 77: Maximum Depth of Binary Tree

**Category/Pattern:** DFS / Binary Tree

**Difficulty:** Easy

**Problem:**
Find the maximum depth of a binary tree.

**Examples:**
```text
Input: [3,9,20,null,null,15,7]
Output: 3
```

**Approach:**
Use DFS to find the height of left and right subtrees and return 1 + max(left, right).

**Code:**
```python
`` `python
def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
`` `
```

## Problem 78: Balanced Binary Tree

**Category/Pattern:** DFS / Binary Tree

**Difficulty:** Easy

**Problem:**
Check if a binary tree is height-balanced.

**Examples:**
```text
Input: [3,9,20,null,null,15,7]
Output: True
```

**Approach:**
Check if left and right subtrees are balanced and their height difference is <= 1 using bottom-up DFS.

**Code:**
```python
`` `python
def isBalanced(root):
    def dfs(node):
        if not node:
            return [True, 0]
        left = dfs(node.left)
        right = dfs(node.right)
        balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1
        return [balanced, 1 + max(left[1], right[1])]
    return dfs(root)[0]
`` `
```

## Problem 79: Same Tree

**Category/Pattern:** DFS / Binary Tree

**Difficulty:** Easy

**Problem:**
Determine if two binary trees are the same.

**Examples:**
```text
Input: p = [1,2,3], q = [1,2,3]
Output: True
```

**Approach:**
Use recursive DFS to compare values and structure of both trees.

**Code:**
```python
`` `python
def isSameTree(p, q):
    if not p and not q:
        return True
    if not p or not q or p.val != q.val:
        return False
    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)
`` `
```

## Problem 80: Insert Interval

**Category/Pattern:** Intervals

**Difficulty:** Medium

**Problem:**
Given a set of non-overlapping intervals sorted by start time, insert a new interval into the intervals (merge if necessary).

**Examples:**
```text
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
```

```text
Output: [[1,5],[6,9]]
```

**Approach:**
Iterate over existing intervals. Add intervals that end before the new one. Merge overlapping ones. Append the remaining.

**Code:**
```python
`` `python
def insert(intervals, newInterval):
    res = []
    for i in range(len(intervals)):
        if newInterval[1] < intervals[i][0]:
            res.append(newInterval)
            return res + intervals[i:]
        elif newInterval[0] > intervals[i][1]:
            res.append(intervals[i])
        else:
            newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]
    res.append(newInterval)
    return res
`` `
```

## Problem 81: Non-overlapping Intervals

**Category/Pattern:** Intervals

**Difficulty:** Medium

**Problem:**
Find the minimum number of intervals you need to remove to make the rest non-overlapping.

**Examples:**
```text
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
```

```text
Output: 1
```

**Approach:**
Sort by end time. Greedily keep non-overlapping intervals and count removals.

**Code:**
```python
`` `python
def eraseOverlapIntervals(intervals):
    intervals.sort(key=lambda x: x[1])
    end = float('-inf')
    count = 0
    for i in intervals:
        if i[0] >= end:
            end = i[1]
        else:
            count += 1
    return count
`` `
```

## Problem 82: Meeting Rooms

**Category/Pattern:** Intervals

**Difficulty:** Easy

**Problem:**
Given an array of meeting time intervals, determine if a person could attend all meetings.

**Examples:**
```text
Input: intervals = [[0,30],[5,10],[15,20]]
```

```text
Output: False
```

**Approach:**
Sort intervals by start time and check for overlaps.

**Code:**
```python
`` `python
def canAttendMeetings(intervals):
    intervals.sort()
    for i in range(1, len(intervals)):
        if intervals[i][0] < intervals[i-1][1]:
            return False
    return True
`` `
```

## Problem 83: Meeting Rooms II

**Category/Pattern:** Intervals

**Difficulty:** Medium

**Problem:**
Return the minimum number of conference rooms required to hold all meetings.

**Examples:**
```text
Input: intervals = [[0,30],[5,10],[15,20]]
```

```text
Output: 2
```

**Approach:**
Use a min-heap to track end times of meetings.

**Code:**
```python
`` `python
import heapq
def minMeetingRooms(intervals):
    if not intervals:
        return 0
    intervals.sort(key=lambda x: x[0])
    heap = [intervals[0][1]]
    for i in intervals[1:]:
        if i[0] >= heap[0]:
            heapq.heappop(heap)
        heapq.heappush(heap, i[1])
    return len(heap)
`` `
```

## Problem 84: Merge Intervals

**Category/Pattern:** Intervals

**Difficulty:** Medium

**Problem:**
Merge all overlapping intervals.

**Examples:**
```text
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
```

```text
Output: [[1,6],[8,10],[15,18]]
```

**Approach:**
Sort by start and merge while iterating.

**Code:**
```python
`` `python
def merge(intervals):
    intervals.sort(key=lambda x: x[0])
    merged = []
    for interval in intervals:
        if not merged or merged[-1][1] < interval[0]:
            merged.append(interval)
        else:
            merged[-1][1] = max(merged[-1][1], interval[1])
    return merged
`` `
```

## Problem 85: Unique Paths

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Find the number of unique paths in a grid from top-left to bottom-right, moving only right or down.

**Examples:**
```text
Input: m = 3, n = 7
```

```text
Output: 28
```

**Approach:**
Use dynamic programming with dp[i][j] = dp[i-1][j] + dp[i][j-1].

**Code:**
```python
`` `python
def uniquePaths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]
`` `
```

## Problem 86: Unique Paths II

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Like Unique Paths but with obstacles. Return number of unique paths avoiding obstacles.

**Examples:**
```text
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
```

```text
Output: 2
```

**Approach:**
Use dynamic programming and handle obstacle cells (set dp = 0 for obstacles).

**Code:**
```python
`` `python
def uniquePathsWithObstacles(obstacleGrid):
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    dp = [[0]*n for _ in range(m)]
    dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0
    for i in range(m):
        for j in range(n):
            if obstacleGrid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[-1][-1]
`` `
```

## Problem 87: Min Cost Climbing Stairs

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Each step has a cost. Return the minimum cost to reach the top of the stairs.

**Examples:**
```text
Input: cost = [10,15,20]
```

```text
Output: 15
```

**Approach:**
Use dp[i] = cost[i] + min(dp[i-1], dp[i-2]).

**Code:**
```python
`` `python
def minCostClimbingStairs(cost):
    n = len(cost)
    dp = [0]*(n+1)
    for i in range(2, n+1):
        dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
    return dp[n]
`` `
```

## Problem 88: Climbing Stairs

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
You can climb 1 or 2 steps. How many distinct ways to reach the top of n stairs?

**Examples:**
```text
Input: n = 3
```

```text
Output: 3
```

**Approach:**
Fibonacci-like DP: dp[i] = dp[i-1] + dp[i-2].

**Code:**
```python
`` `python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n+1):
        a, b = b, a + b
    return b
`` `
```

## Problem 89: Minimum Path Sum

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Find the path from top-left to bottom-right with the minimum sum of numbers in grid cells.

**Examples:**
```text
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
```

```text
Output: 7
```

**Approach:**
Use bottom-up DP with grid[i][j] += min(grid[i-1][j], grid[i][j-1]).

**Code:**
```python
`` `python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    for j in range(1, n):
        grid[0][j] += grid[0][j-1]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]
`` `
```

## Problem 90: Word Break

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

**Examples:**
```text
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
```

**Approach:**
Use dynamic programming to check if the string up to index i can be formed using the words in the dictionary. Initialize a dp array with False values, where dp[i] means s[:i] can be formed.

**Code:**
```python
`` `python
def wordBreak(s, wordDict):
    wordSet = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s)+1):
        for j in range(i):
            if dp[j] and s[j:i] in wordSet:
                dp[i] = True
                break
    return dp[-1]
`` `
```

## Problem 91: Word Break II

**Category/Pattern:** Backtracking | Memoization

**Difficulty:** Hard

**Problem:**
Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

**Examples:**
```text
Input: s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
Output: ["cats and dog","cat sand dog"]
```

**Approach:**
Use DFS with memoization. At each index, recursively try to match dictionary words and build valid sentences.

**Code:**
```python
`` `python
def wordBreak(s, wordDict):
    wordSet = set(wordDict)
    memo = {}
    def dfs(start):
        if start in memo:
            return memo[start]
        if start == len(s):
            return [""]
        res = []
        for end in range(start+1, len(s)+1):
            word = s[start:end]
            if word in wordSet:
                for sub in dfs(end):
                    if sub:
                        res.append(word + " " + sub)
                    else:
                        res.append(word)
        memo[start] = res
        return res
    return dfs(0)
`` `
```

## Problem 92: LRU Cache

**Category/Pattern:** Design | HashMap + Doubly Linked List

**Difficulty:** Medium

**Problem:**
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

**Examples:**
```text
Input:
["LRUCache","put","put","get","put","get","put","get","get","get"]
[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
Output: [null,null,null,1,null,-1,null,-1,3,4]
```

**Approach:**
Use an OrderedDict or implement your own doubly linked list + hashmap to track usage order and values.

**Code:**
```python
`` `python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key in self.cache:
            self.cache.move_to_end(key)
            return self.cache[key]
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
`` `
```

## Problem 93: LFU Cache

**Category/Pattern:** Design | Frequency Map + Linked List

**Difficulty:** Medium

**Problem:**
Design and implement a data structure for Least Frequently Used (LFU) cache.

**Examples:**
```text
Input:
["LFUCache","put","put","get","put","get","get","put","get","get","get"]
[[2],[1,1],[2,2],[1],[3,3],[2],[3],[4,4],[1],[3],[4]]
Output: [null,null,null,1,null,-1,3,null,-1,3,4]
```

**Approach:**
Use a combination of frequency counter and OrderedDict for frequency buckets. Track min frequency to evict least frequently used.

**Code:**
```python
`` `python
from collections import defaultdict, OrderedDict

class LFUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.minFreq = 0
        self.keyToVal = {}
        self.keyToFreq = {}
        self.freqToKeys = defaultdict(OrderedDict)

    def updateFreq(self, key):
        freq = self.keyToFreq[key]
        del self.freqToKeys[freq][key]
        if not self.freqToKeys[freq]:
            del self.freqToKeys[freq]
            if freq == self.minFreq:
                self.minFreq += 1
        self.keyToFreq[key] = freq + 1
        self.freqToKeys[freq + 1][key] = None

    def get(self, key: int) -> int:
        if key not in self.keyToVal:
            return -1
        self.updateFreq(key)
        return self.keyToVal[key]

    def put(self, key: int, value: int) -> None:
        if self.capacity == 0:
            return
        if key in self.keyToVal:
            self.keyToVal[key] = value
            self.updateFreq(key)
        else:
            if len(self.keyToVal) == self.capacity:
                evict = next(iter(self.freqToKeys[self.minFreq]))
                del self.freqToKeys[self.minFreq][evict]
                del self.keyToVal[evict]
                del self.keyToFreq[evict]
            self.keyToVal[key] = value
            self.keyToFreq[key] = 1
            self.freqToKeys[1][key] = None
            self.minFreq = 1
`` `
```

## Problem 94: Sliding Window Median

**Category/Pattern:** Heap | Sliding Window

**Difficulty:** Medium

**Problem:**
You are given an array nums and a sliding window of size k. Return the median of each window as it slides from left to right.

**Examples:**
```text
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1,-1,-1,3,5,6]
```

**Approach:**
Use two heaps (max-heap and min-heap) to maintain the window and compute median efficiently while sliding.

**Code:**
```python
`` `python
# Too long for inline example. Typically solved with heapq and rebalancing between heaps.
`` `
```

## Problem 95: Design Twitter

**Category/Pattern:** Design

**Difficulty:** Medium

**Problem:**
Design a simplified version of Twitter where users can post tweets, follow/unfollow other users, and view the 10 most recent tweets.

**Examples:**
```text
Twitter twitter = new Twitter();
twitter.postTweet(1, 5);
twitter.getNewsFeed(1);
twitter.follow(1, 2);
twitter.postTweet(2, 6);
twitter.getNewsFeed(1);
twitter.unfollow(1, 2);
twitter.getNewsFeed(1);
```

**Approach:**
Maintain tweet storage with timestamps and a mapping of user → followed users. Use a min-heap to collect top tweets from all followed users.

**Code:**
```python
`` `python
import heapq
from collections import defaultdict

class Twitter:
    def __init__(self):
        self.timestamp = 0
        self.tweets = defaultdict(list)
        self.following = defaultdict(set)

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets[userId].append((self.timestamp, tweetId))
        self.timestamp -= 1

    def getNewsFeed(self, userId: int):
        heap = []
        self.following[userId].add(userId)
        for uid in self.following[userId]:
            heap.extend(self.tweets[uid][-10:])
        return [tweetId for _, tweetId in heapq.nsmallest(10, heap)]

    def follow(self, followerId: int, followeeId: int) -> None:
        self.following[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followeeId != followerId:
            self.following[followerId].discard(followeeId)
`` `
```

## Problem 96: Unique Paths

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
A robot is located at the top-left corner of an m x n grid. The robot can only move either down or right. How many possible unique paths are there to reach the bottom-right corner?

**Examples:**
```text
Input: m = 3, n = 7
Output: 28
```

**Approach:**
Use a 2D DP table where dp[i][j] = dp[i-1][j] + dp[i][j-1], or use combinatorics (m+n-2 choose m-1).

**Code:**
```python
`` `python
def uniquePaths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]
`` `
```

## Problem 97: Unique Paths II

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Now consider if some obstacles are added to the grids. How many unique paths are there?

**Examples:**
```text
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
```

**Approach:**
Use DP again, but skip updates where obstacles are found. Start by checking the first row and column carefully.

**Code:**
```python
`` `python
def uniquePathsWithObstacles(grid):
    m, n = len(grid), len(grid[0])
    if grid[0][0] == 1: return 0
    dp = [[0]*n for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                dp[i][j] = 0
            elif i > 0 and j > 0:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            elif i > 0:
                dp[i][j] = dp[i-1][j]
            elif j > 0:
                dp[i][j] = dp[i][j-1]
    return dp[-1][-1]
`` `
```

## Problem 98: Edit Distance

**Category/Pattern:** Dynamic Programming

**Difficulty:** Hard

**Problem:**
Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.

**Examples:**
```text
Input: word1 = "horse", word2 = "ros"
Output: 3
```

**Approach:**
Use a 2D DP table where dp[i][j] represents the edit distance between word1[:i] and word2[:j].

**Code:**
```python
`` `python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0: dp[i][j] = j
            elif j == 0: dp[i][j] = i
            elif word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])
    return dp[m][n]
`` `
```

## Problem 99: Minimum Path Sum

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

**Examples:**
```text
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
```

**Approach:**
Use a DP matrix where dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).

**Code:**
```python
`` `python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    for j in range(1, n):
        grid[0][j] += grid[0][j-1]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]
`` `
```

## Problem 100: Partition Equal Subset Sum

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Given a non-empty array containing only positive integers, determine if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

**Examples:**
```text
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
```

**Approach:**
Use dynamic programming to check if there exists a subset of nums whose sum is equal to total_sum // 2.

**Code:**
```python
`` `python
def canPartition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False
    target = total // 2
    dp = set([0])
    for num in nums:
        dp |= {x + num for x in dp}
    return target in dp
`` `
```

## Problem 101: Decode Ways

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
A message containing letters from A-Z can be encoded to numbers using mapping: 'A' -> 1, ..., 'Z' -> 26. Given a non-empty string, determine the total number of ways to decode it.

**Examples:**
```text
Input: s = "12"
Output: 2
Explanation: "AB" (1 2) or "L" (12).
```

**Approach:**
Use dynamic programming: dp[i] represents the number of ways to decode up to index i. Check one and two-digit combinations at each step.

**Code:**
```python
`` `python
def numDecodings(s):
    if not s or s[0] == '0':
        return 0
    dp = [1, 1]
    for i in range(1, len(s)):
        ways = 0
        if s[i] != '0':
            ways += dp[-1]
        if 10 <= int(s[i-1:i+1]) <= 26:
            ways += dp[-2]
        dp.append(ways)
        dp.pop(0)
    return dp[-1]
`` `
```

## Problem 102: Unique Paths

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
A robot is located at the top-left corner of an m x n grid. It can only move either down or right. Find the number of unique paths to reach the bottom-right corner.

**Examples:**
```text
Input: m = 3, n = 7
Output: 28
```

**Approach:**
Use dynamic programming with a 2D array or optimized 1D array. Each cell stores the sum of paths from the cell above and the cell to the left.

**Code:**
```python
`` `python
def uniquePaths(m, n):
    dp = [1] * n
    for _ in range(m - 1):
        for j in range(1, n):
            dp[j] += dp[j - 1]
    return dp[-1]
`` `
```

## Problem 103: Minimum Path Sum

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Given a m x n grid filled with non-negative numbers, find a path from top-left to bottom-right with the minimum sum of values.

**Examples:**
```text
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: 1 → 3 → 1 → 1 → 1
```

**Approach:**
Use dynamic programming to accumulate the minimum sum for each cell starting from the top-left corner.

**Code:**
```python
`` `python
def minPathSum(grid):
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if i > 0 and j > 0:
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
            elif i > 0:
                grid[i][j] += grid[i-1][j]
            elif j > 0:
                grid[i][j] += grid[i][j-1]
    return grid[-1][-1]
`` `
```

## Problem 104: Coin Change

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
You are given coins of different denominations and a total amount. Compute the fewest number of coins needed to make up that amount.

**Examples:**
```text
Input: coins = [1, 2, 5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
```

**Approach:**
Use bottom-up DP. Initialize an array of amount + 1 length filled with inf. dp[0] = 0. For each coin, update dp[i] = min(dp[i], dp[i - coin] + 1).

**Code:**
```python
`` `python
def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1
`` `
```

## Problem 105: Longest Increasing Subsequence

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Find the length of the longest strictly increasing subsequence of a given array.

**Examples:**
```text
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The LIS is [2,3,7,101]
```

**Approach:**
Use dynamic programming. dp[i] is the LIS ending at index i. Also optimized solution exists using binary search (Patience Sorting).

**Code:**
```python
`` `python
def lengthOfLIS(nums):
    sub = []
    for x in nums:
        i = bisect_left(sub, x)
        if i == len(sub):
            sub.append(x)
        else:
            sub[i] = x
    return len(sub)
`` `
```

## Problem 106: Word Break

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

**Examples:**
```text
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
```

**Approach:**
Use a boolean DP array where dp[i] is True if s[:i] can be segmented. For each i, check if s[j:i] is in wordDict and dp[j] is True.

**Code:**
```python
`` `python
def wordBreak(s, wordDict):
    word_set = set(wordDict)
    dp = [False] * (len(s)+1)
    dp[0] = True
    for i in range(1, len(s)+1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[-1]
`` `
```

## Problem 107: Combination Sum

**Category/Pattern:** Backtracking

**Difficulty:** Medium

**Problem:**
Given an array of distinct integers and a target, return all combinations of numbers where the chosen numbers sum to target. Same number can be reused.

**Examples:**
```text
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
```

**Approach:**
Use backtracking to build combinations. Try each candidate recursively and backtrack if the sum exceeds the target.

**Code:**
```python
`` `python
def combinationSum(candidates, target):
    res = []
    def backtrack(remain, combo, start):
        if remain == 0:
            res.append(list(combo))
            return
        for i in range(start, len(candidates)):
            if candidates[i] <= remain:
                combo.append(candidates[i])
                backtrack(remain - candidates[i], combo, i)
                combo.pop()
    backtrack(target, [], 0)
    return res
`` `
```

## Problem 108: House Robber

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
You are a professional robber planning to rob houses. Each house has some money, but you can't rob adjacent houses. Find the maximum amount of money you can rob.

**Examples:**
```text
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (2) + house 3 (9) + house 5 (1).
```

**Approach:**
Use dynamic programming: dp[i] = max(dp[i-1], dp[i-2] + nums[i])

**Code:**
```python
`` `python
def rob(nums):
    prev = curr = 0
    for num in nums:
        prev, curr = curr, max(curr, prev + num)
    return curr
`` `
```

## Problem 109: House Robber II

**Category/Pattern:** Dynamic Programming

**Difficulty:** Medium

**Problem:**
Same as House Robber, but the houses are arranged in a circle. You can't rob the first and last house together.

**Examples:**
```text
Input: nums = [2,3,2]
Output: 3
```

**Approach:**
Rob either the first to second-last house, or second to last house. Use rob logic on both and return max.

**Code:**
```python
`` `python
def rob(nums):
    if len(nums) == 1:
        return nums[0]
    def rob_line(houses):
        prev = curr = 0
        for h in houses:
            prev, curr = curr, max(curr, prev + h)
        return curr
    return max(rob_line(nums[:-1]), rob_line(nums[1:]))
`` `
```

## Problem 110: Implement Trie (Prefix Tree)

**Category/Pattern:** Trie

**Difficulty:** Medium

**Problem:**
Design a trie with insert, search, and startsWith methods.

**Examples:**
```text
Input: ["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
       [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
Output: [null, null, true, false, true, null, true]
```

**Approach:**
Use a nested dictionary structure or class-based nodes to store characters. Implement insert to build the tree, search to verify full word existence, and startsWith to verify prefix existence.

**Code:**
```python
`` `python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.end = True

    def search(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return cur.end

    def startsWith(self, prefix):
        cur = self.root
        for c in prefix:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return True
`` `
```

## Problem 111: Design Add and Search Words Data Structure

**Category/Pattern:** Trie

**Difficulty:** Medium

**Problem:**
Design a data structure that supports adding new words and searching for a string where '.' can represent any letter.

**Examples:**
```text
Input: ["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
       [[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output: [null,null,null,null,false,true,true,true]
```

**Approach:**
Use a trie structure. For the wildcard character '.', implement recursive DFS during the search.

**Code:**
```python
`` `python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.end = False

class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.end = True

    def search(self, word):
        def dfs(j, node):
            cur = node
            for i in range(j, len(word)):
                c = word[i]
                if c == '.':
                    for child in cur.children.values():
                        if dfs(i + 1, child):
                            return True
                    return False
                else:
                    if c not in cur.children:
                        return False
                    cur = cur.children[c]
            return cur.end

        return dfs(0, self.root)
`` `
```

## Problem 112: Word Search II

**Category/Pattern:** Trie / Backtracking

**Difficulty:** Medium

**Problem:**
Given an m x n board of characters and a list of strings words, return all words on the board.

**Examples:**
```text
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
       words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
```

**Approach:**
Use a trie to store words and DFS from each cell in the board to match against trie paths.

**Code:**
```python
`` `python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None

class Solution:
    def findWords(self, board, words):
        root = TrieNode()
        for word in words:
            node = root
            for letter in word:
                if letter not in node.children:
                    node.children[letter] = TrieNode()
                node = node.children[letter]
            node.word = word

        rows, cols = len(board), len(board[0])
        res = []

        def dfs(r, c, node):
            letter = board[r][c]
            cur_node = node.children.get(letter)
            if not cur_node:
                return

            if cur_node.word:
                res.append(cur_node.word)
                cur_node.word = None

            board[r][c] = "#"
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r+dr, c+dc
                if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] in cur_node.children:
                    dfs(nr, nc, cur_node)
            board[r][c] = letter

        for r in range(rows):
            for c in range(cols):
                if board[r][c] in root.children:
                    dfs(r, c, root)

        return res
`` `
```

## Problem 113: Longest Palindromic Substring

**Category/Pattern:** Dynamic Programming / Expand Around Center

**Difficulty:** Medium

**Problem:**
Given a string `s`, return the longest palindromic substring in `s`.

**Examples:**
```text
Input: s = "babad"
Output: "bab" or "aba"
```

```text
Input: s = "cbbd"
Output: "bb"
```

**Approach:**
Expand around every character (center), and check for the longest palindrome at each center. Keep track of the maximum.

**Code:**
```python
`` `python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ""
        for i in range(len(s)):
            res = max(res, self.expand(s, i, i), self.expand(s, i, i + 1), key=len)
        return res

    def expand(self, s, l, r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1
            r += 1
        return s[l + 1:r]
`` `
```

## Problem 114: Maximum Frequency Stack

**Category/Pattern:** Stack

**Difficulty:** Medium

**Problem:**
Design a stack-like data structure that supports push and pop operations in such a way that the most frequent element is always removed first. If there's a tie, remove the most recent one.

**Examples:**
```text
Input:
push(5), push(7), push(5), push(7), push(4), push(5)
pop() → 5
pop() → 7
pop() → 5
pop() → 4
```

**Approach:**
Use two hash maps: one to count frequencies, and another to group stacks of elements by frequency. Track the maximum frequency seen so far.

**Code:**
```python
`` `python
from collections import defaultdict

class FreqStack:
    def __init__(self):
        self.freq = defaultdict(int)
        self.group = defaultdict(list)
        self.maxfreq = 0

    def push(self, val):
        f = self.freq[val] + 1
        self.freq[val] = f
        self.group[f].append(val)
        self.maxfreq = max(self.maxfreq, f)

    def pop(self):
        val = self.group[self.maxfreq].pop()
        self.freq[val] -= 1
        if not self.group[self.maxfreq]:
            self.maxfreq -= 1
        return val
`` `
```

## Problem 115: Encode and Decode Strings

**Category/Pattern:** Design

**Difficulty:** Medium

**Problem:**
Design an algorithm to encode a list of strings to a single string and decode it back to the original list.

**Examples:**
```text
Input: ['lint','code','love','you']
Encoded: '4#lint4#code4#love3#you'
```

**Approach:**
For each string, store its length followed by a special delimiter. Decode by parsing length and extracting substrings.

**Code:**
```python
`` `python
class Codec:
    def encode(self, strs):
        return ''.join(f"{len(s)}#{s}" for s in strs)

    def decode(self, s):
        res, i = [], 0
        while i < len(s):
            j = s.find('#', i)
            length = int(s[i:j])
            res.append(s[j+1:j+1+length])
            i = j + 1 + length
        return res
`` `
```

## Problem 116: Design Tic-Tac-Toe

**Category/Pattern:** Design

**Difficulty:** Medium

**Problem:**
Design a Tic-Tac-Toe class that can tell if a player has won after each move in O(1) time.

**Examples:**
```text
Input:
move(0, 0, 1), move(0, 2, 2), move(2, 2, 1), move(1, 1, 2), move(2, 0, 1), move(1, 0, 2), move(2, 1, 1)
Output: Player 1 wins
```

**Approach:**
Track rows, columns, diagonals as counters. Add +1 for player 1 and -1 for player 2. Check if any counter reaches n or -n.

**Code:**
```python
`` `python
class TicTacToe:
    def __init__(self, n):
        self.n = n
        self.rows = [0] * n
        self.cols = [0] * n
        self.diag = 0
        self.anti_diag = 0

    def move(self, row, col, player):
        mark = 1 if player == 1 else -1
        self.rows[row] += mark
        self.cols[col] += mark
        if row == col:
            self.diag += mark
        if row + col == self.n - 1:
            self.anti_diag += mark
        if any(abs(x) == self.n for x in (self.rows[row], self.cols[col], self.diag, self.anti_diag)):
            return player
        return 0
`` `
```

## Problem 117: Find Median from Data Stream

**Category/Pattern:** Heap / Priority Queue

**Difficulty:** Medium

**Problem:**
Design a class that supports adding numbers and finding the median of the current data stream.

**Examples:**
```text
addNum(1), addNum(2), findMedian() → 1.5, addNum(3), findMedian() → 2
```

**Approach:**
Use a max heap for the smaller half and min heap for the larger half. Keep sizes balanced.

**Code:**
```python
`` `python
import heapq

class MedianFinder:
    def __init__(self):
        self.small = []  # Max heap (inverted)
        self.large = []  # Min heap

    def addNum(self, num):
        heapq.heappush(self.small, -num)
        heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.small) < len(self.large):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    def findMedian(self):
        if len(self.small) > len(self.large):
            return -self.small[0]
        return (-self.small[0] + self.large[0]) / 2
`` `
```

## Problem 118: LFU Cache

**Category/Pattern:** Design

**Difficulty:** Medium

**Problem:**
Design and implement a data structure for LFU (Least Frequently Used) cache with get and put operations in O(1) time.

**Examples:**
```text
LFUCache(2)
put(1, 1), put(2, 2), get(1) → 1, put(3, 3) → evicts key 2, get(2) → -1
```

**Approach:**
Use a combination of frequency counter and double linked list per frequency level. Track min frequency.

**Code:**
```python
`` `python
from collections import defaultdict, OrderedDict

class LFUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.key_to_val = {}
        self.key_to_freq = {}
        self.freq_to_keys = defaultdict(OrderedDict)
        self.min_freq = 0

    def get(self, key):
        if key not in self.key_to_val:
            return -1
        self._update_freq(key)
        return self.key_to_val[key]

    def put(self, key, value):
        if self.capacity == 0:
            return
        if key in self.key_to_val:
            self.key_to_val[key] = value
            self._update_freq(key)
            return
        if len(self.key_to_val) == self.capacity:
            k, _ = self.freq_to_keys[self.min_freq].popitem(last=False)
            del self.key_to_val[k]
            del self.key_to_freq[k]
        self.key_to_val[key] = value
        self.key_to_freq[key] = 1
        self.freq_to_keys[1][key] = None
        self.min_freq = 1

    def _update_freq(self, key):
        freq = self.key_to_freq[key]
        del self.freq_to_keys[freq][key]
        if not self.freq_to_keys[freq]:
            del self.freq_to_keys[freq]
            if self.min_freq == freq:
                self.min_freq += 1
        self.key_to_freq[key] += 1
        self.freq_to_keys[freq+1][key] = None
`` `
```

## Problem 119: Minimum Cost to Connect All Points

**Category/Pattern:** Graphs / Minimum Spanning Tree

**Difficulty:** Medium

**Problem:**
You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`. Return the minimum cost to make all points connected. The cost is the sum of the weights of the edges in a minimum spanning tree (MST) using Manhattan distance.

**Examples:**
```text
Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
```

```text
Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
```

**Approach:**
This is a classic Minimum Spanning Tree problem. Use Prim's algorithm to grow the MST one node at a time, always choosing the closest unvisited node using a priority queue.

**Code:**
```python
import heapq

def minCostConnectPoints(points):
    n = len(points)
    visited = set()
    minHeap = [(0, 0)]  # (cost, point index)
    total = 0

    while len(visited) < n:
        cost, i = heapq.heappop(minHeap)
        if i in visited:
            continue
        visited.add(i)
        total += cost
        for j in range(n):
            if j not in visited:
                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
                heapq.heappush(minHeap, (dist, j))
    
    return total
```

## Problem 120: Number of Distinct Islands II

**Category/Pattern:** DFS / Hashing

**Difficulty:** Medium

**Problem:**
Given a 2D grid, count the number of distinct islands, considering rotations and reflections as the same.

**Examples:**
```text
Input: [[1,1,0,0],[1,0,0,0],[0,0,0,1],[0,0,1,1]] → Output: 1
```

**Approach:**
Use DFS to find all island shapes. Normalize all transformations (rotations/reflections) and store the canonical form in a set.

**Code:**
```python
`` `python
class Solution:
def numDistinctIslands2(self, grid):
shapes = set()
def dfs(x, y, pos):
grid[x][y] = 0
pos.append((x, y))
for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
nx, ny = x+dx, y+dy
if 0<=nx<len(grid) and 0<=ny<len(grid[0]) and grid[nx][ny]:
dfs(nx, ny, pos)


def normalize(shape):
transforms = [[] for _ in range(8)]
for x, y in shape:
transforms[0].append(( x, y))
transforms[1].append(( x, -y))
transforms[2].append((-x, y))
transforms[3].append((-x, -y))
transforms[4].append(( y, x))
transforms[5].append(( y, -x))
transforms[6].append((-y, x))
transforms[7].append((-y, -x))
norm = []
for t in transforms:
t.sort()
ox, oy = t[0]
norm.append(tuple((x - ox, y - oy) for x, y in t))
return min(norm)


for i in range(len(grid)):
for j in range(len(grid[0])):
if grid[i][j]:
pos = []
dfs(i, j, pos)
shapes.add(normalize(pos))
return len(shapes)
`` `
```

## Problem 121: Making A Large Island

**Category/Pattern:** DFS / Union Find

**Difficulty:** Medium

**Problem:**
Given a binary grid, you can change at most one 0 to 1. Return the size of the largest island possible.

**Examples:**
```text
Input: [[1,0],[0,1]] → Output: 3
```

**Approach:**
Label islands with IDs and calculate their areas. For each 0, sum neighboring unique island areas.

**Code:**
```python
`` `python
class Solution:
def largestIsland(self, grid):
n = len(grid)
island_id = 2
areas = {}


def dfs(i, j, id):
if i < 0 or i >= n or j < 0 or j >= n or grid[i][j] != 1:
return 0
grid[i][j] = id
return 1 + sum(dfs(i + dx, j + dy, id) for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)])


for i in range(n):
for j in range(n):
if grid[i][j] == 1:
areas[island_id] = dfs(i, j, island_id)
island_id += 1


res = max(areas.values() or [0])


for i in range(n):
for j in range(n):
if grid[i][j] == 0:
seen = set()
for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
ni, nj = i+dx, j+dy
if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] > 1:
seen.add(grid[ni][nj])
res = max(res, 1 + sum(areas[k] for k in seen))
return res
`` `
```

## Problem 122: Evaluate Reverse Polish Notation

**Category/Pattern:** Stack

**Difficulty:** Medium

**Problem:**
Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression.

**Examples:**
```text
Input: tokens = ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```

```text
Input: tokens = ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
```

**Approach:**
Use a stack to store operands. When an operator is encountered, pop the top two elements, apply the operator, and push the result back.

**Code:**
```python
`` `python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token not in "+-*/":
                stack.append(int(token))
            else:
                b = stack.pop()
                a = stack.pop()
                if token == "+":
                    stack.append(a + b)
                elif token == "-":
                    stack.append(a - b)
                elif token == "*":
                    stack.append(a * b)
                else:
                    stack.append(int(a / b))
        return stack[0]
`` `
```

## Problem 123: Generate Parentheses

**Category/Pattern:** Backtracking

**Difficulty:** Medium

**Problem:**
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

**Examples:**
```text
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
```

**Approach:**
Use backtracking to build the string. Track open and close parentheses count and only add when valid.

**Code:**
```python
`` `python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def backtrack(s, open_count, close_count):
            if len(s) == 2 * n:
                res.append(s)
                return
            if open_count < n:
                backtrack(s + "(", open_count + 1, close_count)
            if close_count < open_count:
                backtrack(s + ")", open_count, close_count + 1)
        backtrack("", 0, 0)
        return res
`` `
```

## Problem 124: Daily Temperatures

**Category/Pattern:** Monotonic Stack

**Difficulty:** Medium

**Problem:**
Given a list of daily temperatures, return a list such that, for each day, tells you how many days you would have to wait until a warmer temperature.

**Examples:**
```text
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
```

**Approach:**
Use a stack to keep track of indices. Compare current temperature with the last seen to calculate the waiting days.

**Code:**
```python
`` `python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        res = [0] * len(temperatures)
        stack = []
        for i, t in enumerate(temperatures):
            while stack and temperatures[stack[-1]] < t:
                idx = stack.pop()
                res[idx] = i - idx
            stack.append(i)
        return res
`` `
```

## Problem 125: Car Fleet

**Category/Pattern:** Monotonic Stack / Greedy

**Difficulty:** Medium

**Problem:**
There are n cars going to the same destination. A car fleet is some non-empty set of cars that travel at the same speed. Find how many fleets will arrive at the destination.

**Examples:**
```text
Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
```

**Approach:**
Sort cars by position. Use a stack to track times to destination and count how many times times increase.

**Code:**
```python
`` `python
class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = sorted(zip(position, speed), reverse=True)
        stack = []
        for p, s in pair:
            time = (target - p) / s
            if not stack or time > stack[-1]:
                stack.append(time)
        return len(stack)
`` `
```

## Problem 126: Largest Rectangle in Histogram

**Category/Pattern:** Monotonic Stack

**Difficulty:** Hard

**Problem:**
Given an array of integers heights representing the histogram’s bar height, return the area of the largest rectangle.

**Examples:**
```text
Input: heights = [2,1,5,6,2,3]
Output: 10
```

**Approach:**
Use a monotonic increasing stack to track previous bars. Calculate area using width and height when popping.

**Code:**
```python
`` `python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        max_area = 0
        heights.append(0)
        for i, h in enumerate(heights):
            while stack and heights[stack[-1]] > h:
                height = heights[stack.pop()]
                width = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, height * width)
            stack.append(i)
        return max_area
`` `
```

## Problem 127: Asteroid Collision

**Category/Pattern:** Stack

**Difficulty:** Medium

**Problem:**
Given an array of integers representing asteroids in a row, return the state of the asteroids after all collisions.

**Examples:**
```text
Input: asteroids = [5,10,-5]
Output: [5,10]
```

```text
Input: asteroids = [8,-8]
Output: []
```

**Approach:**
Use a stack to simulate collisions. Compare directions and sizes. Pop or append based on the rules.

**Code:**
```python
`` `python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for a in asteroids:
            while stack and a < 0 < stack[-1]:
                if stack[-1] < -a:
                    stack.pop()
                    continue
                elif stack[-1] == -a:
                    stack.pop()
                break
            else:
                stack.append(a)
        return stack
`` `
```

## Problem 128: Minimum Remove to Make Valid Parentheses

**Category/Pattern:** Stack

**Difficulty:** Medium

**Problem:**
Given a string s of '(' , ')' and lowercase English characters. Remove the minimum number of parentheses to make the input string valid.

**Examples:**
```text
Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
```

**Approach:**
Use a stack to track unmatched parentheses. Remove those indices after first pass.

**Code:**
```python
`` `python
class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        s = list(s)
        stack = []
        for i, c in enumerate(s):
            if c == '(':
                stack.append(i)
            elif c == ')':
                if stack:
                    stack.pop()
                else:
                    s[i] = ''
        for i in stack:
            s[i] = ''
        return ''.join(s)
`` `
```

## Problem 129: Merge Intervals

**Category/Pattern:** Intervals / Sorting

**Difficulty:** Medium

**Problem:**
Given an array of intervals, merge all overlapping intervals.

**Examples:**
```text
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
```

**Approach:**
Sort intervals. Then iterate and merge if overlapping, else add to result.

**Code:**
```python
`` `python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        res = [intervals[0]]
        for start, end in intervals[1:]:
            if start <= res[-1][1]:
                res[-1][1] = max(res[-1][1], end)
            else:
                res.append([start, end])
        return res
`` `
```

## Problem 130: Insert Interval

**Category/Pattern:** Intervals / Sorting

**Difficulty:** Medium

**Problem:**
Given a set of non-overlapping intervals, insert a new interval into the intervals and merge if necessary.

**Examples:**
```text
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Approach:**
Iterate through intervals and find where newInterval fits. Merge overlapping intervals during iteration.

**Code:**
```python
`` `python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []
        for i in range(len(intervals)):
            if newInterval[1] < intervals[i][0]:
                res.append(newInterval)
                return res + intervals[i:]
            elif newInterval[0] > intervals[i][1]:
                res.append(intervals[i])
            else:
                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]
        res.append(newInterval)
        return res
`` `
```

## Problem 131: Non-overlapping Intervals

**Category/Pattern:** Greedy / Sorting

**Difficulty:** Medium

**Problem:**
Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

**Examples:**
```text
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
```

**Approach:**
Sort intervals by end time. Greedily keep the one that ends earliest and remove overlapping ones.

**Code:**
```python
`` `python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        end = float('-inf')
        count = 0
        for start, finish in intervals:
            if start >= end:
                end = finish
            else:
                count += 1
        return count
`` `
```

## Problem 132: Reverse Linked List

**Category/Pattern:** Linked List

**Difficulty:** Easy

**Problem:**
Reverse a singly linked list.

**Examples:**
```text
Input: head = [1,2,3,4,5]
```

```text
Output: [5,4,3,2,1]
```

**Approach:**
Iteratively rewire each node's next pointer to point to the previous node while moving through the list.

**Code:**
```python
`` `python
class Solution:
    def reverseList(self, head):
        prev = None
        while head:
            nxt = head.next
            head.next = prev
            prev = head
            head = nxt
        return prev
`` `
```

## Problem 133: Merge Two Sorted Lists

**Category/Pattern:** Linked List

**Difficulty:** Easy

**Problem:**
Merge two sorted linked lists and return it as a new sorted list.

**Examples:**
```text
Input: list1 = [1,2,4], list2 = [1,3,4]
```

```text
Output: [1,1,2,3,4,4]
```

**Approach:**
Use two pointers to traverse both lists, comparing node values and appending the smaller one to the new list.

**Code:**
```python
`` `python
class Solution:
    def mergeTwoLists(self, l1, l2):
        dummy = ListNode()
        tail = dummy
        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next
`` `
```

## Problem 134: Linked List Cycle

**Category/Pattern:** Linked List

**Difficulty:** Easy

**Problem:**
Given a linked list, determine if it has a cycle.

**Examples:**
```text
Input: head = [3,2,0,-4] with a cycle at pos = 1
```

```text
Output: true
```

**Approach:**
Use Floyd's Tortoise and Hare algorithm to detect cycles using two pointers.

**Code:**
```python
`` `python
class Solution:
    def hasCycle(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
`` `
```

## Problem 135: LRU Cache

**Category/Pattern:** Design

**Difficulty:** Medium

**Problem:**
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

**Examples:**
```text
Input: ["LRUCache","put","put","get","put","get","put","get","get","get"]
[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
```

```text
Output: [null,null,null,1,null,-1,null,-1,3,4]
```

**Approach:**
Use an OrderedDict to store the cache keys and values with order-preservation to track usage.

**Code:**
```python
`` `python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
`` `
```

## Problem 136: Merge k Sorted Lists

**Category/Pattern:** Linked List / Heap

**Difficulty:** Hard

**Problem:**
Merge k sorted linked lists and return it as one sorted list.

**Examples:**
```text
Input: lists = [[1,4,5],[1,3,4],[2,6]]
```

```text
Output: [1,1,2,3,4,4,5,6]
```

**Approach:**
Use a min heap to keep track of the smallest elements from each list.

**Code:**
```python
`` `python
import heapq

class Solution:
    def mergeKLists(self, lists):
        heap = []
        for i, node in enumerate(lists):
            if node:
                heapq.heappush(heap, (node.val, i, node))
        dummy = ListNode()
        curr = dummy
        while heap:
            val, i, node = heapq.heappop(heap)
            curr.next = node
            curr = curr.next
            if node.next:
                heapq.heappush(heap, (node.next.val, i, node.next))
        return dummy.next
`` `
```

## Problem 137: Add Two Numbers

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Add two numbers represented by linked lists where each node contains a single digit.

**Examples:**
```text
Input: l1 = [2,4,3], l2 = [5,6,4]
```

```text
Output: [7,0,8]
```

**Approach:**
Traverse both lists, adding digits with carry and building the result as a new linked list.

**Code:**
```python
`` `python
class Solution:
    def addTwoNumbers(self, l1, l2):
        dummy = ListNode()
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
`` `
```

## Problem 138: Copy List with Random Pointer

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
A linked list is given such that each node contains an additional random pointer. Return a deep copy of the list.

**Examples:**
```text
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
```

```text
Output: Deep copied linked list
```

**Approach:**
Use a hash map to create node copies and track original-to-copy references.

**Code:**
```python
`` `python
class Solution:
    def copyRandomList(self, head):
        if not head:
            return None
        old_to_new = {}
        curr = head
        while curr:
            old_to_new[curr] = Node(curr.val)
            curr = curr.next
        curr = head
        while curr:
            old_to_new[curr].next = old_to_new.get(curr.next)
            old_to_new[curr].random = old_to_new.get(curr.random)
            curr = curr.next
        return old_to_new[head]
`` `
```

## Problem 139: Reorder List

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Given a singly linked list, reorder it such that the nodes are rearranged from the ends toward the center.

**Examples:**
```text
Input: [1,2,3,4]
```

```text
Output: [1,4,2,3]
```

**Approach:**
Find the middle, reverse the second half, then merge two halves together.

**Code:**
```python
`` `python
class Solution:
    def reorderList(self, head):
        if not head:
            return
        # Find middle
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        # Reverse second half
        prev, curr = None, slow
        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt
        # Merge two halves
        first, second = head, prev
        while second.next:
            tmp1 = first.next
            tmp2 = second.next
            first.next = second
            second.next = tmp1
            first = tmp1
            second = tmp2
`` `
```

## Problem 140: Remove Nth Node From End of List

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Remove the nth node from the end of a linked list and return its head.

**Examples:**
```text
Input: head = [1,2,3,4,5], n = 2
```

```text
Output: [1,2,3,5]
```

**Approach:**
Use a dummy node and two-pointer technique to reach the node to remove.

**Code:**
```python
`` `python
class Solution:
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(0, head)
        left = right = dummy
        for _ in range(n):
            right = right.next
        while right.next:
            left = left.next
            right = right.next
        left.next = left.next.next
        return dummy.next
`` `
```

## Problem 141: Palindrome Linked List

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Check if a singly linked list is a palindrome.

**Examples:**
```text
Input: head = [1,2,2,1]
```

```text
Output: true
```

**Approach:**
Find the middle, reverse the second half, and compare both halves for equality.

**Code:**
```python
`` `python
class Solution:
    def isPalindrome(self, head):
        fast = slow = head
        # Find middle
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        # Reverse second half
        prev = None
        while slow:
            nxt = slow.next
            slow.next = prev
            prev = slow
            slow = nxt
        # Check palindrome
        left, right = head, prev
        while right:
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        return True
`` `
```

## Problem 142: Intersection of Two Linked Lists

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Find the node at which two singly linked lists intersect.

**Examples:**
```text
Input: Intersect at node with value = 8
```

```text
Output: Reference to the intersecting node
```

**Approach:**
Use two pointers switching heads when reaching the end to equalize path lengths.

**Code:**
```python
`` `python
class Solution:
    def getIntersectionNode(self, headA, headB):
        if not headA or not headB:
            return None
        a, b = headA, headB
        while a != b:
            a = a.next if a else headB
            b = b.next if b else headA
        return a
`` `
```

## Problem 143: Linked List Cycle II

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Find the node where the cycle begins in a linked list.

**Examples:**
```text
Input: List with cycle at node 2
```

```text
Output: Reference to node 2
```

**Approach:**
Use Floyd's Cycle Detection to find the start of the loop.

**Code:**
```python
`` `python
class Solution:
    def detectCycle(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return None
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
`` `
```

## Problem 144: Remove Linked List Elements

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Remove all elements from a linked list of integers that have value val.

**Examples:**
```text
Input: head = [1,2,6,3,4,5,6], val = 6
```

```text
Output: [1,2,3,4,5]
```

**Approach:**
Use a dummy node and skip nodes with the given value.

**Code:**
```python
`` `python
class Solution:
    def removeElements(self, head, val):
        dummy = ListNode(0)
        dummy.next = head
        curr = dummy
        while curr.next:
            if curr.next.val == val:
                curr.next = curr.next.next
            else:
                curr = curr.next
        return dummy.next
`` `
```

## Problem 145: Odd Even Linked List

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Group all odd-indexed nodes together followed by the even-indexed nodes.

**Examples:**
```text
Input: head = [1,2,3,4,5]
```

```text
Output: [1,3,5,2,4]
```

**Approach:**
Separate odd and even nodes and reconnect them.

**Code:**
```python
`` `python
class Solution:
    def oddEvenList(self, head):
        if not head:
            return None
        odd = head
        even = head.next
        even_head = even
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = even_head
        return head
`` `
```

## Problem 146: Add Two Numbers II

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Add two numbers represented by linked lists in forward order.

**Examples:**
```text
Input: l1 = [7,2,4,3], l2 = [5,6,4]
```

```text
Output: [7,8,0,7]
```

**Approach:**
Push all values to stacks and simulate addition with carry.

**Code:**
```python
`` `python
class Solution:
    def addTwoNumbers(self, l1, l2):
        stack1, stack2 = [], []
        while l1:
            stack1.append(l1.val)
            l1 = l1.next
        while l2:
            stack2.append(l2.val)
            l2 = l2.next
        carry = 0
        head = None
        while stack1 or stack2 or carry:
            val = carry
            if stack1:
                val += stack1.pop()
            if stack2:
                val += stack2.pop()
            carry = val // 10
            node = ListNode(val % 10)
            node.next = head
            head = node
        return head
`` `
```

## Problem 147: Flatten a Multilevel Doubly Linked List

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Flatten a multilevel doubly linked list into a single-level doubly linked list.

**Examples:**
```text
Input: [1,2,3,4,5,6,null,null,null,7,8,null,null,9,10]
```

```text
Output: [1,2,3,7,8,9,10,4,5,6]
```

**Approach:**
Use DFS to flatten children into the main list recursively.

**Code:**
```python
`` `python
class Solution:
    def flatten(self, head):
        if not head:
            return head

        def dfs(node):
            curr = node
            last = node
            while curr:
                nxt = curr.next
                if curr.child:
                    child_last = dfs(curr.child)
                    curr.next = curr.child
                    curr.child.prev = curr
                    curr.child = None
                    child_last.next = nxt
                    if nxt:
                        nxt.prev = child_last
                    last = child_last
                else:
                    last = curr
                curr = nxt
            return last

        dfs(head)
        return head
`` `
```

## Problem 148: Sort List

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Sort a linked list in O(n log n) time and constant space complexity.

**Examples:**
```text
Input: head = [4,2,1,3]
```

```text
Output: [1,2,3,4]
```

**Approach:**
Use merge sort: find middle, recursively sort, and merge.

**Code:**
```python
`` `python
class Solution:
    def sortList(self, head):
        if not head or not head.next:
            return head
        # Find the middle
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow.next
        slow.next = None
        # Sort each half
        left = self.sortList(head)
        right = self.sortList(mid)
        # Merge
        return self.merge(left, right)

    def merge(self, l1, l2):
        dummy = ListNode()
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
`` `
```

## Problem 149: Rotate List

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Rotate the list to the right by k places.

**Examples:**
```text
Input: head = [1,2,3,4,5], k = 2
```

```text
Output: [4,5,1,2,3]
```

**Approach:**
Find the length, link tail to head to form a loop, then break after k shifts.

**Code:**
```python
`` `python
class Solution:
    def rotateRight(self, head, k):
        if not head or not head.next:
            return head
        # Find the length and tail
        length, tail = 1, head
        while tail.next:
            tail = tail.next
            length += 1
        k %= length
        if k == 0:
            return head
        # Make it circular
        tail.next = head
        # Find new tail
        for _ in range(length - k):
            tail = tail.next
        new_head = tail.next
        tail.next = None
        return new_head
`` `
```

## Problem 150: Remove Duplicates from Sorted List II

**Category/Pattern:** Linked List

**Difficulty:** Medium

**Problem:**
Remove all nodes that have duplicate numbers, leaving only distinct numbers.

**Examples:**
```text
Input: head = [1,2,3,3,4,4,5]
```

```text
Output: [1,2,5]
```

**Approach:**
Use dummy head and skip duplicate values during traversal.

**Code:**
```python
`` `python
class Solution:
    def deleteDuplicates(self, head):
        dummy = ListNode(0, head)
        prev = dummy
        while head:
            if head.next and head.val == head.next.val:
                while head.next and head.val == head.next.val:
                    head = head.next
                prev.next = head.next
            else:
                prev = prev.next
            head = head.next
        return dummy.next
`` `
```

## SQL Problem 1: Recyclable and Low Fat Products

**Category/Pattern:** Basic SQL | WHERE clause

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the ids of products that are both low fat and recyclable.

**Examples:**
```text
Input:
Products table:
| product_id | low_fats | recyclable |
|------------|----------|------------|
| 0          | Y        | N          |
| 1          | Y        | Y          |
| 2          | N        | Y          |
| 3          | Y        | Y          |
| 4          | N        | N          |

Output:
| product_id |
|------------|
| 1          |
| 3          |
```

**Approach:**
Use a WHERE clause with conditions for both `low_fats = 'Y'` and `recyclable = 'Y'`.

**Code:**
```python
`` `sql
SELECT product_id
FROM Products
WHERE low_fats = 'Y' AND recyclable = 'Y';
`` `
```

## SQL Problem 2: Find Customer Referee

**Category/Pattern:** Self Join | WHERE clause

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the names of the customers who are not referred by the customer with id = 2.

**Examples:**
```text
Input:
Customer table:
| id | name   | referee_id |
|----|--------|------------|
| 1  | Will   | null       |
| 2  | Jane   | null       |
| 3  | Alex   | 2          |
| 4  | Bill   | null       |
| 5  | Zack   | 1          |
| 6  | Mark   | 2          |

Output:
| name  |
|--------|
| Will  |
| Jane  |
| Bill  |
| Zack  |
```

**Approach:**
Use a WHERE clause to filter out customers with `referee_id = 2`.

**Code:**
```python
`` `sql
SELECT name
FROM Customer
WHERE referee_id IS NULL OR referee_id != 2;
`` `
```

## SQL Problem 3: Big Countries

**Category/Pattern:** Basic SQL | WHERE clause

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the name, population, and area of the big countries. A country is big if it has an area of at least 3 million or a population of at least 25 million.

**Examples:**
```text
Input:
World table:
| name      | continent | area  | population | gdp  |
|-----------|-----------|-------|------------|------|
| Afghanistan | Asia   | 652230 | 25500100    | 20343000 |
| Albania   | Europe    | 28748 | 2831741     | 12960000 |
| Algeria   | Africa    | 2381741 | 37100000   | 188681000 |

Output:
| name        | population | area    |
|-------------|------------|---------|
| Afghanistan | 25500100   | 652230  |
| Algeria     | 37100000   | 2381741 |
```

**Approach:**
Use a WHERE clause to filter based on area or population.

**Code:**
```python
`` `sql
SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;
`` `
```

## SQL Problem 4: Article Views I

**Category/Pattern:** Basic SQL | Filtering

**Difficulty:** Easy

**Problem:**
Write a SQL query to find all the authors that viewed their own articles. Return their distinct ID.

**Examples:**
```text
Input:
Views table:
| article_id | author_id | viewer_id | view_date |
|------------|-----------|-----------|-----------|
| 1          | 3         | 5         | 2019-08-01|
| 1          | 3         | 6         | 2019-08-02|
| 2          | 7         | 7         | 2019-08-01|

Output:
| id |
|----|
| 7  |
```

**Approach:**
Filter rows where `author_id = viewer_id`, and select distinct IDs.

**Code:**
```python
`` `sql
SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id;
`` `
```

## SQL Problem 5: Invalid Tweets

**Category/Pattern:** String Functions | LENGTH

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the IDs of tweets that are invalid. A tweet is invalid if it has more than 15 characters.

**Examples:**
```text
Input:
Tweets table:
| tweet_id | content          |
|----------|------------------|
| 1        | Vote for Biden   |
| 2        | Let us make America great again! |

Output:
| tweet_id |
|----------|
| 2        |
```

**Approach:**
Use LENGTH() function to filter content > 15 characters.

**Code:**
```python
`` `sql
SELECT tweet_id
FROM Tweets
WHERE LENGTH(content) > 15;
`` `
```

## SQL Problem 6: Basic Joins

**Category/Pattern:** JOINs | Employee ID Mapping

**Difficulty:** Medium

**Problem:**
Write a SQL query to show each employee's name with their corresponding unique identifier.

**Examples:**
```text
Input:
Employees table:
| id | name  |
|----|--------|
| 1  | Alice |
| 7  | Bob   |

EmployeeUNI table:
| id | unique_id |
|----|-----------|
| 1  | 101       |

Output:
| unique_id | name  |
|-----------|--------|
| 101       | Alice |
| null      | Bob   |
```

**Approach:**
Use LEFT JOIN to combine Employees and EmployeeUNI on id.

**Code:**
```python
`` `sql
SELECT eu.unique_id, e.name
FROM Employees e
LEFT JOIN EmployeeUNI eu
ON e.id = eu.id;
`` `
```

## SQL Problem 7: Product Sales Analysis I

**Category/Pattern:** JOIN | Aggregation

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the product name, year, and price of each product sold.

**Examples:**
```text
Input:
Sales table:
| sale_id | product_id | year | quantity | price |
|---------|------------|------|----------|-------|
| 1       | 100        | 2008 | 10       | 5000  |

Product table:
| product_id | product_name |
|------------|--------------|
| 100        | Nokia        |

Output:
| product_name | year | price |
|--------------|------|-------|
| Nokia        | 2008 | 5000  |
```

**Approach:**
JOIN Sales with Product table on product_id and select required fields.

**Code:**
```python
`` `sql
SELECT p.product_name, s.year, s.price
FROM Sales s
JOIN Product p
ON s.product_id = p.product_id;
`` `
```

## SQL Problem 8: Customer Who Visited but Did Not Make Any Transactions

**Category/Pattern:** Anti Join | LEFT JOIN + NULL

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the IDs of the users who visited but did not make any transactions.

**Examples:**
```text
Input:
Visits table:
| visit_id | customer_id |
|----------|-------------|
| 1        | 23          |
| 2        | 9           |

Transactions table:
| transaction_id | visit_id |
|----------------|----------|
| 2              | 5        |

Output:
| customer_id |
|--------------|
| 23           |
| 9            |
```

**Approach:**
LEFT JOIN Visits and Transactions on visit_id and filter where transaction_id IS NULL.

**Code:**
```python
`` `sql
SELECT v.customer_id
FROM Visits v
LEFT JOIN Transactions t
ON v.visit_id = t.visit_id
WHERE t.transaction_id IS NULL;
`` `
```

## SQL Problem 9: Rising Temperature

**Category/Pattern:** Self Join | Date Comparison

**Difficulty:** Easy

**Problem:**
Write a SQL query to find all dates' Ids with higher temperatures compared to the previous day.

**Examples:**
```text
Input:
Weather table:
| id | recordDate | temperature |
|----|-------------|-------------|
| 1  | 2015-01-01  | 10          |
| 2  | 2015-01-02  | 25          |
| 3  | 2015-01-03  | 20          |
| 4  | 2015-01-04  | 30          |

Output:
| id |
|----|
| 2  |
| 4  |
```

**Approach:**
Self-join Weather table to compare temperature with the previous day's record.

**Code:**
```python
`` `sql
SELECT w1.id
FROM Weather w1
JOIN Weather w2
ON DATEDIFF(w1.recordDate, w2.recordDate) = 1
WHERE w1.temperature > w2.temperature;
`` `
```

## SQL Problem 10: Average Time of Process per Machine

**Category/Pattern:** Window Function | Grouping

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the average time each machine takes to complete a process (end_time - start_time).

**Examples:**
```text
Input:
Activity table:
| machine_id | process_id | activity_type | timestamp |
|------------|------------|---------------|-----------|
| 0          | 0          | start         | 0         |
| 0          | 0          | end           | 3         |

Output:
| machine_id | processing_time |
|------------|------------------|
| 0          | 3.00             |
```

**Approach:**
Group by machine_id and process_id, compute time difference using conditional aggregation, then average.

**Code:**
```python
`` `sql
SELECT machine_id,
       ROUND(AVG(CASE WHEN activity_type = 'end' THEN timestamp END -
                  CASE WHEN activity_type = 'start' THEN timestamp END), 2) AS processing_time
FROM Activity
GROUP BY machine_id, process_id;
`` `
```

## SQL Problem 11: Employee Bonus

**Category/Pattern:** LEFT JOIN | NULL handling

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the names of all employees who received a bonus.

**Examples:**
```text
Input:
Employee table:
| empId | name  | supervisor | salary |
|-------|-------|------------|--------|
| 3     | Brad  | null       | 4000   |
| 1     | John  | 3          | 1000   |
| 2     | Dan   | 3          | 2000   |
| 4     | Thomas| 3          | 4000   |

Bonus table:
| empId | bonus |
|-------|-------|
| 2     | 500   |
| 4     | null  |

Output:
| name  | bonus |
|-------|-------|
| Dan   | 500   |
```

**Approach:**
LEFT JOIN the Employee table with the Bonus table and filter for non-null bonus values.

**Code:**
```python
`` `sql
SELECT name, bonus
FROM Employee e
JOIN Bonus b ON e.empId = b.empId
WHERE bonus IS NOT NULL;
`` `
```

## SQL Problem 12: Students and Examinations

**Category/Pattern:** JOIN | COUNT

**Difficulty:** Easy

**Problem:**
Write a SQL query to report the number of times each student attended each exam.

**Examples:**
```text
Input:
Students table:
| student_id | student_name |
|------------|--------------|
| 1          | Alice        |
| 2          | Bob          |

Subjects table:
| subject_name |
|--------------|
| Math         |
| Physics      |

Examinations table:
| student_id | subject_name |
|------------|--------------|
| 1          | Math         |
| 1          | Math         |
| 2          | Math         |

Output:
| student_id | student_name | subject_name | attended_exams |
|------------|--------------|--------------|----------------|
| 1          | Alice        | Math         | 2              |
| 1          | Alice        | Physics      | 0              |
| 2          | Bob          | Math         | 1              |
| 2          | Bob          | Physics      | 0              |
```

**Approach:**
Cross JOIN Students and Subjects, then LEFT JOIN with Examinations and COUNT.

**Code:**
```python
`` `sql
SELECT s.student_id, s.student_name, sub.subject_name,
       COUNT(e.subject_name) AS attended_exams
FROM Students s
CROSS JOIN Subjects sub
LEFT JOIN Examinations e
  ON s.student_id = e.student_id AND sub.subject_name = e.subject_name
GROUP BY s.student_id, s.student_name, sub.subject_name;
`` `
```

## SQL Problem 13: Managers with at Least 5 Direct Reports

**Category/Pattern:** GROUP BY | HAVING

**Difficulty:** Medium

**Problem:**
Write a SQL query to find the managers with at least five direct reports.

**Examples:**
```text
Input:
Employee table:
| id | name | department | managerId |
|----|------|------------|-----------|
| 1  | John | A          | null      |
| 2  | Dan  | A          | 1         |
| 3  | James| A          | 1         |
| 4  | Amy  | A          | 1         |
| 5  | Anne | A          | 1         |
| 6  | Ron  | A          | 1         |

Output:
| name |
|------|
| John |
```

**Approach:**
Group by managerId and filter groups with COUNT(*) >= 5. Join back to get names.

**Code:**
```python
`` `sql
SELECT name
FROM Employee
WHERE id IN (
    SELECT managerId
    FROM Employee
    WHERE managerId IS NOT NULL
    GROUP BY managerId
    HAVING COUNT(*) >= 5
);
`` `
```

## SQL Problem 14: Confirmation Rate

**Category/Pattern:** JOIN | Aggregation | Division

**Difficulty:** Medium

**Problem:**
Write a SQL query to find confirmation rate per user: confirmed / total requests made.

**Examples:**
```text
Input:
Signups table:
| user_id | time_stamp |
|---------|------------|
| 3       | 2020-03-21 |

Confirmations table:
| user_id | time_stamp | action     |
|---------|------------|------------|
| 3       | 2021-01-06 | confirmed  |

Output:
| user_id | confirmation_rate |
|---------|-------------------|
| 3       | 1.00              |
```

**Approach:**
Use conditional aggregation to count confirmations and divide by total confirmations.

**Code:**
```python
`` `sql
SELECT s.user_id,
       ROUND(SUM(c.action = 'confirmed') / COUNT(c.action), 2) AS confirmation_rate
FROM Signups s
LEFT JOIN Confirmations c ON s.user_id = c.user_id
GROUP BY s.user_id;
`` `
```

## SQL Problem 15: Basic Aggregate Functions

**Category/Pattern:** COUNT | AVG | MAX | MIN

**Difficulty:** Medium

**Problem:**
Write a SQL query to return aggregate stats on salaries: average, max, min, and total count.

**Examples:**
```text
Input:
Salaries table:
| emp_id | salary |
|--------|--------|
| 1      | 5000   |
| 2      | 6000   |

Output:
| avg_salary | max_salary | min_salary | total_employees |
|------------|------------|------------|------------------|
| 5500       | 6000       | 5000       | 2                |
```

**Approach:**
Use aggregation functions: AVG(), MAX(), MIN(), COUNT().

**Code:**
```python
`` `sql
SELECT AVG(salary) AS avg_salary,
       MAX(salary) AS max_salary,
       MIN(salary) AS min_salary,
       COUNT(*) AS total_employees
FROM Salaries;
`` `
```

## SQL Problem 16: Not Boring Movies

**Category/Pattern:** WHERE clause | Subquery

**Difficulty:** Easy

**Problem:**
Write a SQL query to find all movies with an odd id and a description not equal to 'boring'.

**Examples:**
```text
Input:
Cinema table:
| id | movie  | description |
|----|--------|-------------|
| 1  | Alien  | boring      |
| 2  | Logan  | action      |

Output:
| id | movie |
|----|--------|
| 2  | Logan |
```

**Approach:**
Use WHERE clause with modulo check and condition on description.

**Code:**
```python
`` `sql
SELECT * 
FROM Cinema
WHERE id % 2 = 1 AND description != 'boring'
ORDER BY rating DESC;
`` `
```

## SQL Problem 17: Average Selling Price

**Category/Pattern:** JOIN | Aggregation

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the average selling price per product.

**Examples:**
```text
Input:
Prices table:
| product_id | price |
|------------|-------|
| 1          | 100   |
| 2          | 200   |

UnitsSold table:
| product_id | units |
|------------|-------|
| 1          | 2     |
| 2          | 1     |

Output:
| product_id | average_price |
|------------|----------------|
| 1          | 100.00         |
| 2          | 200.00         |
```

**Approach:**
Multiply price × units, then divide total by units for each product.

**Code:**
```python
`` `sql
SELECT p.product_id,
       ROUND(SUM(p.price * u.units) / SUM(u.units), 2) AS average_price
FROM Prices p
JOIN UnitsSold u ON p.product_id = u.product_id
GROUP BY p.product_id;
`` `
```

## SQL Problem 18: Project Employees I

**Category/Pattern:** JOIN | Filtering

**Difficulty:** Easy

**Problem:**
Write a SQL query to list all employee IDs participating in each project.

**Examples:**
```text
Input:
Project table:
| project_id | employee_id |
|------------|-------------|
| 1          | 1           |
| 1          | 2           |

Output:
| project_id | employee_id |
|------------|-------------|
| 1          | 1           |
| 1          | 2           |
```

**Approach:**
Select all records from Project as-is.

**Code:**
```python
`` `sql
SELECT project_id, employee_id
FROM Project;
`` `
```

## SQL Problem 19: Percentage of Users Attended a Contest

**Category/Pattern:** JOIN | Aggregation | Division

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the percentage of users who attended at least one contest.

**Examples:**
```text
Input:
Users table:
| user_id | name |
|---------|------|
| 6       | Alice|
| 7       | Bob  |

Register table:
| contest_id | user_id |
|------------|---------|
| 215        | 6       |

Output:
| percentage |
|------------|
| 50.00      |
```

**Approach:**
Use COUNT(DISTINCT) on Register and divide by total users.

**Code:**
```python
`` `sql
SELECT ROUND(COUNT(DISTINCT r.user_id) * 100.0 / COUNT(DISTINCT u.user_id), 2) AS percentage
FROM Users u
LEFT JOIN Register r ON u.user_id = r.user_id;
`` `
```

## SQL Problem 20: Queries Quality and Percentage

**Category/Pattern:** Aggregation | Conditional Count

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the average quality and percentage of poor queries (rating < 3) per query_name.

**Examples:**
```text
Input:
Queries table:
| query_name | rating | position |
|------------|--------|----------|
| google     | 5      | 1        |
| google     | 2      | 2        |

Output:
| query_name | quality | poor_query_percentage |
|------------|---------|------------------------|
| google     | 3.5     | 50.00                  |
```

**Approach:**
Use conditional COUNT with rating < 3 and calculate percentage.

**Code:**
```python
`` `sql
SELECT query_name,
       ROUND(AVG(rating), 2) AS quality,
       ROUND(SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS poor_query_percentage
FROM Queries
GROUP BY query_name;
`` `
```

## SQL Problem 21: Monthly Transactions I

**Category/Pattern:** GROUP BY | Aggregation | Date Functions

**Difficulty:** Medium

**Problem:**
Write a SQL query to get the number of transactions per month and their total amount.

**Examples:**
```text
Input:
Transactions table:
| id | country | state | amount | trans_date |
|----|---------|-------|--------|------------|
| 1  | US      | approved | 1000 | 2021-01-01 |
| 2  | US      | declined | 2000 | 2021-01-05 |

Output:
| month      | trans_count | total_amount |
|------------|-------------|--------------|
| 2021-01    | 2           | 3000         |
```

**Approach:**
GROUP BY formatted month using DATE_FORMAT and COUNT/SUM values.

**Code:**
```python
`` `sql
SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month,
       COUNT(*) AS trans_count,
       SUM(amount) AS total_amount
FROM Transactions
GROUP BY month;
`` `
```

## SQL Problem 22: Immediate Food Delivery II

**Category/Pattern:** JOIN | Conditional Aggregation

**Difficulty:** Medium

**Problem:**
Write a SQL query to calculate the immediate delivery rate per customer.

**Examples:**
```text
Input:
Delivery table:
| delivery_id | customer_id | order_date | customer_pref_delivery_date |
|-------------|-------------|------------|------------------------------|
| 1           | 1           | 2022-01-01 | 2022-01-01                   |

Output:
| immediate_percentage |
|----------------------|
| 100.00               |
```

**Approach:**
Compare order_date with preferred_delivery_date and calculate percentage.

**Code:**
```python
`` `sql
SELECT ROUND(SUM(order_date = customer_pref_delivery_date) * 100.0 / COUNT(*), 2) AS immediate_percentage
FROM Delivery;
`` `
```

## SQL Problem 23: Game Play Analysis IV

**Category/Pattern:** Window Functions | Aggregation

**Difficulty:** Medium

**Problem:**
Write a SQL query to find players who logged in for 3 consecutive days.

**Examples:**
```text
Input:
Activity table:
| player_id | event_date |
|-----------|------------|
| 1         | 2022-01-01 |
| 1         | 2022-01-02 |
| 1         | 2022-01-03 |

Output:
| player_id |
|-----------|
| 1         |
```

**Approach:**
Use DENSE_RANK or LEAD/LAG functions to check for 3-day streaks.

**Code:**
```python
`` `sql
SELECT DISTINCT player_id
FROM (
  SELECT player_id, event_date,
         LEAD(event_date, 1) OVER (PARTITION BY player_id ORDER BY event_date) AS next_day,
         LEAD(event_date, 2) OVER (PARTITION BY player_id ORDER BY event_date) AS next_day2
  FROM Activity
) a
WHERE DATEDIFF(next_day, event_date) = 1
  AND DATEDIFF(next_day2, next_day) = 1;
`` `
```

## SQL Problem 24: Sorting and Grouping

**Category/Pattern:** GROUP BY | ORDER BY

**Difficulty:** Medium

**Problem:**
Write a SQL query to group and sort records based on certain fields.

**Examples:**
```text
Input:
Items table:
| id | category | price |
|----|----------|--------|
| 1  | A        | 10     |
| 2  | A        | 15     |
| 3  | B        | 20     |

Output:
| category | total_price |
|----------|-------------|
| A        | 25          |
| B        | 20          |
```

**Approach:**
GROUP BY the category and SUM the prices, then ORDER BY total.

**Code:**
```python
`` `sql
SELECT category, SUM(price) AS total_price
FROM Items
GROUP BY category
ORDER BY total_price DESC;
`` `
```

## SQL Problem 25: Number of Unique Subjects Taught by Each Teacher

**Category/Pattern:** GROUP BY | COUNT(DISTINCT)

**Difficulty:** Easy

**Problem:**
Write a SQL query to count the number of unique subjects each teacher teaches.

**Examples:**
```text
Input:
Teacher table:
| teacher_id | subject_id |
|------------|------------|
| 1          | 101        |
| 1          | 102        |
| 2          | 101        |

Output:
| teacher_id | cnt |
|------------|-----|
| 1          | 2   |
| 2          | 1   |
```

**Approach:**
GROUP BY teacher_id and COUNT(DISTINCT subject_id).

**Code:**
```python
`` `sql
SELECT teacher_id, COUNT(DISTINCT subject_id) AS cnt
FROM Teacher
GROUP BY teacher_id;
`` `
```

## SQL Problem 26: User Activity for the Past 30 Days I

**Category/Pattern:** DATE | COUNT | GROUP BY

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the number of users active in the past 30 days from today.

**Examples:**
```text
Input:
UserActivity table:
| user_id | activity_date |
|---------|----------------|
| 1       | 2023-08-01     |
| 2       | 2023-08-20     |

Assuming today's date is 2023-08-31.

Output:
| user_id | activity_count |
|---------|----------------|
| 1       | 1              |
| 2       | 1              |
```

**Approach:**
Use WHERE clause to filter last 30 days and COUNT by user_id.

**Code:**
```python
`` `sql
SELECT user_id, COUNT(*) AS activity_count
FROM UserActivity
WHERE activity_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
GROUP BY user_id;
`` `
```

## SQL Problem 27: Product Sales Analysis III

**Category/Pattern:** GROUP BY | JOIN | Aggregation

**Difficulty:** Medium

**Problem:**
Write a SQL query to return the top-selling product(s) by quantity in 2022.

**Examples:**
```text
Input:
Sales table:
| product_id | year | quantity |
|------------|------|----------|
| 1          | 2022 | 500      |
| 2          | 2022 | 600      |

Output:
| product_id |
|------------|
| 2          |
```

**Approach:**
GROUP BY product_id and filter by year. Use subquery for MAX quantity.

**Code:**
```python
`` `sql
SELECT product_id
FROM Sales
WHERE year = 2022
GROUP BY product_id
HAVING SUM(quantity) = (
  SELECT MAX(total)
  FROM (
    SELECT SUM(quantity) AS total
    FROM Sales
    WHERE year = 2022
    GROUP BY product_id
  ) AS t
);
`` `
```

## SQL Problem 28: Classes With at Least 5 Students

**Category/Pattern:** GROUP BY | HAVING

**Difficulty:** Easy

**Problem:**
Write a SQL query to find all class IDs with at least 5 students.

**Examples:**
```text
Input:
Courses table:
| student | class |
|---------|-------|
| A       | 1     |
| B       | 1     |
| C       | 1     |
| D       | 1     |
| E       | 1     |
| F       | 2     |

Output:
| class |
|-------|
| 1     |
```

**Approach:**
GROUP BY class and use HAVING COUNT(*) >= 5.

**Code:**
```python
`` `sql
SELECT class
FROM Courses
GROUP BY class
HAVING COUNT(DISTINCT student) >= 5;
`` `
```

## SQL Problem 29: Find Followers Count

**Category/Pattern:** GROUP BY | COUNT

**Difficulty:** Easy

**Problem:**
Write a SQL query to get the number of followers each user has.

**Examples:**
```text
Input:
Followers table:
| user_id | follower_id |
|---------|-------------|
| 1       | 2           |
| 1       | 3           |

Output:
| user_id | followers_count |
|---------|------------------|
| 1       | 2                |
```

**Approach:**
GROUP BY user_id and COUNT(follower_id).

**Code:**
```python
`` `sql
SELECT user_id, COUNT(follower_id) AS followers_count
FROM Followers
GROUP BY user_id;
`` `
```

## SQL Problem 30: Biggest Single Number

**Category/Pattern:** Subquery | Filtering

**Difficulty:** Easy

**Problem:**
Write a SQL query to find the largest number that occurs only once in the table.

**Examples:**
```text
Input:
Numbers table:
| num |
|-----|
| 8   |
| 8   |
| 3   |

Output:
| num |
|-----|
| 3   |
```

**Approach:**
GROUP BY num, HAVING COUNT(*) = 1, ORDER BY DESC and LIMIT 1.

**Code:**
```python
`` `sql
SELECT MAX(num) AS num
FROM (
    SELECT num
    FROM Numbers
    GROUP BY num
    HAVING COUNT(*) = 1
) AS single;
`` `
```

## SQL Problem 31: Customers Who Bought All Products

**Category/Pattern:** Relational Division | GROUP BY | HAVING

**Difficulty:** Medium

**Problem:**
Find customers who bought all available products.

**Examples:**
```text
Input:
Customer table:
| customer_id | product_key |
|-------------|-------------|
| 1           | 5           |
| 1           | 6           |
| 2           | 5           |

Product table:
| product_key |
|-------------|
| 5           |
| 6           |

Output:
| customer_id |
|-------------|
| 1           |
```

**Approach:**
Count distinct product_key per customer and match it to total product count.

**Code:**
```python
`` `sql
SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product);
`` `
```

## SQL Problem 32: The Number of Employees Which Report to Each Employee

**Category/Pattern:** Self JOIN | GROUP BY

**Difficulty:** Easy

**Problem:**
Find number of employees reporting to each manager.

**Examples:**
```text
Input:
Employee table:
| employee_id | name | manager_id |
|-------------|------|------------|
| 1           | John | null       |
| 2           | Dan  | 1          |

Output:
| employee_id | reports_count |
|-------------|----------------|
| 1           | 1              |
```

**Approach:**
GROUP BY manager_id and COUNT employees.

**Code:**
```python
`` `sql
SELECT manager_id AS employee_id, COUNT(*) AS reports_count
FROM Employee
WHERE manager_id IS NOT NULL
GROUP BY manager_id;
`` `
```

## SQL Problem 33: Primary Department for Each Employee

**Category/Pattern:** JOIN | ROW_NUMBER | Window Function

**Difficulty:** Easy

**Problem:**
Return each employee's primary department (with the smallest department_id).

**Examples:**
```text
Input:
Employee table:
| employee_id | department_id |
|-------------|---------------|
| 1           | 1             |
| 1           | 2             |

Output:
| employee_id | department_id |
|-------------|---------------|
| 1           | 1             |
```

**Approach:**
Use ROW_NUMBER partitioned by employee_id, ordered by department_id.

**Code:**
```python
`` `sql
WITH ranked AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY employee_id ORDER BY department_id) AS rn
  FROM Employee
)
SELECT employee_id, department_id
FROM ranked
WHERE rn = 1;
`` `
```

## SQL Problem 34: Triangle Judgement

**Category/Pattern:** CASE WHEN | Basic Logic

**Difficulty:** Easy

**Problem:**
Determine if 3 numbers can form a triangle.

**Examples:**
```text
Input:
Triangle table:
| x | y | z |
|---|---|---|
| 3 | 4 | 5 |
| 1 | 1 | 3 |

Output:
| triangle |
|----------|
| Yes      |
| No       |
```

**Approach:**
Check triangle inequality: x + y > z and permutations.

**Code:**
```python
`` `sql
SELECT *,
       CASE
           WHEN x + y > z AND x + z > y AND y + z > x THEN 'Yes'
           ELSE 'No'
       END AS triangle
FROM Triangle;
`` `
```

## SQL Problem 35: Consecutive Numbers

**Category/Pattern:** Window Function | Self Join

**Difficulty:** Medium

**Problem:**
Find numbers that appear at least 3 times consecutively.

**Examples:**
```text
Input:
Logs table:
| id | num |
|----|-----|
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |

Output:
| num |
|-----|
| 1   |
```

**Approach:**
Use LEAD/LAG or self joins to check 3 consecutive rows.

**Code:**
```python
`` `sql
SELECT DISTINCT l1.num
FROM Logs l1
JOIN Logs l2 ON l1.id = l2.id - 1
JOIN Logs l3 ON l1.id = l3.id - 2
WHERE l1.num = l2.num AND l2.num = l3.num;
`` `
```

## SQL Problem 36: Product Price at a Given Date

**Category/Pattern:** Temporal Join | Filtering

**Difficulty:** Medium

**Problem:**
Get price of each product as of a given date.

**Examples:**
```text
Input:
Products table:
| product_id | price | change_date |
|------------|-------|-------------|
| 1          | 10    | 2021-01-01  |
| 1          | 20    | 2021-03-01  |

Query Date: 2021-02-01

Output:
| product_id | price |
|------------|--------|
| 1          | 10     |
```

**Approach:**
Filter records where change_date <= query_date and pick latest via RANK/ROW_NUMBER.

**Code:**
```python
`` `sql
WITH ranked_prices AS (
  SELECT *,
         ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rn
  FROM Products
  WHERE change_date <= '2021-02-01'
)
SELECT product_id, price
FROM ranked_prices
WHERE rn = 1;
`` `
```

## SQL Problem 37: Last Person to Fit in the Bus

**Category/Pattern:** Running Total | Cumulative SUM

**Difficulty:** Medium

**Problem:**
Determine the last person that fits into the bus before capacity is exceeded.

**Examples:**
```text
Input:
Passengers table:
| id | weight |
|----|--------|
| 1  | 100    |
| 2  | 150    |

Bus capacity = 200

Output:
| id |
|----|
| 1  |
```

**Approach:**
Use window function SUM() to track cumulative weight and filter where it crosses the limit.

**Code:**
```python
`` `sql
WITH running_weight AS (
  SELECT id, weight,
         SUM(weight) OVER (ORDER BY id) AS total_weight
  FROM Passengers
)
SELECT MAX(id) AS last_person
FROM running_weight
WHERE total_weight <= 200;
`` `
```

## SQL Problem 38: Count Salary Categories

**Category/Pattern:** CASE WHEN | GROUP BY

**Difficulty:** Medium

**Problem:**
Categorize and count salaries into three buckets.

**Examples:**
```text
Input:
Salaries table:
| id | salary |
|----|--------|
| 1  | 100    |
| 2  | 500    |
| 3  | 1200   |

Output:
| category | count |
|----------|-------|
| Low      | 1     |
| Medium   | 1     |
| High     | 1     |
```

**Approach:**
Use CASE WHEN for salary ranges and GROUP BY the category.

**Code:**
```python
`` `sql
SELECT
  CASE
    WHEN salary < 500 THEN 'Low'
    WHEN salary BETWEEN 500 AND 1000 THEN 'Medium'
    ELSE 'High'
  END AS category,
  COUNT(*) AS count
FROM Salaries
GROUP BY category;
`` `
```

## SQL Problem 39: Employees Whose Manager Left the Company

**Category/Pattern:** Self Join | NULL Check

**Difficulty:** Easy

**Problem:**
Find employees whose manager no longer exists in the company.

**Examples:**
```text
Input:
Employees table:
| id | name | manager_id |
|----|------|------------|
| 1  | A    | null       |
| 2  | B    | 3          |
| 3  | C    | null       |
| 4  | D    | 5          |

Output:
| name |
|------|
| D    |
```

**Approach:**
LEFT JOIN on manager_id and check for NULL on joined manager.

**Code:**
```python
`` `sql
SELECT e.name
FROM Employees e
LEFT JOIN Employees m ON e.manager_id = m.id
WHERE e.manager_id IS NOT NULL AND m.id IS NULL;
`` `
```

## SQL Problem 40: Exchange Seats

**Category/Pattern:** CASE | Modulo | Self Join

**Difficulty:** Medium

**Problem:**
Swap seats for every pair of students.

**Examples:**
```text
Input:
Seat table:
| id | student |
|----|---------|
| 1  | A       |
| 2  | B       |
| 3  | C       |

Output:
| id | student |
|----|---------|
| 1  | B       |
| 2  | A       |
| 3  | C       |
```

**Approach:**
Use CASE or self join to swap every adjacent pair based on even/odd ID.

**Code:**
```python
`` `sql
SELECT id,
       CASE
           WHEN id % 2 = 1 AND id + 1 IN (SELECT id FROM Seat)
               THEN LEAD(student) OVER (ORDER BY id)
           WHEN id % 2 = 0 THEN LAG(student) OVER (ORDER BY id)
           ELSE student
       END AS student
FROM Seat;
`` `
```

## SQL Problem 41: Movie Rating

**Category/Pattern:** JOIN | Aggregation

**Difficulty:** Medium

**Problem:**
Find movie ratings and order them based on the average rating and popularity.

**Examples:**
```text
Input:
Users table, Movies table, and Ratings table

Output:
List of movie titles ordered by average rating and number of ratings.
```

**Approach:**
JOIN Ratings with Movies, group by movie title, and order by AVG(rating) and COUNT(*) DESC.

**Code:**
```python
`` `sql
SELECT m.title
FROM Movies m
JOIN Ratings r ON m.movie_id = r.movie_id
GROUP BY m.title
ORDER BY AVG(r.rating) DESC, COUNT(*) DESC;
`` `
```

## SQL Problem 42: Restaurant Growth

**Category/Pattern:** Window Functions | Running Total

**Difficulty:** Medium

**Problem:**
Track the number of customers for each restaurant over time.

**Examples:**
```text
Input:
Sales table with restaurant_id, sale_date, and customer_count.

Output:
Cumulative customer count by restaurant over time.
```

**Approach:**
Use SUM() OVER (PARTITION BY restaurant_id ORDER BY sale_date) to calculate running total.

**Code:**
```python
`` `sql
SELECT restaurant_id, sale_date,
       SUM(customer_count) OVER (PARTITION BY restaurant_id ORDER BY sale_date) AS cumulative_customers
FROM Sales;
`` `
```

## SQL Problem 43: Friend Requests II: Who Has the Most Friends

**Category/Pattern:** Self Join | Aggregation

**Difficulty:** Medium

**Problem:**
Determine who has the most friends based on friend request pairs.

**Examples:**
```text
Input:
RequestAccepted table with requester_id and accepter_id

Output:
User ID with the highest number of friends
```

**Approach:**
UNION requester and accepter into one column, then GROUP BY user ID and count occurrences.

**Code:**
```python
`` `sql
SELECT id, COUNT(*) AS num
FROM (
    SELECT requester_id AS id FROM RequestAccepted
    UNION ALL
    SELECT accepter_id AS id FROM RequestAccepted
) AS all_ids
GROUP BY id
ORDER BY num DESC
LIMIT 1;
`` `
```

## SQL Problem 44: Investments in 2016

**Category/Pattern:** Filtering | Aggregation

**Difficulty:** Medium

**Problem:**
Find investors who made high investments in 2016.

**Examples:**
```text
Input:
Investments table with investor_id, amount, and investment_date

Output:
Investors with high total investment in 2016
```

**Approach:**
Filter year = 2016, group by investor_id and use HAVING for minimum threshold.

**Code:**
```python
`` `sql
SELECT investor_id
FROM Investments
WHERE YEAR(investment_date) = 2016
GROUP BY investor_id
HAVING SUM(amount) >= 100000;
`` `
```

## SQL Problem 45: Department Top Three Salaries

**Category/Pattern:** Window Function | RANK

**Difficulty:** Hard

**Problem:**
Get top three salaries from each department.

**Examples:**
```text
Input:
Employee table with salary and department_id

Output:
Top 3 highest salaries per department
```

**Approach:**
Use DENSE_RANK() or ROW_NUMBER() partitioned by department and filter where rank <= 3.

**Code:**
```python
`` `sql
WITH RankedSalaries AS (
  SELECT name, salary, department_id,
         DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rnk
  FROM Employee
)
SELECT name, salary, department_id
FROM RankedSalaries
WHERE rnk <= 3;
`` `
```

## SQL Problem 46: Fix Names in a Table

**Category/Pattern:** String Functions | Capitalization

**Difficulty:** Easy

**Problem:**
Capitalize the first letter and make the rest lowercase in each name.

**Examples:**
```text
Input:
| user_id | name   |
|---------|--------|
| 1       | aLiCE  |

Output:
| user_id | name   |
|---------|--------|
| 1       | Alice  |
```

**Approach:**
Use CONCAT with UPPER(LEFT(name,1)) and LOWER(SUBSTRING).

**Code:**
```python
`` `sql
SELECT user_id,
       CONCAT(UPPER(LEFT(name, 1)), LOWER(SUBSTRING(name, 2))) AS name
FROM Users;
`` `
```

## SQL Problem 47: Patients With a Condition

**Category/Pattern:** Filtering | String Matching

**Difficulty:** Easy

**Problem:**
Get patients diagnosed with a condition starting with 'DIAB1'.

**Examples:**
```text
Input:
| patient_id | conditions          |
|------------|---------------------|
| 1          | DIAB100, CANCER200  |

Output:
| patient_id |
|------------|
| 1          |
```

**Approach:**
Use LIKE or REGEXP to filter conditions starting with DIAB1.

**Code:**
```python
`` `sql
SELECT patient_id
FROM Patients
WHERE conditions LIKE 'DIAB1%';
`` `
```

## SQL Problem 48: Delete Duplicate Emails

**Category/Pattern:** Duplicate Handling | DELETE

**Difficulty:** Easy

**Problem:**
Remove duplicate emails, keep the row with the smallest id.

**Examples:**
```text
Input:
| id | email         |
|----|---------------|
| 1  | a@leetcode.com|
| 2  | b@leetcode.com|
| 3  | a@leetcode.com|

Output:
Only ids 1 and 2 remain.
```

**Approach:**
Use DELETE with WHERE id NOT IN (subquery selecting MIN(id) for each email).

**Code:**
```python
`` `sql
DELETE FROM Person
WHERE id NOT IN (
  SELECT MIN(id)
  FROM Person
  GROUP BY email
);
`` `
```

## SQL Problem 49: Second Highest Salary

**Category/Pattern:** Subquery | Aggregation

**Difficulty:** Medium

**Problem:**
Return the second highest salary from Employee table.

**Examples:**
```text
Input:
| id | salary |
|----|--------|
| 1  | 100    |
| 2  | 200    |

Output:
| SecondHighestSalary |
|---------------------|
| 100                 |
```

**Approach:**
Use MAX with subquery to find max salary less than overall max.

**Code:**
```python
`` `sql
SELECT MAX(salary) AS SecondHighestSalary
FROM Employee
WHERE salary < (
  SELECT MAX(salary) FROM Employee
);
`` `
```

## SQL Problem 50: Group Sold Products By The Date

**Category/Pattern:** GROUP BY | Aggregation

**Difficulty:** Easy

**Problem:**
Group products sold by date and show product names comma-separated.

**Examples:**
```text
Input:
| sell_date | product |
|-----------|---------|
| 2020-05-30| Apple   |
| 2020-05-30| Banana  |

Output:
| sell_date | products      |
|-----------|---------------|
| 2020-05-30| Apple,Banana  |
```

**Approach:**
GROUP BY sell_date and use GROUP_CONCAT or STRING_AGG.

**Code:**
```python
`` `sql
SELECT sell_date,
       GROUP_CONCAT(product ORDER BY product) AS products
FROM Activities
GROUP BY sell_date;
`` `
```


---
title: "NeetCode 150 + SQL 50 Study Guide"
format:
  html:
    toc: true
    toc-depth: 3
    code-tools: true
    code-fold: true
    smooth-scroll: true
---

# NeetCode 150 (Python Problems)


## Array | Hash Table


### 1. Contains Duplicate
**Category**: Array | Hash Table  
**Difficulty**: Easy

#### Description
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

#### Examples
Input: nums = [1,2,3,1]
Output: true

#### Approach
Use a set to keep track of seen elements. If an element is already in the set, return True. Otherwise, continue adding elements to the set.

#### Code
```python
def containsDuplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False
```


### 2. Valid Anagram
**Category**: Array | Hash Table  
**Difficulty**: Easy

#### Description
Given two strings s and t, return true if t is an anagram of s, and false otherwise.

#### Examples
Input: s = 'anagram', t = 'nagaram'
Output: true

#### Approach
Use collections.Counter to count the frequency of characters in both strings and compare the resulting dictionaries.

#### Code
```python
from collections import Counter

def isAnagram(s, t):
    return Counter(s) == Counter(t)
```


### 3. Two Sum
**Category**: Array | Hash Table  
**Difficulty**: Easy

#### Description
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

#### Examples
Input: nums = [2,7,11,15], target = 9
Output: [0,1]

#### Approach
Use a hash map to store each number’s complement (target - num) and its index. If the current number exists in the map, return its index and the current index.

#### Code
```python
def twoSum(nums, target):
    lookup = {}
    for i, num in enumerate(nums):
        if target - num in lookup:
            return [lookup[target - num], i]
        lookup[num] = i
```


### 4. Group Anagrams
**Category**: Array | Hash Table  
**Difficulty**: Medium

#### Description
Given an array of strings strs, group the anagrams together. You can return the answer in any order.

#### Examples
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["eat","tea","ate"],["tan","nat"],["bat"]]

#### Approach
Sort each word and use the sorted word as a key in a dictionary to group all anagrams together.

#### Code
```python
from collections import defaultdict

def groupAnagrams(strs):
    anagrams = defaultdict(list)
    for word in strs:
        key = ''.join(sorted(word))
        anagrams[key].append(word)
    return list(anagrams.values())
```


### 5. Top K Frequent Elements
**Category**: Array | Hash Table  
**Difficulty**: Medium

#### Description
Given a non-empty array of integers, return the k most frequent elements.

#### Examples
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

#### Approach
Use Counter to count frequencies, then use a heap to extract the top k elements based on frequency.

#### Code
```python
from collections import Counter
import heapq

def topKFrequent(nums, k):
    count = Counter(nums)
    return heapq.nlargest(k, count.keys(), key=count.get)
```


### 6. Encode and Decode Strings
**Category**: Array | Hash Table  
**Difficulty**: Medium

#### Description
Design an algorithm to encode a list of strings to a single string, and decode that string back to a list of strings.

#### Examples
Input: ["lint","code","love","you"]
Encoded: "4#lint4#code4#love3#you"

#### Approach
For encoding, prefix each string with its length and a special delimiter. For decoding, read the length, then the string.

#### Code
```python
class Codec:
    def encode(self, strs):
        return ''.join(f"{len(s)}#{s}" for s in strs)

    def decode(self, s):
        i, res = 0, []
        while i < len(s):
            j = s.find('#', i)
            length = int(s[i:j])
            i = j + 1
            res.append(s[i:i+length])
            i += length
        return res
```


### 7. Product of Array Except Self
**Category**: Array | Hash Table  
**Difficulty**: Medium

#### Description
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

#### Examples
Input: nums = [1,2,3,4]
Output: [24,12,8,6]

#### Approach
Use two passes: left-to-right to compute prefix products, then right-to-left for suffix products. Multiply the results.

#### Code
```python
def productExceptSelf(nums):
    n = len(nums)
    res = [1] * n
    prefix = 1
    for i in range(n):
        res[i] = prefix
        prefix *= nums[i]
    suffix = 1
    for i in range(n-1, -1, -1):
        res[i] *= suffix
        suffix *= nums[i]
    return res
```


### 8. Valid Sudoku
**Category**: Array | Hash Table  
**Difficulty**: Medium

#### Description
Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated.

#### Examples
Input: 9x9 board with numbers and '.'
Output: true or false

#### Approach
Use sets to track seen numbers in each row, column, and 3x3 sub-box. Validate as you go.

#### Code
```python
def isValidSudoku(board):
    rows = [set() for _ in range(9)]
    cols = [set() for _ in range(9)]
    boxes = [set() for _ in range(9)]
    
    for r in range(9):
        for c in range(9):
            val = board[r][c]
            if val == ".":
                continue
            if val in rows[r] or val in cols[c] or val in boxes[(r//3)*3 + c//3]:
                return False
            rows[r].add(val)
            cols[c].add(val)
            boxes[(r//3)*3 + c//3].add(val)
    return True
```


### 9. Longest Consecutive Sequence
**Category**: Array | Hash Table  
**Difficulty**: Medium

#### Description
Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

#### Examples
Input: nums = [100,4,200,1,3,2]
Output: 4

#### Approach
Put all elements into a set. For each number, if it's the start of a sequence (num-1 not in set), count the sequence length forward.

#### Code
```python
def longestConsecutive(nums):
    num_set = set(nums)
    longest = 0
    for num in num_set:
        if num - 1 not in num_set:
            length = 1
            while num + length in num_set:
                length += 1
            longest = max(longest, length)
    return longest
```


## Two Pointers


### 10. Valid Palindrome
**Category**: Two Pointers  
**Difficulty**: Easy

#### Description
Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

#### Examples
Input: s = 'A man, a plan, a canal: Panama'
Output: true

#### Approach
Use two pointers: one from the start and one from the end. Move inward, skipping non-alphanumeric characters, and compare lowercase values.

#### Code
```python
def isPalindrome(s: str) -> bool:
    left, right = 0, len(s) - 1
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        if s[left].lower() != s[right].lower():
            return False
        left += 1
        right -= 1
    return True
```


### 11. Two Sum II Input Array Is Sorted
**Category**: Two Pointers  
**Difficulty**: Medium

#### Description
Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target.

#### Examples
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]

#### Approach
Use two pointers from start and end. If sum is greater than target, move right pointer left; if less, move left pointer right.

#### Code
```python
def twoSum(numbers, target):
    left, right = 0, len(numbers) - 1
    while left < right:
        curr_sum = numbers[left] + numbers[right]
        if curr_sum == target:
            return [left + 1, right + 1]
        elif curr_sum < target:
            left += 1
        else:
            right -= 1
```


### 12. 3Sum
**Category**: Two Pointers  
**Difficulty**: Medium

#### Description
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j != k, and they sum to 0.

#### Examples
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

#### Approach
Sort the array and use two pointers on each fixed element. Skip duplicates and move pointers based on current sum.

#### Code
```python
def threeSum(nums):
    nums.sort()
    res = []
    for i, a in enumerate(nums):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        l, r = i + 1, len(nums) - 1
        while l < r:
            total = a + nums[l] + nums[r]
            if total > 0:
                r -= 1
            elif total < 0:
                l += 1
            else:
                res.append([a, nums[l], nums[r]])
                while l < r and nums[l] == nums[l + 1]:
                    l += 1
                while l < r and nums[r] == nums[r - 1]:
                    r -= 1
                l += 1
                r -= 1
    return res
```


### 13. Container With Most Water
**Category**: Two Pointers  
**Difficulty**: Medium

#### Description
You are given an integer array height of length n. There are n vertical lines. Find two lines that together with the x-axis form a container that holds the most water.

#### Examples
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49

#### Approach
Use two pointers and calculate area at each step. Move the pointer pointing to the shorter line inward.

#### Code
```python
def maxArea(height):
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        max_area = max(max_area, (right - left) * min(height[left], height[right]))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```


### 14. Trapping Rain Water
**Category**: Two Pointers  
**Difficulty**: Hard

#### Description
Given n non-negative integers representing an elevation map, compute how much water it can trap after raining.

#### Examples
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

#### Approach
Use two pointers with left_max and right_max tracking the highest bars. Water trapped at any point is min(left_max, right_max) - height[i].

#### Code
```python
def trap(height):
    left, right = 0, len(height) - 1
    left_max = right_max = 0
    water = 0
    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1
    return water
```


## Sliding Window


### 15. Best Time to Buy And Sell Stock
**Category**: Sliding Window  
**Difficulty**: Easy

#### Description
You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve from a single buy and sell.

#### Examples
Input: prices = [7,1,5,3,6,4]
Output: 5

#### Approach
Track the minimum price so far and compute the potential profit at each day. Update the max profit accordingly.

#### Code
```python
def maxProfit(prices):
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        if price < min_price:
            min_price = price
        max_profit = max(max_profit, price - min_price)
    return max_profit
```


### 16. Longest Substring Without Repeating Characters
**Category**: Sliding Window  
**Difficulty**: Medium

#### Description
Given a string s, find the length of the longest substring without repeating characters.

#### Examples
Input: s = 'abcabcbb'
Output: 3

#### Approach
Use a sliding window and a set to store characters. Move the window’s left edge when duplicates are found.

#### Code
```python
def lengthOfLongestSubstring(s):
    char_set = set()
    left = 0
    max_len = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_len = max(max_len, right - left + 1)
    return max_len
```


### 17. Longest Repeating Character Replacement
**Category**: Sliding Window  
**Difficulty**: Medium

#### Description
Given a string s and an integer k, return the length of the longest substring containing the same letter you can get after performing at most k character replacements.

#### Examples
Input: s = 'ABAB', k = 2
Output: 4

#### Approach
Use a sliding window and count the most frequent character in the window. If the window size minus most frequent count is > k, shrink the window.

#### Code
```python
from collections import defaultdict

def characterReplacement(s, k):
    count = defaultdict(int)
    left = maxf = 0
    res = 0
    for right in range(len(s)):
        count[s[right]] += 1
        maxf = max(maxf, count[s[right]])
        while (right - left + 1) - maxf > k:
            count[s[left]] -= 1
            left += 1
        res = max(res, right - left + 1)
    return res
```


### 18. Permutation In String
**Category**: Sliding Window  
**Difficulty**: Medium

#### Description
Given two strings s1 and s2, return true if s2 contains a permutation of s1.

#### Examples
Input: s1 = 'ab', s2 = 'eidbaooo'
Output: true

#### Approach
Use sliding window of size len(s1) over s2 and compare character counts using Counter.

#### Code
```python
from collections import Counter

def checkInclusion(s1, s2):
    if len(s1) > len(s2):
        return False
    s1_count = Counter(s1)
    window = Counter(s2[:len(s1)])
    if s1_count == window:
        return True
    for i in range(len(s1), len(s2)):
        window[s2[i]] += 1
        window[s2[i - len(s1)]] -= 1
        if window[s2[i - len(s1)]] == 0:
            del window[s2[i - len(s1)]]
        if window == s1_count:
            return True
    return False
```


### 19. Minimum Window Substring
**Category**: Sliding Window  
**Difficulty**: Hard

#### Description
Given two strings s and t, return the minimum window in s which contains all the characters of t.

#### Examples
Input: s = 'ADOBECODEBANC', t = 'ABC'
Output: 'BANC'

#### Approach
Use two pointers and count maps to slide a window over s, expanding and contracting to find the minimal valid substring.

#### Code
```python
from collections import Counter

def minWindow(s, t):
    if not t or not s:
        return ""
    t_count = Counter(t)
    window = {}
    have, need = 0, len(t_count)
    res = [-1, -1]
    res_len = float("inf")
    left = 0

    for right, c in enumerate(s):
        window[c] = window.get(c, 0) + 1
        if c in t_count and window[c] == t_count[c]:
            have += 1
        while have == need:
            if (right - left + 1) < res_len:
                res = [left, right]
                res_len = right - left + 1
            window[s[left]] -= 1
            if s[left] in t_count and window[s[left]] < t_count[s[left]]:
                have -= 1
            left += 1
    l, r = res
    return s[l:r+1] if res_len != float("inf") else ""
```


### 20. Sliding Window Maximum
**Category**: Sliding Window  
**Difficulty**: Hard

#### Description
You are given an array nums and an integer k, return the maximum value in every sliding window of size k.

#### Examples
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

#### Approach
Use a deque to store indices in decreasing order of their values. Remove out-of-bound indices and keep the max at the front.

#### Code
```python
from collections import deque

def maxSlidingWindow(nums, k):
    q = deque()
    res = []

    for i, n in enumerate(nums):
        while q and nums[q[-1]] < n:
            q.pop()
        q.append(i)

        if q[0] == i - k:
            q.popleft()

        if i >= k - 1:
            res.append(nums[q[0]])

    return res
```


## Stack


### 21. Valid Parentheses
**Category**: Stack  
**Difficulty**: Easy

#### Description
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

#### Examples
Input: s = "()[]{}"
Output: true

#### Approach
Use a stack to track opening brackets. For each closing bracket, check if it matches the top of the stack.

#### Code
```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in mapping:
            top = stack.pop() if stack else '#'
            if mapping[char] != top:
                return False
        else:
            stack.append(char)
    return not stack
```


### 22. Min Stack
**Category**: Stack  
**Difficulty**: Medium

#### Description
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

#### Examples
Input: ["MinStack","push","push","push","getMin","pop","top","getMin"]
Output: [null,null,null,null,-3,null,0,-2]

#### Approach
Use an auxiliary stack to keep track of the minimum value at each level of the stack.

#### Code
```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```


### 23. Evaluate Reverse Polish Notation
**Category**: Stack  
**Difficulty**: Medium

#### Description
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

#### Examples
Input: tokens = ["2","1","+","3","*"]
Output: 9

#### Approach
Use a stack. For each token, if it’s a number, push to stack. If an operator, pop two numbers, apply the operation, and push result back.

#### Code
```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token not in "+-*/":
            stack.append(int(token))
        else:
            b, a = stack.pop(), stack.pop()
            if token == '+': stack.append(a + b)
            elif token == '-': stack.append(a - b)
            elif token == '*': stack.append(a * b)
            else: stack.append(int(a / b))
    return stack[0]
```


### 24. Generate Parentheses
**Category**: Stack  
**Difficulty**: Medium

#### Description
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

#### Examples
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]

#### Approach
Use backtracking with a stack. Track the count of open and closed parentheses used.

#### Code
```python
def generateParenthesis(n):
    res = []
    def backtrack(s='', left=0, right=0):
        if len(s) == 2 * n:
            res.append(s)
            return
        if left < n:
            backtrack(s + '(', left + 1, right)
        if right < left:
            backtrack(s + ')', left, right + 1)
    backtrack()
    return res
```


### 25. Daily Temperatures
**Category**: Stack  
**Difficulty**: Medium

#### Description
Given a list of daily temperatures, return a list such that for each day, tells how many days to wait for a warmer temperature.

#### Examples
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]

#### Approach
Use a monotonic stack to keep indices of decreasing temperatures. For each new day, calculate how many days it took to get warmer.

#### Code
```python
def dailyTemperatures(temperatures):
    res = [0] * len(temperatures)
    stack = []  # pair: [temp, index]
    for i, t in enumerate(temperatures):
        while stack and t > stack[-1][0]:
            stackT, stackInd = stack.pop()
            res[stackInd] = i - stackInd
        stack.append((t, i))
    return res
```


### 26. Car Fleet
**Category**: Stack  
**Difficulty**: Medium

#### Description
There are n cars going to the same destination. Each car has a position and speed. Return the number of car fleets that will arrive at the destination.

#### Examples
Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3

#### Approach
Sort cars by position, compute their time to target, and count fleets using a stack to manage merging cars.

#### Code
```python
def carFleet(target, position, speed):
    pair = sorted(zip(position, speed), reverse=True)
    stack = []
    for pos, spd in pair:
        time = (target - pos) / spd
        if not stack or time > stack[-1]:
            stack.append(time)
    return len(stack)
```


### 27. Largest Rectangle In Histogram
**Category**: Stack  
**Difficulty**: Hard

#### Description
Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle.

#### Examples
Input: heights = [2,1,5,6,2,3]
Output: 10

#### Approach
Use a stack to keep track of increasing bars. Calculate area when encountering a shorter bar using previous heights and indices.

#### Code
```python
def largestRectangleArea(heights):
    stack = []
    max_area = 0
    heights.append(0)
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            H = heights[stack.pop()]
            W = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, H * W)
        stack.append(i)
    return max_area
```


## Binary Search


### 28. Binary Search
**Category**: Binary Search  
**Difficulty**: Easy

#### Description
Given an array of integers nums which is sorted in ascending order, and an integer target, return the index of target if it is in nums, or -1 if it is not.

#### Examples
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4

#### Approach
Use classic binary search: calculate mid, compare to target, and adjust search space accordingly.

#### Code
```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```


### 29. Search a 2D Matrix
**Category**: Binary Search  
**Difficulty**: Medium

#### Description
Write an efficient algorithm that searches for a value in an m x n matrix. The matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.

#### Examples
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true

#### Approach
Flatten the matrix virtually and apply binary search using row = mid // n and col = mid % n.

#### Code
```python
def searchMatrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    while left <= right:
        mid = (left + right) // 2
        mid_val = matrix[mid // cols][mid % cols]
        if mid_val == target:
            return True
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
```


### 30. Koko Eating Bananas
**Category**: Binary Search  
**Difficulty**: Medium

#### Description
Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Return the minimum integer k such that she can eat all the bananas within h hours.

#### Examples
Input: piles = [3,6,7,11], h = 8
Output: 4

#### Approach
Use binary search to find minimum k. For each guess, simulate hours needed and shrink the range based on feasibility.

#### Code
```python
import math

def minEatingSpeed(piles, h):
    left, right = 1, max(piles)
    while left < right:
        mid = (left + right) // 2
        hours = sum(math.ceil(p / mid) for p in piles)
        if hours > h:
            left = mid + 1
        else:
            right = mid
    return left
```


### 31. Find Minimum In Rotated Sorted Array
**Category**: Binary Search  
**Difficulty**: Medium

#### Description
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Find the minimum element.

#### Examples
Input: nums = [3,4,5,1,2]
Output: 1

#### Approach
Binary search: if mid > right, min is in right half; otherwise, in left. Narrow search window accordingly.

#### Code
```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```


### 32. Search In Rotated Sorted Array
**Category**: Binary Search  
**Difficulty**: Medium

#### Description
You are given an integer array nums sorted in ascending order and rotated at an unknown pivot. Search for target and return its index.

#### Examples
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

#### Approach
Use modified binary search: detect sorted half, check if target is in bounds, and adjust search range.

#### Code
```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```


### 33. Time Based Key Value Store
**Category**: Binary Search  
**Difficulty**: Medium

#### Description
Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the value at a given timestamp.

#### Examples
Input: set("foo", "bar", 1), get("foo", 1) → "bar"

#### Approach
Store for each key a sorted list of (timestamp, value) pairs. Use binary search to find the latest time <= given timestamp.

#### Code
```python
from collections import defaultdict
import bisect

class TimeMap:
    def __init__(self):
        self.store = defaultdict(list)

    def set(self, key, value, timestamp):
        self.store[key].append((timestamp, value))

    def get(self, key, timestamp):
        values = self.store[key]
        i = bisect.bisect_right(values, (timestamp, chr(127)))
        return values[i-1][1] if i else ""
```


### 34. Median of Two Sorted Arrays
**Category**: Binary Search  
**Difficulty**: Hard

#### Description
Given two sorted arrays nums1 and nums2, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

#### Examples
Input: nums1 = [1,3], nums2 = [2]
Output: 2.0

#### Approach
Use binary search on the smaller array to partition both arrays such that left and right halves are balanced.

#### Code
```python
def findMedianSortedArrays(nums1, nums2):
    A, B = nums1, nums2
    total = len(A) + len(B)
    half = total // 2

    if len(B) < len(A):
        A, B = B, A

    l, r = 0, len(A) - 1
    while True:
        i = (l + r) // 2
        j = half - i - 2

        Aleft = A[i] if i >= 0 else float("-inf")
        Aright = A[i+1] if (i+1) < len(A) else float("inf")
        Bleft = B[j] if j >= 0 else float("-inf")
        Bright = B[j+1] if (j+1) < len(B) else float("inf")

        if Aleft <= Bright and Bleft <= Aright:
            if total % 2:
                return min(Aright, Bright)
            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
        elif Aleft > Bright:
            r = i - 1
        else:
            l = i + 1
```


## Linked List


### 35. Reverse Linked List
**Category**: Linked List  
**Difficulty**: Easy

#### Description
Given the head of a singly linked list, reverse the list, and return the reversed list.

#### Examples
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

#### Approach
Iterate through the list while reversing the pointers using prev and curr references.

#### Code
```python
def reverseList(head):
    prev = None
    curr = head
    while curr:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    return prev
```


### 36. Merge Two Sorted Lists
**Category**: Linked List  
**Difficulty**: Easy

#### Description
Merge two sorted linked lists and return it as a new sorted list.

#### Examples
Input: l1 = [1,2,4], l2 = [1,3,4]
Output: [1,1,2,3,4,4]

#### Approach
Iteratively compare nodes from both lists and merge them into a new list.

#### Code
```python
def mergeTwoLists(l1, l2):
    dummy = ListNode()
    tail = dummy
    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    tail.next = l1 or l2
    return dummy.next
```


### 37. Linked List Cycle
**Category**: Linked List  
**Difficulty**: Easy

#### Description
Given head, determine if the linked list has a cycle.

#### Examples
Input: head = [3,2,0,-4], pos = 1
Output: true

#### Approach
Use Floyd’s Tortoise and Hare algorithm (slow and fast pointers).

#### Code
```python
def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```


### 38. Reorder List
**Category**: Linked List  
**Difficulty**: Medium

#### Description
Reorder the given list from L0→L1→…→Ln-1→Ln to L0→Ln→L1→Ln-1→L2→…

#### Examples
Input: [1,2,3,4]
Output: [1,4,2,3]

#### Approach
Find the middle, reverse the second half, then merge two halves alternately.

#### Code
```python
def reorderList(head):
    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    second = slow.next
    slow.next = None
    prev = None
    while second:
        tmp = second.next
        second.next = prev
        prev = second
        second = tmp

    first, second = head, prev
    while second:
        tmp1, tmp2 = first.next, second.next
        first.next = second
        second.next = tmp1
        first = tmp1
        second = tmp2
```


### 39. Remove Nth Node From End of List
**Category**: Linked List  
**Difficulty**: Medium

#### Description
Given the head of a linked list, remove the nth node from the end and return its head.

#### Examples
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

#### Approach
Use two pointers. Move one ahead by n steps, then move both until the lead pointer hits the end.

#### Code
```python
def removeNthFromEnd(head, n):
    dummy = ListNode(0, head)
    fast = slow = dummy
    for _ in range(n):
        fast = fast.next
    while fast.next:
        fast = fast.next
        slow = slow.next
    slow.next = slow.next.next
    return dummy.next
```


### 40. Copy List With Random Pointer
**Category**: Linked List  
**Difficulty**: Medium

#### Description
A linked list is given where each node contains an additional random pointer. Return a deep copy of the list.

#### Examples
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]

#### Approach
Use a hash map to map original nodes to their copies, then assign next and random pointers.

#### Code
```python
def copyRandomList(head):
    old_to_new = {None: None}
    curr = head
    while curr:
        old_to_new[curr] = Node(curr.val)
        curr = curr.next
    curr = head
    while curr:
        old_to_new[curr].next = old_to_new[curr.next]
        old_to_new[curr].random = old_to_new[curr.random]
        curr = curr.next
    return old_to_new[head]
```


### 41. Add Two Numbers
**Category**: Linked List  
**Difficulty**: Medium

#### Description
Add two numbers represented by linked lists in reverse order.

#### Examples
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]

#### Approach
Traverse both lists, summing digits and carry. Construct new list as you go.

#### Code
```python
def addTwoNumbers(l1, l2):
    dummy = ListNode()
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        v1 = l1.val if l1 else 0
        v2 = l2.val if l2 else 0
        val = v1 + v2 + carry
        carry = val // 10
        curr.next = ListNode(val % 10)
        curr = curr.next
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    return dummy.next
```


### 42. Find The Duplicate Number
**Category**: Linked List  
**Difficulty**: Medium

#### Description
Given an array of integers nums containing n + 1 integers where each integer is between 1 and n inclusive, find the duplicate number.

#### Examples
Input: nums = [1,3,4,2,2]
Output: 2

#### Approach
Use Floyd’s Tortoise and Hare (cycle detection in linked list) algorithm.

#### Code
```python
def findDuplicate(nums):
    slow = fast = 0
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break
    slow2 = 0
    while slow != slow2:
        slow = nums[slow]
        slow2 = nums[slow2]
    return slow
```


### 43. LRU Cache
**Category**: Linked List  
**Difficulty**: Medium

#### Description
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

#### Examples
Input: ["LRUCache","put","put","get","put","get","put","get","get","get"]
Output: [null,null,null,1,null,-1,null,-1,3,4]

#### Approach
Use OrderedDict or combine a hashmap with a doubly linked list to manage ordering and fast access.

#### Code
```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```


### 44. Merge K Sorted Lists
**Category**: Linked List  
**Difficulty**: Hard

#### Description
Merge k sorted linked lists and return it as one sorted list.

#### Examples
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]

#### Approach
Use a heap (priority queue) to compare heads of each list efficiently.

#### Code
```python
import heapq

def mergeKLists(lists):
    min_heap = []
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(min_heap, (node.val, i, node))
    dummy = ListNode()
    curr = dummy
    while min_heap:
        val, i, node = heapq.heappop(min_heap)
        curr.next = node
        curr = curr.next
        if node.next:
            heapq.heappush(min_heap, (node.next.val, i, node.next))
    return dummy.next
```


### 45. Reverse Nodes In K Group
**Category**: Linked List  
**Difficulty**: Hard

#### Description
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

#### Examples
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

#### Approach
Count k nodes, reverse that chunk, and recurse or iteratively connect remaining parts.

#### Code
```python
def reverseKGroup(head, k):
    curr = head
    count = 0
    while curr and count < k:
        curr = curr.next
        count += 1
    if count == k:
        prev = self.reverseKGroup(curr, k)
        while count:
            tmp = head.next
            head.next = prev
            prev = head
            head = tmp
            count -= 1
        return prev
    return head
```


## Trees


### 46. Invert Binary Tree
**Category**: Trees  
**Difficulty**: Easy

#### Description
Invert a binary tree by flipping it around its center.

#### Examples
Input: [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]

#### Approach
Use recursion to swap left and right children for each node.

#### Code
```python
def invertTree(root):
    if not root:
        return None
    root.left, root.right = invertTree(root.right), invertTree(root.left)
    return root
```


### 47. Maximum Depth of Binary Tree
**Category**: Trees  
**Difficulty**: Easy

#### Description
Return the maximum depth of a binary tree.

#### Examples
Input: [3,9,20,null,null,15,7]
Output: 3

#### Approach
Use DFS to return 1 + max depth of left and right subtrees.

#### Code
```python
def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```


### 48. Diameter of Binary Tree
**Category**: Trees  
**Difficulty**: Easy

#### Description
Return the length of the longest path between any two nodes in a binary tree.

#### Examples
Input: [1,2,3,4,5]
Output: 3

#### Approach
Compute diameter by finding the max path through each node (left height + right height).

#### Code
```python
def diameterOfBinaryTree(root):
    diameter = 0
    def dfs(node):
        nonlocal diameter
        if not node:
            return 0
        left, right = dfs(node.left), dfs(node.right)
        diameter = max(diameter, left + right)
        return 1 + max(left, right)
    dfs(root)
    return diameter
```


### 49. Balanced Binary Tree
**Category**: Trees  
**Difficulty**: Easy

#### Description
Determine if a binary tree is height-balanced.

#### Examples
Input: [3,9,20,null,null,15,7]
Output: true

#### Approach
Check that heights of subtrees differ by no more than 1, using post-order traversal.

#### Code
```python
def isBalanced(root):
    def dfs(node):
        if not node:
            return (True, 0)
        left_bal, left_height = dfs(node.left)
        right_bal, right_height = dfs(node.right)
        balanced = left_bal and right_bal and abs(left_height - right_height) <= 1
        return (balanced, 1 + max(left_height, right_height))
    return dfs(root)[0]
```


### 50. Same Tree
**Category**: Trees  
**Difficulty**: Easy

#### Description
Check if two binary trees are the same in structure and node values.

#### Examples
Input: p = [1,2,3], q = [1,2,3]
Output: true

#### Approach
Recursively compare corresponding nodes of both trees.

#### Code
```python
def isSameTree(p, q):
    if not p and not q:
        return True
    if not p or not q or p.val != q.val:
        return False
    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)
```


### 51. Subtree of Another Tree
**Category**: Trees  
**Difficulty**: Easy

#### Description
Check if one tree is a subtree of another.

#### Examples
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true

#### Approach
Use isSameTree function and traverse root to check all possible subtree matches.

#### Code
```python
def isSubtree(root, subRoot):
    if not root:
        return False
    if isSameTree(root, subRoot):
        return True
    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)

def isSameTree(p, q):
    if not p and not q:
        return True
    if not p or not q or p.val != q.val:
        return False
    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)
```


### 52. Lowest Common Ancestor of a Binary Search Tree
**Category**: Trees  
**Difficulty**: Easy

#### Description
Given a BST, find the lowest common ancestor (LCA) of two given nodes.

#### Examples
Input: root = [6,2,8,0,4,7,9], p = 2, q = 8
Output: 6

#### Approach
Use BST property: if p and q are on different sides, current node is LCA.

#### Code
```python
def lowestCommonAncestor(root, p, q):
    if p.val < root.val and q.val < root.val:
        return lowestCommonAncestor(root.left, p, q)
    elif p.val > root.val and q.val > root.val:
        return lowestCommonAncestor(root.right, p, q)
    else:
        return root
```


### 53. Binary Tree Level Order Traversal
**Category**: Trees  
**Difficulty**: Medium

#### Description
Return the level order traversal of a binary tree's nodes' values.

#### Examples
Input: [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]

#### Approach
Use a queue (BFS) and process nodes level by level.

#### Code
```python
from collections import deque

def levelOrder(root):
    res = []
    q = deque([root])
    while q:
        level = []
        for _ in range(len(q)):
            node = q.popleft()
            if node:
                level.append(node.val)
                q.append(node.left)
                q.append(node.right)
        if level:
            res.append(level)
    return res
```


### 54. Binary Tree Right Side View
**Category**: Trees  
**Difficulty**: Medium

#### Description
Given a binary tree, return the values of the nodes you can see ordered from top to bottom.

#### Examples
Input: [1,2,3,null,5,null,4]
Output: [1,3,4]

#### Approach
Use BFS and take the last element of each level.

#### Code
```python
def rightSideView(root):
    if not root:
        return []
    res, queue = [], deque([root])
    while queue:
        rightmost = None
        for _ in range(len(queue)):
            node = queue.popleft()
            if node:
                rightmost = node.val
                queue.append(node.left)
                queue.append(node.right)
        if rightmost is not None:
            res.append(rightmost)
    return res
```


### 55. Count Good Nodes In Binary Tree
**Category**: Trees  
**Difficulty**: Medium

#### Description
Count the number of good nodes in a binary tree. A node is good if it's the largest value on the path from root to that node.

#### Examples
Input: [3,1,4,3,null,1,5]
Output: 4

#### Approach
Use DFS and track the max value seen so far on the path to each node.

#### Code
```python
def goodNodes(root):
    def dfs(node, max_val):
        if not node:
            return 0
        res = 1 if node.val >= max_val else 0
        max_val = max(max_val, node.val)
        res += dfs(node.left, max_val)
        res += dfs(node.right, max_val)
        return res
    return dfs(root, root.val)
```


### 56. Validate Binary Search Tree
**Category**: Trees  
**Difficulty**: Medium

#### Description
Determine if a given binary tree is a valid binary search tree (BST).

#### Examples
Input: [2,1,3]
Output: true

#### Approach
Recursively check that each node value lies within valid min/max bounds.

#### Code
```python
def isValidBST(root):
    def validate(node, low, high):
        if not node:
            return True
        if not (low < node.val < high):
            return False
        return validate(node.left, low, node.val) and validate(node.right, node.val, high)
    return validate(root, float('-inf'), float('inf'))
```


### 57. Kth Smallest Element In a BST
**Category**: Trees  
**Difficulty**: Medium

#### Description
Given the root of a binary search tree and an integer k, return the kth smallest element.

#### Examples
Input: [3,1,4,null,2], k = 1
Output: 1

#### Approach
Use in-order traversal which gives nodes in ascending order. Return the kth visited node.

#### Code
```python
def kthSmallest(root, k):
    stack = []
    while True:
        while root:
            stack.append(root)
            root = root.left
        root = stack.pop()
        k -= 1
        if k == 0:
            return root.val
        root = root.right
```


### 58. Construct Binary Tree From Preorder And Inorder Traversal
**Category**: Trees  
**Difficulty**: Medium

#### Description
Build a binary tree from preorder and inorder traversal arrays.

#### Examples
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

#### Approach
Use recursion: root is the first preorder element, find its index in inorder to split left/right subtrees.

#### Code
```python
def buildTree(preorder, inorder):
    inorder_map = {val: i for i, val in enumerate(inorder)}
    def helper(pre_left, pre_right, in_left):
        if pre_left > pre_right:
            return None
        root_val = preorder[pre_left]
        root = TreeNode(root_val)
        in_root_idx = inorder_map[root_val]
        left_tree_size = in_root_idx - in_left
        root.left = helper(pre_left + 1, pre_left + left_tree_size, in_left)
        root.right = helper(pre_left + left_tree_size + 1, pre_right, in_root_idx + 1)
        return root
    return helper(0, len(preorder) - 1, 0)
```


### 59. Binary Tree Maximum Path Sum
**Category**: Trees  
**Difficulty**: Hard

#### Description
Return the maximum path sum of any path in the tree (not necessarily root-to-leaf).

#### Examples
Input: [1,2,3]
Output: 6

#### Approach
DFS post-order traversal to compute max path sum at each node including both children, track global max.

#### Code
```python
def maxPathSum(root):
    max_sum = float('-inf')
    def dfs(node):
        nonlocal max_sum
        if not node:
            return 0
        left = max(dfs(node.left), 0)
        right = max(dfs(node.right), 0)
        max_sum = max(max_sum, node.val + left + right)
        return node.val + max(left, right)
    dfs(root)
    return max_sum
```


### 60. Serialize And Deserialize Binary Tree
**Category**: Trees  
**Difficulty**: Hard

#### Description
Design an algorithm to serialize and deserialize a binary tree.

#### Examples
Input: root = [1,2,3,null,null,4,5]
Serialized Output: '1,2,#,#,3,4,#,#,5,#,#'

#### Approach
Use preorder traversal with '#' as null placeholder. For deserialization, recursively reconstruct using a queue.

#### Code
```python
class Codec:
    def serialize(self, root):
        vals = []
        def dfs(node):
            if not node:
                vals.append("#")
                return
            vals.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return ",".join(vals)

    def deserialize(self, data):
        vals = iter(data.split(","))
        def dfs():
            val = next(vals)
            if val == "#":
                return None
            node = TreeNode(int(val))
            node.left = dfs()
            node.right = dfs()
            return node
        return dfs()
```


## Heap / Priority Queue


### 61. Kth Largest Element in a Stream
**Category**: Heap / Priority Queue  
**Difficulty**: Easy

#### Description
Design a class to find the kth largest element in a stream. It should support adding new numbers and returning the kth largest element.

#### Examples
Input: k = 3, nums = [4,5,8,2]
add(3) → 4
add(5) → 5
add(10) → 5

#### Approach
Use a min heap of size k. Keep the k largest elements and return heap[0].

#### Code
```python
import heapq

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.heap = nums
        heapq.heapify(self.heap)
        while len(self.heap) > k:
            heapq.heappop(self.heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.heap, val)
        if len(self.heap) > self.k:
            heapq.heappop(self.heap)
        return self.heap[0]
```


### 62. Last Stone Weight
**Category**: Heap / Priority Queue  
**Difficulty**: Easy

#### Description
Given a list of stones with weights, repeatedly smash the two heaviest until one or none is left. Return the weight of the last stone (or 0).

#### Examples
Input: stones = [2,7,4,1,8,1]
Output: 1

#### Approach
Use a max heap by negating the weights. Pop top two, smash, push back difference if any.

#### Code
```python
import heapq

def lastStoneWeight(stones):
    stones = [-s for s in stones]
    heapq.heapify(stones)
    while len(stones) > 1:
        first = -heapq.heappop(stones)
        second = -heapq.heappop(stones)
        if first != second:
            heapq.heappush(stones, -(first - second))
    return -stones[0] if stones else 0
```


### 63. K Closest Points to Origin
**Category**: Heap / Priority Queue  
**Difficulty**: Medium

#### Description
Given a list of points, return the k closest points to the origin (0, 0).

#### Examples
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]

#### Approach
Use a max heap of size k, storing (distance, point). Pop when size exceeds k.

#### Code
```python
import heapq

def kClosest(points, k):
    max_heap = []
    for x, y in points:
        dist = -(x**2 + y**2)
        heapq.heappush(max_heap, (dist, x, y))
        if len(max_heap) > k:
            heapq.heappop(max_heap)
    return [(x, y) for _, x, y in max_heap]
```


### 64. Kth Largest Element In An Array
**Category**: Heap / Priority Queue  
**Difficulty**: Medium

#### Description
Find the kth largest element in an unsorted array. Note that it is the kth largest element in sorted order, not the kth distinct element.

#### Examples
Input: [3,2,1,5,6,4], k = 2
Output: 5

#### Approach
Use a min heap of size k to keep track of k largest elements. Return heap[0].

#### Code
```python
import heapq

def findKthLargest(nums, k):
    heap = nums[:k]
    heapq.heapify(heap)
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heappushpop(heap, num)
    return heap[0]
```


### 65. Task Scheduler
**Category**: Heap / Priority Queue  
**Difficulty**: Medium

#### Description
You are given a list of tasks and a cooling interval. Schedule the tasks to minimize total time with the constraint that the same task must be at least n intervals apart.

#### Examples
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8

#### Approach
Use a max heap for task frequency. Simulate rounds of size n+1, refill the heap after each round.

#### Code
```python
from collections import Counter
import heapq

def leastInterval(tasks, n):
    count = Counter(tasks)
    max_heap = [-c for c in count.values()]
    heapq.heapify(max_heap)
    time = 0
    while max_heap:
        i, temp = 0, []
        while i <= n:
            if max_heap:
                val = heapq.heappop(max_heap)
                if val + 1 < 0:
                    temp.append(val + 1)
            time += 1
            if not max_heap and not temp:
                break
            i += 1
        for item in temp:
            heapq.heappush(max_heap, item)
    return time
```


### 66. Design Twitter
**Category**: Heap / Priority Queue  
**Difficulty**: Medium

#### Description
Design a simplified version of Twitter with postTweet, getNewsFeed, follow, and unfollow.

#### Examples
postTweet(1, 5), getNewsFeed(1), follow(1, 2), postTweet(2, 6), getNewsFeed(1)

#### Approach
Use a heap to keep track of most recent tweets from followed users. Maintain user tweet lists with timestamps.

#### Code
```python
import heapq
from collections import defaultdict, deque

class Twitter:
    def __init__(self):
        self.time = 0
        self.tweets = defaultdict(deque)
        self.follows = defaultdict(set)

    def postTweet(self, userId, tweetId):
        self.tweets[userId].appendleft((self.time, tweetId))
        self.time += 1

    def getNewsFeed(self, userId):
        self.follows[userId].add(userId)
        heap, res = [], []
        for uid in self.follows[userId]:
            for tweet in list(self.tweets[uid])[:10]:
                heapq.heappush(heap, tweet)
        return [tweetId for _, tweetId in heapq.nlargest(10, heap)]

    def follow(self, followerId, followeeId):
        self.follows[followerId].add(followeeId)

    def unfollow(self, followerId, followeeId):
        if followeeId in self.follows[followerId] and followeeId != followerId:
            self.follows[followerId].remove(followeeId)
```


### 67. Find Median From Data Stream
**Category**: Heap / Priority Queue  
**Difficulty**: Hard

#### Description
Design a data structure that supports adding numbers and finding the median of the current data stream.

#### Examples
Input: [1, 2, 3]
Output: Median is 2

#### Approach
Use two heaps: max heap for lower half, min heap for upper half. Balance heaps and compute median from tops.

#### Code
```python
import heapq

class MedianFinder:
    def __init__(self):
        self.small = []  # Max heap (invert values)
        self.large = []  # Min heap

    def addNum(self, num):
        heapq.heappush(self.small, -num)
        if self.small and self.large and (-self.small[0]) > self.large[0]:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.small) > len(self.large) + 1:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.large) > len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    def findMedian(self):
        if len(self.small) > len(self.large):
            return -self.small[0]
        return (-self.small[0] + self.large[0]) / 2
```


## Backtracking


### 68. Subsets
**Category**: Backtracking  
**Difficulty**: Medium

#### Description
Given an integer array nums, return all possible subsets (the power set).

#### Examples
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

#### Approach
Use DFS to explore two choices at each step — include or exclude the current element.

#### Code
```python
def subsets(nums):
    res = []
    def backtrack(start, path):
        res.append(path[:])
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()
    backtrack(0, [])
    return res
```


### 69. Combination Sum
**Category**: Backtracking  
**Difficulty**: Medium

#### Description
Return all unique combinations where the candidate numbers sum to the target. Reuse numbers allowed.

#### Examples
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]

#### Approach
Use DFS and backtrack with current path and remaining target. Explore same index for reuse.

#### Code
```python
def combinationSum(candidates, target):
    res = []
    def backtrack(start, path, total):
        if total == target:
            res.append(path[:])
            return
        if total > target:
            return
        for i in range(start, len(candidates)):
            path.append(candidates[i])
            backtrack(i, path, total + candidates[i])
            path.pop()
    backtrack(0, [], 0)
    return res
```


### 70. Combination Sum II
**Category**: Backtracking  
**Difficulty**: Medium

#### Description
Each number in candidates may only be used once. Return all unique combinations that sum to target.

#### Examples
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: [[1,1,6],[1,2,5],[1,7],[2,6]]

#### Approach
Sort input and use DFS. Skip duplicates. Track used indices to avoid reuse.

#### Code
```python
def combinationSum2(candidates, target):
    res = []
    candidates.sort()
    def backtrack(start, path, total):
        if total == target:
            res.append(path[:])
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            if total + candidates[i] > target:
                break
            path.append(candidates[i])
            backtrack(i + 1, path, total + candidates[i])
            path.pop()
    backtrack(0, [], 0)
    return res
```


### 71. Permutations
**Category**: Backtracking  
**Difficulty**: Medium

#### Description
Return all the permutations of the given list of numbers.

#### Examples
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

#### Approach
Use backtracking with a visited set to generate all permutations.

#### Code
```python
def permute(nums):
    res = []
    def backtrack(path, used):
        if len(path) == len(nums):
            res.append(path[:])
            return
        for i in range(len(nums)):
            if i in used:
                continue
            used.add(i)
            path.append(nums[i])
            backtrack(path, used)
            path.pop()
            used.remove(i)
    backtrack([], set())
    return res
```


### 72. Subsets II
**Category**: Backtracking  
**Difficulty**: Medium

#### Description
Return all possible subsets (the power set). The solution set must not contain duplicate subsets.

#### Examples
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]

#### Approach
Sort the array and skip duplicates in recursion.

#### Code
```python
def subsetsWithDup(nums):
    res = []
    nums.sort()
    def backtrack(start, path):
        res.append(path[:])
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[i - 1]:
                continue
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()
    backtrack(0, [])
    return res
```


### 73. Word Search
**Category**: Backtracking  
**Difficulty**: Medium

#### Description
Given a board and a word, return true if the word exists in the grid. Letters must be adjacent and not reused.

#### Examples
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true

#### Approach
Use DFS to explore each cell. Mark visited cells by modifying the board temporarily.

#### Code
```python
def exist(board, word):
    rows, cols = len(board), len(board[0])
    def dfs(r, c, i):
        if i == len(word):
            return True
        if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] != word[i]:
            return False
        tmp, board[r][c] = board[r][c], '#'
        found = dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1)
        board[r][c] = tmp
        return found
    for r in range(rows):
        for c in range(cols):
            if dfs(r, c, 0):
                return True
    return False
```


### 74. Palindrome Partitioning
**Category**: Backtracking  
**Difficulty**: Medium

#### Description
Partition s such that every substring is a palindrome. Return all such possible partitionings.

#### Examples
Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]

#### Approach
Use backtracking. At each index, try all palindromic substrings and recurse from the next index.

#### Code
```python
def partition(s):
    res = []
    def is_palindrome(sub):
        return sub == sub[::-1]
    def backtrack(start, path):
        if start == len(s):
            res.append(path[:])
            return
        for end in range(start + 1, len(s) + 1):
            if is_palindrome(s[start:end]):
                path.append(s[start:end])
                backtrack(end, path)
                path.pop()
    backtrack(0, [])
    return res
```


### 75. Letter Combinations of a Phone Number
**Category**: Backtracking  
**Difficulty**: Medium

#### Description
Return all letter combinations that the number could represent.

#### Examples
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

#### Approach
Use backtracking and map digits to characters using a dictionary.

#### Code
```python
def letterCombinations(digits):
    if not digits:
        return []
    phone = {
        '2': 'abc', '3': 'def', '4': 'ghi',
        '5': 'jkl', '6': 'mno', '7': 'pqrs',
        '8': 'tuv', '9': 'wxyz'
    }
    res = []
    def backtrack(index, path):
        if index == len(digits):
            res.append("".join(path))
            return
        for char in phone[digits[index]]:
            path.append(char)
            backtrack(index + 1, path)
            path.pop()
    backtrack(0, [])
    return res
```


### 76. N Queens
**Category**: Backtracking  
**Difficulty**: Hard

#### Description
The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.

#### Examples
Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."]]

#### Approach
Backtrack row by row. Track columns and diagonals with sets to avoid conflicts.

#### Code
```python
def solveNQueens(n):
    res = []
    cols, pos_diag, neg_diag = set(), set(), set()
    board = [["."] * n for _ in range(n)]

    def backtrack(r):
        if r == n:
            res.append(["".join(row) for row in board])
            return
        for c in range(n):
            if c in cols or (r + c) in pos_diag or (r - c) in neg_diag:
                continue
            cols.add(c)
            pos_diag.add(r + c)
            neg_diag.add(r - c)
            board[r][c] = "Q"
            backtrack(r + 1)
            cols.remove(c)
            pos_diag.remove(r + c)
            neg_diag.remove(r - c)
            board[r][c] = "."
    backtrack(0)
    return res
```


## Tries


### 77. Implement Trie Prefix Tree
**Category**: Tries  
**Difficulty**: Medium

#### Description
Implement a trie with insert, search, and startsWith methods.

#### Examples
Input: insert("apple"), search("apple"), search("app"), startsWith("app")
Output: true, false, true

#### Approach
Use a tree structure where each node is a dictionary. Track end of word with a special flag.

#### Code
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.end_of_word = True

    def search(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return node.end_of_word

    def startsWith(self, prefix):
        node = self.root
        for ch in prefix:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return True
```


### 78. Design Add And Search Words Data Structure
**Category**: Tries  
**Difficulty**: Medium

#### Description
Design a data structure that supports adding new words and searching for a word including wildcards '.'

#### Examples
Input: addWord("bad"), search("b.d")
Output: true

#### Approach
Use a trie. For search, implement DFS to handle the wildcard '.' by exploring all children.

#### Code
```python
class WordDictionary:
    def __init__(self):
        self.trie = {}

    def addWord(self, word):
        node = self.trie
        for c in word:
            node = node.setdefault(c, {})
        node['$'] = True

    def search(self, word):
        def dfs(j, node):
            for i in range(j, len(word)):
                c = word[i]
                if c == '.':
                    return any(dfs(i + 1, child) for child in node.values() if child != True)
                if c not in node:
                    return False
                node = node[c]
            return '$' in node
        return dfs(0, self.trie)
```


### 79. Word Search II
**Category**: Tries  
**Difficulty**: Hard

#### Description
Given a 2D board and a list of words, return all words that exist in the board using trie + DFS.

#### Examples
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["oath","eat"]

#### Approach
Build a trie of the words. For each cell on the board, do DFS with pruning using the trie structure.

#### Code
```python
def findWords(board, words):
    trie = {}
    for word in words:
        node = trie
        for c in word:
            node = node.setdefault(c, {})
        node['$'] = word

    res = []
    rows, cols = len(board), len(board[0])

    def dfs(r, c, parent):
        letter = board[r][c]
        curr_node = parent[letter]
        word_match = curr_node.pop('$', False)
        if word_match:
            res.append(word_match)
        board[r][c] = '#'
        for dr, dc in [(0,1),(1,0),(0,-1),(-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] in curr_node:
                dfs(nr, nc, curr_node)
        board[r][c] = letter
        if not curr_node:
            parent.pop(letter)

    for r in range(rows):
        for c in range(cols):
            if board[r][c] in trie:
                dfs(r, c, trie)

    return res
```


## Graphs


### 80. Number of Islands
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Given a 2D grid map of '1's (land) and '0's (water), count the number of islands.

#### Examples
Input: grid = [["1","1","0","0"],["1","1","0","0"],["0","0","1","0"],["0","0","0","1"]]
Output: 3

#### Approach
Use DFS or BFS to mark all land cells of each island. Count the number of times a new DFS starts.

#### Code
```python
def numIslands(grid):
    if not grid:
        return 0
    rows, cols = len(grid), len(grid[0])
    def dfs(r, c):
        if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0':
            return
        grid[r][c] = '0'
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    count = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                dfs(r, c)
                count += 1
    return count
```


### 81. Max Area of Island
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Return the area of the largest island in the grid.

#### Examples
Input: [[0,0,1,0],[0,1,1,0],[0,0,0,0],[1,1,0,0]]
Output: 4

#### Approach
Use DFS to explore and count the size of each island. Track the maximum area encountered.

#### Code
```python
def maxAreaOfIsland(grid):
    rows, cols = len(grid), len(grid[0])
    def dfs(r, c):
        if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0:
            return 0
        grid[r][c] = 0
        return 1 + dfs(r+1,c) + dfs(r-1,c) + dfs(r,c+1) + dfs(r,c-1)
    return max(dfs(r, c) for r in range(rows) for c in range(cols))
```


### 82. Clone Graph
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.

#### Examples
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]

#### Approach
Use DFS with a hashmap to map original nodes to cloned nodes to prevent revisits.

#### Code
```python
def cloneGraph(node):
    if not node:
        return None
    old_to_new = {}
    def dfs(n):
        if n in old_to_new:
            return old_to_new[n]
        copy = Node(n.val)
        old_to_new[n] = copy
        for neighbor in n.neighbors:
            copy.neighbors.append(dfs(neighbor))
        return copy
    return dfs(node)
```


### 83. Walls And Gates
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Fill each empty room with the distance to its nearest gate. Walls are -1, gates are 0, and empty rooms are INF (2^31 - 1).

#### Examples
Input: rooms = [[2147483647,-1,0,2147483647],...]
Output: [[3,-1,0,1],...]

#### Approach
Use BFS starting from all gates simultaneously, propagating distances outward.

#### Code
```python
from collections import deque

def wallsAndGates(rooms):
    rows, cols = len(rooms), len(rooms[0])
    q = deque()
    for r in range(rows):
        for c in range(cols):
            if rooms[r][c] == 0:
                q.append((r, c))
    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and rooms[nr][nc] == 2**31 - 1:
                rooms[nr][nc] = rooms[r][c] + 1
                q.append((nr, nc))
```


### 84. Rotting Oranges
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Determine the minimum number of minutes that must elapse until no cell has a fresh orange.

#### Examples
Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4

#### Approach
Use BFS starting from all rotten oranges, spreading rot to adjacent fresh ones each minute.

#### Code
```python
from collections import deque

def orangesRotting(grid):
    rows, cols = len(grid), len(grid[0])
    q = deque()
    fresh = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                q.append((r, c))
            elif grid[r][c] == 1:
                fresh += 1
    time = 0
    while q and fresh > 0:
        for _ in range(len(q)):
            r, c = q.popleft()
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                    grid[nr][nc] = 2
                    fresh -= 1
                    q.append((nr, nc))
        time += 1
    return time if fresh == 0 else -1
```


### 85. Pacific Atlantic Water Flow
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Return the list of coordinates from which water can flow to both the Pacific and Atlantic oceans.

#### Examples
Input: heights = [[1,2,2,3,5],...]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]

#### Approach
Do DFS/BFS from all Pacific-border and Atlantic-border cells, and find intersection.

#### Code
```python
def pacificAtlantic(heights):
    rows, cols = len(heights), len(heights[0])
    pacific, atlantic = set(), set()

    def dfs(r, c, visited, prev_height):
        if (r, c) in visited or r < 0 or c < 0 or r >= rows or c >= cols or heights[r][c] < prev_height:
            return
        visited.add((r, c))
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            dfs(r+dr, c+dc, visited, heights[r][c])

    for r in range(rows):
        dfs(r, 0, pacific, heights[r][0])
        dfs(r, cols-1, atlantic, heights[r][cols-1])
    for c in range(cols):
        dfs(0, c, pacific, heights[0][c])
        dfs(rows-1, c, atlantic, heights[rows-1][c])
    return list(pacific & atlantic)
```


### 86. Surrounded Regions
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Capture all regions surrounded by 'X'. Any 'O' that is not on the border and not connected to a border 'O' should be flipped.

#### Examples
Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]

#### Approach
Use DFS to mark 'O's connected to borders. Then flip all unmarked 'O's.

#### Code
```python
def solve(board):
    if not board:
        return
    rows, cols = len(board), len(board[0])
    def dfs(r, c):
        if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] != 'O':
            return
        board[r][c] = 'T'
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            dfs(r+dr, c+dc)

    for r in range(rows):
        dfs(r, 0)
        dfs(r, cols-1)
    for c in range(cols):
        dfs(0, c)
        dfs(rows-1, c)

    for r in range(rows):
        for c in range(cols):
            if board[r][c] == 'O':
                board[r][c] = 'X'
            elif board[r][c] == 'T':
                board[r][c] = 'O'
```


### 87. Course Schedule
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Return true if you can finish all courses given prerequisites as a directed graph (detect cycle).

#### Examples
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true

#### Approach
Use DFS or Kahn’s algorithm to detect cycles in the directed graph.

#### Code
```python
def canFinish(numCourses, prerequisites):
    graph = [[] for _ in range(numCourses)]
    for a, b in prerequisites:
        graph[a].append(b)
    visited = [0] * numCourses
    def dfs(node):
        if visited[node] == -1:
            return False
        if visited[node] == 1:
            return True
        visited[node] = -1
        for nei in graph[node]:
            if not dfs(nei):
                return False
        visited[node] = 1
        return True
    return all(dfs(i) for i in range(numCourses))
```


### 88. Course Schedule II
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Return the ordering of courses to take if possible (topological sort).

#### Examples
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]

#### Approach
Use Kahn’s algorithm (BFS with in-degree array) for topological sort.

#### Code
```python
from collections import deque

def findOrder(numCourses, prerequisites):
    graph = [[] for _ in range(numCourses)]
    in_degree = [0] * numCourses
    for a, b in prerequisites:
        graph[b].append(a)
        in_degree[a] += 1
    q = deque([i for i in range(numCourses) if in_degree[i] == 0])
    res = []
    while q:
        node = q.popleft()
        res.append(node)
        for nei in graph[node]:
            in_degree[nei] -= 1
            if in_degree[nei] == 0:
                q.append(nei)
    return res if len(res) == numCourses else []
```


### 89. Graph Valid Tree
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Given n nodes labeled from 0 to n-1 and a list of edges, check if it's a valid tree.

#### Examples
Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true

#### Approach
Check if the graph is acyclic and connected using DFS or Union-Find.

#### Code
```python
def validTree(n, edges):
    if len(edges) != n - 1:
        return False
    parent = [i for i in range(n)]
    def find(x):
        while x != parent[x]:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x
    for a, b in edges:
        pa, pb = find(a), find(b)
        if pa == pb:
            return False
        parent[pa] = pb
    return True
```


### 90. Number of Connected Components In An Undirected Graph
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Return the number of connected components in an undirected graph.

#### Examples
Input: n = 5, edges = [[0,1],[1,2],[3,4]]
Output: 2

#### Approach
Use DFS/BFS to mark visited nodes and count separate components.

#### Code
```python
def countComponents(n, edges):
    graph = [[] for _ in range(n)]
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)
    visited = set()
    def dfs(node):
        for nei in graph[node]:
            if nei not in visited:
                visited.add(nei)
                dfs(nei)
    count = 0
    for i in range(n):
        if i not in visited:
            visited.add(i)
            dfs(i)
            count += 1
    return count
```


### 91. Redundant Connection
**Category**: Graphs  
**Difficulty**: Medium

#### Description
Find the redundant connection in a graph that would form a cycle if added.

#### Examples
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]

#### Approach
Use Union-Find. If two nodes already share the same root, the edge is redundant.

#### Code
```python
def findRedundantConnection(edges):
    parent = [i for i in range(len(edges) + 1)]
    def find(x):
        while x != parent[x]:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x
    for a, b in edges:
        pa, pb = find(a), find(b)
        if pa == pb:
            return [a, b]
        parent[pa] = pb
```


### 92. Word Ladder
**Category**: Graphs  
**Difficulty**: Hard

#### Description
Return the shortest transformation sequence from beginWord to endWord, changing one letter at a time and using words from the wordList.

#### Examples
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5

#### Approach
Use BFS with a queue and generate all valid 1-letter transformations for each word.

#### Code
```python
from collections import deque

def ladderLength(beginWord, endWord, wordList):
    wordSet = set(wordList)
    if endWord not in wordSet:
        return 0
    q = deque([(beginWord, 1)])
    while q:
        word, steps = q.popleft()
        if word == endWord:
            return steps
        for i in range(len(word)):
            for c in "abcdefghijklmnopqrstuvwxyz":
                newWord = word[:i] + c + word[i+1:]
                if newWord in wordSet:
                    wordSet.remove(newWord)
                    q.append((newWord, steps + 1))
    return 0
```


## Advanced Graphs


### 93. Network Delay Time
**Category**: Advanced Graphs  
**Difficulty**: Medium

#### Description
You are given a network of n nodes, represented as a list of travel times times, where times[i] = (u, v, w) represents a time w it takes for a signal to travel from node u to v. Return how long it takes for all nodes to receive the signal from a starting node k.

#### Examples
Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2

#### Approach
Use Dijkstra's algorithm with a priority queue (heapq). Track minimum time to each node, and return the maximum time.

#### Code
```python
import heapq
def networkDelayTime(times, n, k):
    graph = {i: [] for i in range(1, n + 1)}
    for u, v, w in times:
        graph[u].append((v, w))
    minHeap = [(0, k)]
    visited = {}
    while minHeap:
        time, node = heapq.heappop(minHeap)
        if node in visited:
            continue
        visited[node] = time
        for nei, wt in graph[node]:
            if nei not in visited:
                heapq.heappush(minHeap, (time + wt, nei))
    return max(visited.values()) if len(visited) == n else -1
```


### 94. Reconstruct Itinerary
**Category**: Advanced Graphs  
**Difficulty**: Hard

#### Description
Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in lexical order.

#### Examples
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]

#### Approach
Build a graph with min-heaps to maintain lexical order. Use DFS to traverse and backtrack when stuck.

#### Code
```python
from collections import defaultdict
import heapq

def findItinerary(tickets):
    graph = defaultdict(list)
    for src, dst in sorted(tickets)[::-1]:
        graph[src].append(dst)
    
    res = []
    def dfs(node):
        while graph[node]:
            dfs(graph[node].pop())
        res.append(node)
    dfs("JFK")
    return res[::-1]
```


### 95. Min Cost to Connect All Points
**Category**: Advanced Graphs  
**Difficulty**: Medium

#### Description
Given a 2D array points where points[i] = [xi, yi], return the minimum cost to make all points connected. Cost between two points is Manhattan distance.

#### Examples
Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20

#### Approach
Use Prim’s algorithm for Minimum Spanning Tree. Use a priority queue to track minimum cost edges.

#### Code
```python
import heapq

def minCostConnectPoints(points):
    n = len(points)
    visited = set()
    minHeap = [(0, 0)]  # cost, point_index
    res = 0
    while len(visited) < n:
        cost, i = heapq.heappop(minHeap)
        if i in visited:
            continue
        visited.add(i)
        res += cost
        for j in range(n):
            if j not in visited:
                new_cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
                heapq.heappush(minHeap, (new_cost, j))
    return res
```


### 96. Swim In Rising Water
**Category**: Advanced Graphs  
**Difficulty**: Hard

#### Description
You are given an n x n integer matrix grid where each value represents elevation. Return the minimum time to reach the bottom right corner, assuming you can only swim when elevation <= time.

#### Examples
Input: grid = [[0,2],[1,3]]
Output: 3

#### Approach
Use Dijkstra’s algorithm with a priority queue to minimize the maximum elevation encountered.

#### Code
```python
import heapq

def swimInWater(grid):
    n = len(grid)
    minHeap = [(grid[0][0], 0, 0)]
    visited = set()
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    
    while minHeap:
        t, r, c = heapq.heappop(minHeap)
        if (r, c) in visited:
            continue
        visited.add((r, c))
        if r == n - 1 and c == n - 1:
            return t
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited:
                heapq.heappush(minHeap, (max(t, grid[nr][nc]), nr, nc))
```


### 97. Alien Dictionary
**Category**: Advanced Graphs  
**Difficulty**: Hard

#### Description
Given a list of words sorted in alien dictionary order, return a string that represents the order of characters.

#### Examples
Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"

#### Approach
Build a graph of characters based on adjacent word comparisons. Perform topological sort (Kahn’s algorithm).

#### Code
```python
from collections import defaultdict, deque

def alienOrder(words):
    adj = defaultdict(set)
    in_degree = {c: 0 for word in words for c in word}
    
    for i in range(len(words) - 1):
        w1, w2 = words[i], words[i+1]
        if len(w1) > len(w2) and w1.startswith(w2):
            return ""
        for c1, c2 in zip(w1, w2):
            if c1 != c2:
                if c2 not in adj[c1]:
                    adj[c1].add(c2)
                    in_degree[c2] += 1
                break
    
    queue = deque([c for c in in_degree if in_degree[c] == 0])
    res = []
    while queue:
        c = queue.popleft()
        res.append(c)
        for nei in adj[c]:
            in_degree[nei] -= 1
            if in_degree[nei] == 0:
                queue.append(nei)
    
    return "".join(res) if len(res) == len(in_degree) else ""
```


### 98. Cheapest Flights Within K Stops
**Category**: Advanced Graphs  
**Difficulty**: Medium

#### Description
You are given flights and need to find the cheapest price from source to destination with at most k stops.

#### Examples
Input: n = 4, flights = [[0,1,100],[1,2,100],[2,3,100],[0,3,500]], src = 0, dst = 3, k = 1
Output: 500

#### Approach
Use BFS with a priority queue, tracking cost and number of stops. Skip if stops exceed k.

#### Code
```python
import heapq
from collections import defaultdict

def findCheapestPrice(n, flights, src, dst, k):
    graph = defaultdict(list)
    for u, v, w in flights:
        graph[u].append((v, w))
    minHeap = [(0, src, 0)]
    
    while minHeap:
        cost, u, stops = heapq.heappop(minHeap)
        if u == dst:
            return cost
        if stops > k:
            continue
        for v, w in graph[u]:
            heapq.heappush(minHeap, (cost + w, v, stops + 1))
    return -1
```


## 1-D Dynamic Programming


### 99. Climbing Stairs
**Category**: 1-D Dynamic Programming  
**Difficulty**: Easy

#### Description
You are climbing a staircase. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

#### Examples
Input: n = 2
Output: 2
Explanation: 1 step + 1 step, or 2 steps

#### Approach
Classic Fibonacci problem. Use bottom-up DP: dp[i] = dp[i-1] + dp[i-2].

#### Code
```python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b
```


### 100. Min Cost Climbing Stairs
**Category**: 1-D Dynamic Programming  
**Difficulty**: Easy

#### Description
Each step has a cost. You can climb one or two steps. Find the minimum cost to reach the top.

#### Examples
Input: cost = [10, 15, 20]
Output: 15
Explanation: Climb 1 step to 15, then 2 steps to top

#### Approach
Use dp[i] = cost[i] + min(dp[i-1], dp[i-2]). Start from the base and go up.

#### Code
```python
def minCostClimbingStairs(cost):
    for i in range(2, len(cost)):
        cost[i] += min(cost[i - 1], cost[i - 2])
    return min(cost[-1], cost[-2])
```


### 101. House Robber
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
You cannot rob two adjacent houses. Find the maximum amount you can rob.

#### Examples
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob 2 + 9 + 1

#### Approach
Bottom-up DP: dp[i] = max(dp[i-1], dp[i-2] + nums[i])

#### Code
```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) <= 2:
        return max(nums)
    dp = [0]*len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    return dp[-1]
```


### 102. House Robber II
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Same as House Robber but houses are in a circle. First and last cannot be robbed together.

#### Examples
Input: nums = [2,3,2]
Output: 3

#### Approach
Run House Robber DP twice: once excluding first, once excluding last. Return max of the two.

#### Code
```python
def rob(nums):
    def rob_line(nums):
        if len(nums) <= 2:
            return max(nums)
        dp = [0]*len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        return dp[-1]

    if len(nums) == 1:
        return nums[0]
    return max(rob_line(nums[1:]), rob_line(nums[:-1]))
```


### 103. Longest Palindromic Substring
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Given a string, return the longest palindromic substring in it.

#### Examples
Input: s = "babad"
Output: "bab"

#### Approach
Expand around center technique: try to expand palindrome from each character and gap.

#### Code
```python
def longestPalindrome(s):
    res = ""
    for i in range(len(s)):
        for a, b in [(i, i), (i, i+1)]:
            while a >= 0 and b < len(s) and s[a] == s[b]:
                if (b - a + 1) > len(res):
                    res = s[a:b+1]
                a -= 1
                b += 1
    return res
```


### 104. Palindromic Substrings
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Count the number of palindromic substrings in a given string.

#### Examples
Input: s = "abc"
Output: 3

#### Approach
Use expand-around-center technique. Check both odd and even centers.

#### Code
```python
def countSubstrings(s):
    res = 0
    for i in range(len(s)):
        for a, b in [(i, i), (i, i+1)]:
            while a >= 0 and b < len(s) and s[a] == s[b]:
                res += 1
                a -= 1
                b += 1
    return res
```


### 105. Decode Ways
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Given a string containing digits, return the number of ways to decode it. 'A' -> 1, ..., 'Z' -> 26

#### Examples
Input: s = "226"
Output: 3

#### Approach
Bottom-up DP. dp[i] = number of ways to decode up to i-th character, checking 1-digit and 2-digit combinations.

#### Code
```python
def numDecodings(s):
    if not s or s[0] == '0':
        return 0
    dp = [1, 1]
    for i in range(1, len(s)):
        temp = 0
        if s[i] != '0':
            temp += dp[1]
        if 10 <= int(s[i-1:i+1]) <= 26:
            temp += dp[0]
        dp[0], dp[1] = dp[1], temp
    return dp[1]
```


### 106. Coin Change
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
You are given coins of different denominations and a total amount. Find the minimum number of coins to make up the amount.

#### Examples
Input: coins = [1,2,5], amount = 11
Output: 3

#### Approach
Use bottom-up DP: dp[i] = min(dp[i], dp[i - coin] + 1). Initialize dp with inf and set dp[0] = 0.

#### Code
```python
def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1
```


### 107. Maximum Product Subarray
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Find the contiguous subarray within an array (containing at least one number) which has the largest product.

#### Examples
Input: nums = [2,3,-2,4]
Output: 6

#### Approach
Track both max and min product so far. Swap on encountering a negative number.

#### Code
```python
def maxProduct(nums):
    res = max(nums)
    curMin, curMax = 1, 1
    for n in nums:
        if n == 0:
            curMin, curMax = 1, 1
            continue
        tmp = curMax * n
        curMax = max(n * curMax, n * curMin, n)
        curMin = min(tmp, n * curMin, n)
        res = max(res, curMax)
    return res
```


### 108. Word Break
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Given a string and a dictionary of words, determine if it can be segmented into a space-separated sequence of dictionary words.

#### Examples
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true

#### Approach
Use DP with a set of wordDict. dp[i] = True if s[:i] can be segmented.

#### Code
```python
def wordBreak(s, wordDict):
    wordSet = set(wordDict)
    dp = [False]*(len(s)+1)
    dp[0] = True
    for i in range(1, len(s)+1):
        for j in range(i):
            if dp[j] and s[j:i] in wordSet:
                dp[i] = True
                break
    return dp[-1]
```


### 109. Longest Increasing Subsequence
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Return the length of the longest strictly increasing subsequence in the array.

#### Examples
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4

#### Approach
Use DP to track max length ending at each index. Optionally, use binary search (Patience Sorting) for O(n log n).

#### Code
```python
def lengthOfLIS(nums):
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j]+1)
    return max(dp)
```


### 110. Partition Equal Subset Sum
**Category**: 1-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Given a non-empty array, determine if it can be partitioned into two subsets with equal sum.

#### Examples
Input: nums = [1,5,11,5]
Output: true

#### Approach
This is a variation of subset sum. Use DP to check if half of total sum is possible.

#### Code
```python
def canPartition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False
    target = total // 2
    dp = set([0])
    for n in nums:
        next_dp = set(dp)
        for t in dp:
            if t + n == target:
                return True
            next_dp.add(t + n)
        dp = next_dp
    return target in dp
```


## 2-D Dynamic Programming


### 111. Unique Paths
**Category**: 2-D Dynamic Programming  
**Difficulty**: Medium

#### Description
You are in an m x n grid and can only move right or down. How many unique paths exist from the top-left to the bottom-right?

#### Examples
Input: m = 3, n = 7
Output: 28

#### Approach
Use a 2D DP table where dp[i][j] = dp[i-1][j] + dp[i][j-1]. Initialize first row and column as 1.

#### Code
```python
def uniquePaths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]
```


### 112. Longest Common Subsequence
**Category**: 2-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Given two strings, return the length of their longest common subsequence.

#### Examples
Input: text1 = "abcde", text2 = "ace"
Output: 3

#### Approach
Use 2D DP: dp[i][j] = length of LCS of text1[:i] and text2[:j].

#### Code
```python
def longestCommonSubsequence(text1, text2):
    dp = [[0]*(len(text2)+1) for _ in range(len(text1)+1)]
    for i in range(1, len(text1)+1):
        for j in range(1, len(text2)+1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[-1][-1]
```


### 113. Best Time to Buy And Sell Stock With Cooldown
**Category**: 2-D Dynamic Programming  
**Difficulty**: Medium

#### Description
You can’t buy a stock the day after you sell it. Find the max profit with as many transactions as you like.

#### Examples
Input: prices = [1,2,3,0,2]
Output: 3

#### Approach
Use three states: holding, sold, and rest. Transition between them using DP.

#### Code
```python
def maxProfit(prices):
    if not prices:
        return 0
    n = len(prices)
    hold, sold, rest = -prices[0], 0, 0
    for i in range(1, n):
        prev_hold = hold
        hold = max(hold, rest - prices[i])
        rest = max(rest, sold)
        sold = prev_hold + prices[i]
    return max(sold, rest)
```


### 114. Coin Change II
**Category**: 2-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Count the number of combinations that make up a certain amount using given coin denominations.

#### Examples
Input: amount = 5, coins = [1,2,5]
Output: 4

#### Approach
Use 1D DP array where dp[i] += dp[i - coin] for each coin.

#### Code
```python
def change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    return dp[amount]
```


### 115. Target Sum
**Category**: 2-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Assign '+' or '-' to elements of the array to sum up to target. Return total number of ways.

#### Examples
Input: nums = [1,1,1,1,1], target = 3
Output: 5

#### Approach
Transform to subset sum problem. Use DP with total sum partitioning.

#### Code
```python
def findTargetSumWays(nums, target):
    total = sum(nums)
    if (target + total) % 2 != 0 or abs(target) > total:
        return 0
    s = (target + total) // 2
    dp = [0] * (s + 1)
    dp[0] = 1
    for num in nums:
        for i in range(s, num - 1, -1):
            dp[i] += dp[i - num]
    return dp[s]
```


### 116. Interleaving String
**Category**: 2-D Dynamic Programming  
**Difficulty**: Medium

#### Description
Given strings s1, s2, and s3, determine if s3 is formed by an interleaving of s1 and s2.

#### Examples
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true

#### Approach
Use a 2D DP table where dp[i][j] = whether s3[:i+j] can be formed from s1[:i] and s2[:j].

#### Code
```python
def isInterleave(s1, s2, s3):
    if len(s1) + len(s2) != len(s3):
        return False
    dp = [[False]*(len(s2)+1) for _ in range(len(s1)+1)]
    dp[0][0] = True
    for i in range(len(s1)+1):
        for j in range(len(s2)+1):
            if i > 0 and s1[i-1] == s3[i+j-1]:
                dp[i][j] |= dp[i-1][j]
            if j > 0 and s2[j-1] == s3[i+j-1]:
                dp[i][j] |= dp[i][j-1]
    return dp[-1][-1]
```


### 117. Longest Increasing Path In a Matrix
**Category**: 2-D Dynamic Programming  
**Difficulty**: Hard

#### Description
Find the longest increasing path in a 2D integer matrix.

#### Examples
Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4

#### Approach
Use DFS with memoization for each cell. Explore 4 directions from each cell.

#### Code
```python
def longestIncreasingPath(matrix):
    if not matrix or not matrix[0]:
        return 0
    m, n = len(matrix), len(matrix[0])
    dp = [[0]*n for _ in range(m)]

    def dfs(i, j, prev):
        if i < 0 or i >= m or j < 0 or j >= n or matrix[i][j] <= prev:
            return 0
        if dp[i][j]:
            return dp[i][j]
        val = matrix[i][j]
        dp[i][j] = 1 + max(
            dfs(i+1, j, val),
            dfs(i-1, j, val),
            dfs(i, j+1, val),
            dfs(i, j-1, val)
        )
        return dp[i][j]

    return max(dfs(i, j, -float('inf')) for i in range(m) for j in range(n))
```


### 118. Distinct Subsequences
**Category**: 2-D Dynamic Programming  
**Difficulty**: Hard

#### Description
Given strings s and t, return the number of distinct subsequences of s which equals t.

#### Examples
Input: s = "rabbbit", t = "rabbit"
Output: 3

#### Approach
Use 2D DP table. dp[i][j] = ways to form t[:j] from s[:i].

#### Code
```python
def numDistinct(s, t):
    m, n = len(s), len(t)
    dp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(m+1):
        dp[i][0] = 1
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s[i-1] == t[j-1]:
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
            else:
                dp[i][j] = dp[i-1][j]
    return dp[m][n]
```


### 119. Edit Distance
**Category**: 2-D Dynamic Programming  
**Difficulty**: Hard

#### Description
Find the minimum number of operations to convert word1 to word2. Operations: insert, delete, replace.

#### Examples
Input: word1 = "horse", word2 = "ros"
Output: 3

#### Approach
Use 2D DP: dp[i][j] = min edits to convert word1[:i] to word2[:j].

#### Code
```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(m+1):
        dp[i][0] = i
    for j in range(n+1):
        dp[0][j] = j
    for i in range(1, m+1):
        for j in range(1, n+1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])
    return dp[m][n]
```


### 120. Burst Balloons
**Category**: 2-D Dynamic Programming  
**Difficulty**: Hard

#### Description
Return the maximum coins you can collect by bursting balloons wisely.

#### Examples
Input: nums = [3,1,5,8]
Output: 167

#### Approach
Use DP with interval-based recursion. Try bursting each balloon last within a window (i,j).

#### Code
```python
def maxCoins(nums):
    nums = [1] + nums + [1]
    n = len(nums)
    dp = [[0]*n for _ in range(n)]
    for l in range(2, n):
        for i in range(n - l):
            j = i + l
            for k in range(i+1, j):
                dp[i][j] = max(dp[i][j], 
                               nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])
    return dp[0][-1]
```


### 121. Regular Expression Matching
**Category**: 2-D Dynamic Programming  
**Difficulty**: Hard

#### Description
Implement regular expression matching with support for '.' and '*'.

#### Examples
Input: s = "mississippi", p = "mis*is*p*."
Output: False

#### Approach
Use 2D DP where dp[i][j] = whether s[:i] matches p[:j]. Handle '.' and '*' carefully.

#### Code
```python
def isMatch(s, p):
    dp = [[False]*(len(p)+1) for _ in range(len(s)+1)]
    dp[0][0] = True
    for j in range(1, len(p)+1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-2]
    for i in range(1, len(s)+1):
        for j in range(1, len(p)+1):
            if p[j-1] == s[i-1] or p[j-1] == '.':
                dp[i][j] = dp[i-1][j-1]
            elif p[j-1] == '*':
                dp[i][j] = dp[i][j-2]
                if p[j-2] == s[i-1] or p[j-2] == '.':
                    dp[i][j] |= dp[i-1][j]
    return dp[len(s)][len(p)]
```


## Greedy


### 122. Maximum Subarray
**Category**: Greedy  
**Difficulty**: Medium

#### Description
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

#### Examples
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.

#### Approach
Kadane’s Algorithm: Iterate through the array while maintaining a running maximum and a global maximum.

#### Code
```python
def maxSubArray(nums):
    max_sum = curr_sum = nums[0]
    for num in nums[1:]:
        curr_sum = max(num, curr_sum + num)
        max_sum = max(max_sum, curr_sum)
    return max_sum
```


### 123. Jump Game
**Category**: Greedy  
**Difficulty**: Medium

#### Description
You are given an integer array nums. Each element represents your max jump length at that position. Return true if you can reach the last index.

#### Examples
Input: nums = [2,3,1,1,4]
Output: true

#### Approach
Use a greedy strategy to keep track of the furthest index you can reach while iterating through the array.

#### Code
```python
def canJump(nums):
    max_reach = 0
    for i, jump in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + jump)
    return True
```


### 124. Jump Game II
**Category**: Greedy  
**Difficulty**: Medium

#### Description
Return the minimum number of jumps to reach the last index. Assume you can always reach the end.

#### Examples
Input: nums = [2,3,1,1,4]
Output: 2

#### Approach
Use a greedy BFS-like approach to track the current jump range and count jumps when range is exceeded.

#### Code
```python
def jump(nums):
    jumps = 0
    cur_end = cur_farthest = 0
    for i in range(len(nums) - 1):
        cur_farthest = max(cur_farthest, i + nums[i])
        if i == cur_end:
            jumps += 1
            cur_end = cur_farthest
    return jumps
```


### 125. Gas Station
**Category**: Greedy  
**Difficulty**: Medium

#### Description
Given two integer arrays gas and cost, return the starting gas station index if you can travel around the circuit once in the clockwise direction, otherwise return -1.

#### Examples
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3

#### Approach
If total gas is less than total cost, return -1. Otherwise, use a greedy approach to find the starting index.

#### Code
```python
def canCompleteCircuit(gas, cost):
    total, tank, start = 0, 0, 0
    for i in range(len(gas)):
        total += gas[i] - cost[i]
        tank += gas[i] - cost[i]
        if tank < 0:
            start = i + 1
            tank = 0
    return start if total >= 0 else -1
```


### 126. Hand of Straights
**Category**: Greedy  
**Difficulty**: Medium

#### Description
Check if the deck can be divided into groups of W consecutive cards.

#### Examples
Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
Output: True

#### Approach
Count frequency of each card, and use a min heap or sorted keys to attempt building valid consecutive sequences.

#### Code
```python
from collections import Counter
from heapq import heappop, heappush, heapify

def isNStraightHand(hand, groupSize):
    if len(hand) % groupSize != 0:
        return False
    count = Counter(hand)
    min_heap = list(count.keys())
    heapify(min_heap)

    while min_heap:
        first = min_heap[0]
        for i in range(first, first + groupSize):
            if count[i] == 0:
                return False
            count[i] -= 1
            if count[i] == 0:
                if i != min_heap[0]:
                    return False
                heappop(min_heap)
    return True
```


### 127. Merge Triplets to Form Target Triplet
**Category**: Greedy  
**Difficulty**: Medium

#### Description
Given a list of triplets and a target triplet, determine if you can merge some triplets to get the target.

#### Examples
Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]
Output: True

#### Approach
Track which target elements can be satisfied by eligible triplets.

#### Code
```python
def mergeTriplets(triplets, target):
    good = [False, False, False]
    for t in triplets:
        if all(t[i] <= target[i] for i in range(3)):
            for i in range(3):
                if t[i] == target[i]:
                    good[i] = True
    return all(good)
```


### 128. Partition Labels
**Category**: Greedy  
**Difficulty**: Medium

#### Description
Partition a string into as many parts as possible so that each letter appears in at most one part.

#### Examples
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]

#### Approach
Greedily expand the current partition until the last occurrence of each character is within bounds.

#### Code
```python
def partitionLabels(s):
    last = {ch: i for i, ch in enumerate(s)}
    j = anchor = 0
    res = []
    for i, ch in enumerate(s):
        j = max(j, last[ch])
        if i == j:
            res.append(i - anchor + 1)
            anchor = i + 1
    return res
```


### 129. Valid Parenthesis String
**Category**: Greedy  
**Difficulty**: Medium

#### Description
Given a string with '(', ')', and '*', determine if it is valid. '*' can be '(', ')' or empty.

#### Examples
Input: s = "(*)"
Output: True

#### Approach
Use two counters for minimum and maximum open parentheses based on interpretation of '*'.

#### Code
```python
def checkValidString(s):
    lo = hi = 0
    for ch in s:
        if ch == '(':
            lo += 1
            hi += 1
        elif ch == ')':
            lo -= 1
            hi -= 1
        else:  # '*'
            lo -= 1
            hi += 1
        if hi < 0:
            return False
        lo = max(lo, 0)
    return lo == 0
```


## Intervals


### 130. Insert Interval
**Category**: Intervals  
**Difficulty**: Medium

#### Description
You are given an array of non-overlapping intervals sorted by their start time, and a new interval. Insert the new interval into the intervals such that the result is also sorted and non-overlapping.

#### Examples
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

#### Approach
Traverse intervals, add all intervals ending before newInterval. Merge overlapping ones. Add remaining intervals.

#### Code
```python
def insert(intervals, newInterval):
    res = []
    for i in range(len(intervals)):
        if newInterval[1] < intervals[i][0]:
            res.append(newInterval)
            return res + intervals[i:]
        elif newInterval[0] > intervals[i][1]:
            res.append(intervals[i])
        else:
            newInterval = [min(newInterval[0], intervals[i][0]),
                           max(newInterval[1], intervals[i][1])]
    res.append(newInterval)
    return res
```


### 131. Merge Intervals
**Category**: Intervals  
**Difficulty**: Medium

#### Description
Given an array of intervals, merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.

#### Examples
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]

#### Approach
Sort intervals by start time. Iterate and merge intervals that overlap.

#### Code
```python
def merge(intervals):
    intervals.sort(key=lambda x: x[0])
    merged = []
    for interval in intervals:
        if not merged or merged[-1][1] < interval[0]:
            merged.append(interval)
        else:
            merged[-1][1] = max(merged[-1][1], interval[1])
    return merged
```


### 132. Non Overlapping Intervals
**Category**: Intervals  
**Difficulty**: Medium

#### Description
Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

#### Examples
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1

#### Approach
Sort by end time. Greedily keep intervals that don’t overlap with the previous.

#### Code
```python
def eraseOverlapIntervals(intervals):
    intervals.sort(key=lambda x: x[1])
    end = float('-inf')
    count = 0
    for start, finish in intervals:
        if start >= end:
            end = finish
        else:
            count += 1
    return count
```


### 133. Meeting Rooms
**Category**: Intervals  
**Difficulty**: Easy

#### Description
Given an array of meeting time intervals, determine if a person could attend all meetings.

#### Examples
Input: intervals = [[0,30],[5,10],[15,20]]
Output: False

#### Approach
Sort intervals and check for overlaps between consecutive meetings.

#### Code
```python
def canAttendMeetings(intervals):
    intervals.sort(key=lambda x: x[0])
    for i in range(1, len(intervals)):
        if intervals[i][0] < intervals[i - 1][1]:
            return False
    return True
```


### 134. Meeting Rooms II
**Category**: Intervals  
**Difficulty**: Medium

#### Description
Given an array of meeting time intervals, find the minimum number of conference rooms required.

#### Examples
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2

#### Approach
Sort start and end times separately. Use two pointers to simulate room usage.

#### Code
```python
def minMeetingRooms(intervals):
    if not intervals:
        return 0
    starts = sorted(i[0] for i in intervals)
    ends = sorted(i[1] for i in intervals)
    s = e = rooms = 0
    while s < len(intervals):
        if starts[s] < ends[e]:
            rooms += 1
        else:
            e += 1
        s += 1
    return rooms
```


### 135. Minimum Interval to Include Each Query
**Category**: Intervals  
**Difficulty**: Hard

#### Description
You are given a list of intervals and queries. For each query, find the size of the smallest interval that includes it.

#### Examples
Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
Output: [3,3,1,4]

#### Approach
Sort intervals and queries. Use a min-heap to track interval sizes covering current query.

#### Code
```python
import heapq

def minInterval(intervals, queries):
    intervals.sort()
    result = {}
    min_heap = []
    i = 0
    for q in sorted(queries):
        while i < len(intervals) and intervals[i][0] <= q:
            l, r = intervals[i]
            heapq.heappush(min_heap, (r - l + 1, r))
            i += 1
        while min_heap and min_heap[0][1] < q:
            heapq.heappop(min_heap)
        result[q] = min_heap[0][0] if min_heap else -1
    return [result[q] for q in queries]
```


## Math and Geometry


### 136. Rotate Image
**Category**: Math and Geometry  
**Difficulty**: Medium

#### Description
You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise) in-place.

#### Examples
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]

#### Approach
Transpose the matrix, then reverse each row to achieve a 90-degree rotation.

#### Code
```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    for row in matrix:
        row.reverse()
```


### 137. Spiral Matrix
**Category**: Math and Geometry  
**Difficulty**: Medium

#### Description
Return all elements of the matrix in spiral order.

#### Examples
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]

#### Approach
Use four pointers (top, bottom, left, right) to track bounds and simulate spiral traversal.

#### Code
```python
def spiralOrder(matrix):
    res = []
    while matrix:
        res += matrix.pop(0)
        if matrix and matrix[0]:
            for row in matrix:
                res.append(row.pop())
        if matrix:
            res += matrix.pop()[::-1]
        if matrix and matrix[0]:
            for row in matrix[::-1]:
                res.append(row.pop(0))
    return res
```


### 138. Set Matrix Zeroes
**Category**: Math and Geometry  
**Difficulty**: Medium

#### Description
If an element is 0, set its entire row and column to 0. Do it in-place with O(1) space.

#### Examples
Input: [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]

#### Approach
Use first row and column as markers, and a separate flag for the first column.

#### Code
```python
def setZeroes(matrix):
    R, C = len(matrix), len(matrix[0])
    first_col = any(matrix[i][0] == 0 for i in range(R))

    for i in range(R):
        for j in range(1, C):
            if matrix[i][j] == 0:
                matrix[i][0] = matrix[0][j] = 0

    for i in range(1, R):
        for j in range(1, C):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0

    if matrix[0][0] == 0:
        for j in range(C):
            matrix[0][j] = 0

    if first_col:
        for i in range(R):
            matrix[i][0] = 0
```


### 139. Happy Number
**Category**: Math and Geometry  
**Difficulty**: Easy

#### Description
Determine if a number is a 'happy number'.

#### Examples
Input: n = 19
Output: true
Explanation: 1² + 9² = 82 → 8² + 2² = 68 → ... → 1

#### Approach
Use a set to detect loops. Repeatedly replace number with sum of squares of its digits.

#### Code
```python
def isHappy(n):
    seen = set()
    while n != 1:
        n = sum(int(d) ** 2 for d in str(n))
        if n in seen:
            return False
        seen.add(n)
    return True
```


### 140. Plus One
**Category**: Math and Geometry  
**Difficulty**: Easy

#### Description
Increment the integer represented as an array of digits.

#### Examples
Input: digits = [1,2,3]
Output: [1,2,4]

#### Approach
Traverse from the end and handle carry. If carry remains at the end, insert 1.

#### Code
```python
def plusOne(digits):
    for i in reversed(range(len(digits))):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0
    return [1] + digits
```


### 141. Pow(x, n)
**Category**: Math and Geometry  
**Difficulty**: Medium

#### Description
Implement pow(x, n), which calculates x raised to the power n.

#### Examples
Input: x = 2.00000, n = 10
Output: 1024.00000

#### Approach
Use fast exponentiation (binary exponentiation) recursively or iteratively.

#### Code
```python
def myPow(x, n):
    if n == 0: return 1
    if n < 0: return 1 / myPow(x, -n)
    half = myPow(x, n // 2)
    return half * half if n % 2 == 0 else half * half * x
```


### 142. Multiply Strings
**Category**: Math and Geometry  
**Difficulty**: Medium

#### Description
Multiply two non-negative numbers represented as strings. Do not convert directly to integers.

#### Examples
Input: num1 = "123", num2 = "456"
Output: "56088"

#### Approach
Simulate multiplication digit-by-digit and store partial results in an array.

#### Code
```python
def multiply(num1, num2):
    if num1 == "0" or num2 == "0":
        return "0"
    res = [0] * (len(num1) + len(num2))
    for i in reversed(range(len(num1))):
        for j in reversed(range(len(num2))):
            res[i+j+1] += int(num1[i]) * int(num2[j])
            res[i+j] += res[i+j+1] // 10
            res[i+j+1] %= 10
    result = ''.join(map(str, res)).lstrip('0')
    return result
```


### 143. Detect Squares
**Category**: Math and Geometry  
**Difficulty**: Medium

#### Description
Design a data structure that supports adding points and counting the number of squares with a given query point.

#### Examples
Input: add([3,10]), add([11,2]), add([3,2]), count([11,10]) → Output: 1

#### Approach
Store all points and counts. For a new point, check perpendicular distances to form valid squares.

#### Code
```python
from collections import defaultdict

class DetectSquares:

    def __init__(self):
        self.pts = defaultdict(int)

    def add(self, point):
        self.pts[tuple(point)] += 1

    def count(self, point):
        px, py = point
        res = 0
        for (x, y), cnt in self.pts.items():
            if abs(px - x) != abs(py - y) or px == x or py == y:
                continue
            res += cnt * self.pts[(px, y)] * self.pts[(x, py)]
        return res
```


## Bit Manipulation


### 144. Single Number
**Category**: Bit Manipulation  
**Difficulty**: Easy

#### Description
Every element appears twice except for one. Find that single one.

#### Examples
Input: nums = [4,1,2,1,2]
Output: 4

#### Approach
Use XOR. All duplicate numbers cancel out due to XOR properties.

#### Code
```python
def singleNumber(nums):
    res = 0
    for num in nums:
        res ^= num
    return res
```


### 145. Number of 1 Bits
**Category**: Bit Manipulation  
**Difficulty**: Easy

#### Description
Return the number of '1' bits in the binary representation of an unsigned integer.

#### Examples
Input: n = 11 (binary: 1011)
Output: 3

#### Approach
Use bit manipulation: n & (n-1) removes the lowest set bit each time.

#### Code
```python
def hammingWeight(n):
    count = 0
    while n:
        n &= n - 1
        count += 1
    return count
```


### 146. Counting Bits
**Category**: Bit Manipulation  
**Difficulty**: Easy

#### Description
Given an integer n, return an array where each i-th element is the number of 1's in binary representation of i.

#### Examples
Input: n = 2
Output: [0,1,1]

#### Approach
Use dynamic programming: result[i] = result[i >> 1] + (i & 1).

#### Code
```python
def countBits(n):
    res = [0] * (n + 1)
    for i in range(1, n + 1):
        res[i] = res[i >> 1] + (i & 1)
    return res
```


### 147. Reverse Bits
**Category**: Bit Manipulation  
**Difficulty**: Easy

#### Description
Reverse the bits of a given 32-bit unsigned integer.

#### Examples
Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000

#### Approach
Iterate over all 32 bits, shift result, and add current bit using AND mask.

#### Code
```python
def reverseBits(n):
    res = 0
    for _ in range(32):
        res = (res << 1) | (n & 1)
        n >>= 1
    return res
```


### 148. Missing Number
**Category**: Bit Manipulation  
**Difficulty**: Easy

#### Description
Find the missing number in an array containing n distinct numbers taken from 0 to n.

#### Examples
Input: nums = [3,0,1]
Output: 2

#### Approach
Use XOR from 0 to n and XOR with all elements in array.

#### Code
```python
def missingNumber(nums):
    res = len(nums)
    for i, num in enumerate(nums):
        res ^= i ^ num
    return res
```


### 149. Sum of Two Integers
**Category**: Bit Manipulation  
**Difficulty**: Medium

#### Description
Calculate the sum of two integers without using '+' or '-' operators.

#### Examples
Input: a = 1, b = 2
Output: 3

#### Approach
Use bitwise AND and XOR to simulate addition and carry.

#### Code
```python
def getSum(a, b):
    mask = 0xFFFFFFFF
    while b:
        a, b = (a ^ b) & mask, ((a & b) << 1) & mask
    return a if a <= 0x7FFFFFFF else ~(a ^ mask)
```


### 150. Reverse Integer
**Category**: Bit Manipulation  
**Difficulty**: Medium

#### Description
Given a signed 32-bit integer x, return x with its digits reversed. Return 0 if it overflows.

#### Examples
Input: x = 123
Output: 321

#### Approach
Convert to string or use modulo math. Check overflow bounds before returning result.

#### Code
```python
def reverse(x):
    sign = -1 if x < 0 else 1
    x *= sign
    rev = 0
    while x:
        rev = rev * 10 + x % 10
        x //= 10
    rev *= sign
    return rev if -(2**31) <= rev <= 2**31 - 1 else 0
```


# SQL 50 (SQL Problems)


## Select


### 151. Recyclable and Low Fat Products
**Category**: Select  
**Difficulty**: Easy

#### Description
Find the ids of products that are both low fat and recyclable.

#### Examples
Input: Products table with columns (product_id, low_fats, recyclable)
Output: product_id values that match both conditions

#### Approach
Use a WHERE clause with two conditions: low_fats = 'Y' and recyclable = 'Y'.

#### Table Definitions
**Products**  
```sql
CREATE TABLE Products (
    product_id INT,
    low_fats ENUM('Y', 'N'),
    recyclable ENUM('Y', 'N')
);
```

#### Code
```sql
SELECT product_id
FROM Products
WHERE low_fats = 'Y' AND recyclable = 'Y';
```


### 152. Find Customer Referee
**Category**: Select  
**Difficulty**: Easy

#### Description
Find the names of customers who were not referred by the customer with id = 2.

#### Approach
Use WHERE clause to exclude records where referee_id = 2.

#### Table Definitions
**Customer**  
```sql
CREATE TABLE Customer (
    id INT,
    name VARCHAR(255),
    referee_id INT
);
```

#### Code
```sql
SELECT name
FROM Customer
WHERE referee_id != 2 OR referee_id IS NULL;
```


### 153. Big Countries
**Category**: Select  
**Difficulty**: Easy

#### Description
Find the name, population, and area of countries with population >= 25000000 or area >= 3000000.

#### Approach
Use OR condition on population and area.

#### Table Definitions
**World**  
```sql
CREATE TABLE World (
    name VARCHAR(255),
    continent VARCHAR(255),
    area INT,
    population INT,
    gdp BIGINT
);
```

#### Code
```sql
SELECT name, population, area
FROM World
WHERE population >= 25000000 OR area >= 3000000;
```


### 154. Article Views I
**Category**: Select  
**Difficulty**: Easy

#### Description
Find the IDs of articles viewed by the same user who authored them.

#### Approach
Filter where author_id = viewer_id using WHERE clause.

#### Table Definitions
**Views**  
```sql
CREATE TABLE Views (
    article_id INT,
    author_id INT,
    viewer_id INT,
    view_date DATE
);
```

#### Code
```sql
SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY id;
```


### 155. Invalid Tweets
**Category**: Select  
**Difficulty**: Easy

#### Description
Find the IDs of tweets that are longer than 15 characters.

#### Approach
Use the LENGTH() function and filter where it exceeds 15.

#### Table Definitions
**Tweets**  
```sql
CREATE TABLE Tweets (
    tweet_id INT,
    content VARCHAR(255)
);
```

#### Code
```sql
SELECT tweet_id
FROM Tweets
WHERE LENGTH(content) > 15;
```


## Basic Joins


### 156. Replace Employee ID With The Unique Identifier
**Category**: Basic Joins  
**Difficulty**: Easy

#### Description
Display the name of each employee along with their unique ID if available.

#### Approach
LEFT JOIN on Employees and EmployeeUNI using id.

#### Table Definitions
**Employees**  
```sql
CREATE TABLE Employees (
    id INT,
    name VARCHAR(255)
);
```

**EmployeeUNI**  
```sql
CREATE TABLE EmployeeUNI (
    id INT,
    unique_id INT
);
```

#### Code
```sql
SELECT E.unique_id, E.name
FROM Employees E
LEFT JOIN EmployeeUNI U ON E.id = U.id;
```


### 157. Product Sales Analysis I
**Category**: Basic Joins  
**Difficulty**: Easy

#### Description
Return the product_name and year-wise total quantity sold.

#### Approach
JOIN Sales and Product tables using product_id.

#### Table Definitions
**Sales**  
```sql
CREATE TABLE Sales (
    sale_id INT,
    product_id INT,
    year INT,
    quantity INT,
    price INT
);
```

**Product**  
```sql
CREATE TABLE Product (
    product_id INT,
    product_name VARCHAR(255)
);
```

#### Code
```sql
SELECT P.product_name, S.year, S.price
FROM Sales S
JOIN Product P ON S.product_id = P.product_id;
```


### 158. Customer Who Visited but Did Not Make Any Transactions
**Category**: Basic Joins  
**Difficulty**: Easy

#### Description
Find customers who visited but did not make any transactions.

#### Approach
LEFT JOIN Visits with Transactions and check for NULL in transaction_id.

#### Table Definitions
**Visits**  
```sql
CREATE TABLE Visits (
    visit_id INT,
    customer_id INT
);
```

**Transactions**  
```sql
CREATE TABLE Transactions (
    transaction_id INT,
    visit_id INT,
    amount INT
);
```

#### Code
```sql
SELECT V.customer_id, COUNT(V.visit_id) AS count_no_trans
FROM Visits V
LEFT JOIN Transactions T ON V.visit_id = T.visit_id
WHERE T.transaction_id IS NULL
GROUP BY V.customer_id;
```


### 159. Rising Temperature
**Category**: Basic Joins  
**Difficulty**: Easy

#### Description
Find all dates' IDs with temperature higher than the previous day.

#### Approach
Self-join Weather table on day difference.

#### Table Definitions
**Weather**  
```sql
CREATE TABLE Weather (
    id INT,
    recordDate DATE,
    temperature INT
);
```

#### Code
```sql
SELECT W1.id
FROM Weather W1
JOIN Weather W2 ON DATEDIFF(W1.recordDate, W2.recordDate) = 1
WHERE W1.temperature > W2.temperature;
```


### 160. Average Time of Process per Machine
**Category**: Basic Joins  
**Difficulty**: Easy

#### Description
Calculate average time taken by each machine to complete processes.

#### Approach
Join Start and End tables, calculate average (end - start).

#### Table Definitions
**Activity**  
```sql
CREATE TABLE Activity (
    machine_id INT,
    process_id INT,
    activity_type ENUM('start', 'end'),
    timestamp FLOAT
);
```

#### Code
```sql
SELECT machine_id, 
       ROUND(AVG(timestamp - start_time), 3) AS processing_time
FROM (
    SELECT A.machine_id, A.timestamp AS start_time, B.timestamp
    FROM Activity A
    JOIN Activity B ON A.machine_id = B.machine_id 
                    AND A.process_id = B.process_id
                    AND A.activity_type = 'start'
                    AND B.activity_type = 'end'
) T
GROUP BY machine_id;
```


### 161. Employee Bonus
**Category**: Basic Joins  
**Difficulty**: Easy

#### Description
List employees with bonuses if bonus is less than 1000 or NULL.

#### Approach
LEFT JOIN Employee and Bonus tables, filter bonus < 1000 or IS NULL.

#### Table Definitions
**Employee**  
```sql
CREATE TABLE Employee (
    empId INT,
    name VARCHAR(255),
    supervisor INT,
    salary INT
);
```

**Bonus**  
```sql
CREATE TABLE Bonus (
    empId INT,
    bonus INT
);
```

#### Code
```sql
SELECT E.name, B.bonus
FROM Employee E
LEFT JOIN Bonus B ON E.empId = B.empId
WHERE B.bonus < 1000 OR B.bonus IS NULL;
```


### 162. Students and Examinations
**Category**: Basic Joins  
**Difficulty**: Easy

#### Description
For each student and subject, report the number of times the student attended the exam.

#### Approach
Use CROSS JOIN Students × Subjects, then LEFT JOIN with Examinations and GROUP BY.

#### Table Definitions
**Students**  
```sql
CREATE TABLE Students (
    student_id INT,
    student_name VARCHAR(255)
);
```

**Subjects**  
```sql
CREATE TABLE Subjects (
    subject_name VARCHAR(255)
);
```

**Examinations**  
```sql
CREATE TABLE Examinations (
    student_id INT,
    subject_name VARCHAR(255)
);
```

#### Code
```sql
SELECT S.student_id, S.student_name, Sub.subject_name, COUNT(E.subject_name) AS attended_exams
FROM Students S
CROSS JOIN Subjects Sub
LEFT JOIN Examinations E ON S.student_id = E.student_id AND Sub.subject_name = E.subject_name
GROUP BY S.student_id, Sub.subject_name;
```


### 163. Managers with at Least 5 Direct Reports
**Category**: Basic Joins  
**Difficulty**: Medium

#### Description
Find employees who are managers with at least 5 direct reports.

#### Approach
Group by managerId and filter using HAVING clause.

#### Table Definitions
**Employee**  
```sql
CREATE TABLE Employee (
    id INT,
    name VARCHAR(255),
    department VARCHAR(255),
    managerId INT
);
```

#### Code
```sql
SELECT name
FROM Employee
WHERE id IN (
    SELECT managerId
    FROM Employee
    GROUP BY managerId
    HAVING COUNT(*) >= 5
);
```


### 164. Confirmation Rate
**Category**: Basic Joins  
**Difficulty**: Medium

#### Description
Calculate confirmation rate per user based on confirmations divided by requests.

#### Approach
LEFT JOIN Signups and Confirmations, use CASE WHEN logic to calculate.

#### Table Definitions
**Signups**  
```sql
CREATE TABLE Signups (
    user_id INT,
    time_stamp DATETIME
);
```

**Confirmations**  
```sql
CREATE TABLE Confirmations (
    user_id INT,
    time_stamp DATETIME,
    action ENUM('confirmed', 'timeout')
);
```

#### Code
```sql
SELECT S.user_id,
       ROUND(SUM(CASE WHEN C.action = 'confirmed' THEN 1 ELSE 0 END)/COUNT(C.action), 2) AS confirmation_rate
FROM Signups S
LEFT JOIN Confirmations C ON S.user_id = C.user_id
GROUP BY S.user_id;
```


## Basic Aggregate Functions


### 165. Not Boring Movies
**Category**: Basic Aggregate Functions  
**Difficulty**: Easy

#### Description
Find all movies with odd IDs and a description that is not 'boring', ordered by rating descending.

#### Approach
Use WHERE with MOD(id, 2) = 1 and description != 'boring'. ORDER BY rating DESC.

#### Table Definitions
**Cinema**  
```sql
CREATE TABLE Cinema (
    id INT,
    movie VARCHAR(255),
    description VARCHAR(255),
    rating FLOAT
);
```

#### Code
```sql
SELECT *
FROM Cinema
WHERE id % 2 = 1 AND description != 'boring'
ORDER BY rating DESC;
```


### 166. Average Selling Price
**Category**: Basic Aggregate Functions  
**Difficulty**: Easy

#### Description
Calculate the average selling price per product_id.

#### Approach
JOIN Prices and UnitsSold, group by product_id, use SUM(price * units)/SUM(units).

#### Table Definitions
**Prices**  
```sql
CREATE TABLE Prices (
    product_id INT,
    start_date DATE,
    end_date DATE,
    price INT
);
```

**UnitsSold**  
```sql
CREATE TABLE UnitsSold (
    product_id INT,
    purchase_date DATE,
    units INT
);
```

#### Code
```sql
SELECT p.product_id, 
       ROUND(SUM(p.price * u.units) / SUM(u.units), 2) AS average_price
FROM Prices p
JOIN UnitsSold u 
  ON p.product_id = u.product_id 
 AND u.purchase_date BETWEEN p.start_date AND p.end_date
GROUP BY p.product_id;
```


### 167. Project Employees I
**Category**: Basic Aggregate Functions  
**Difficulty**: Easy

#### Description
Return the project ID and the total number of employees assigned to each project.

#### Approach
GROUP BY project_id and COUNT(employee_id).

#### Table Definitions
**Project**  
```sql
CREATE TABLE Project (
    project_id INT,
    employee_id INT
);
```

**Employee**  
```sql
CREATE TABLE Employee (
    employee_id INT,
    name VARCHAR(255),
    experience_years INT
);
```

#### Code
```sql
SELECT project_id, COUNT(employee_id) AS employees_count
FROM Project
GROUP BY project_id;
```


### 168. Percentage of Users Attended a Contest
**Category**: Basic Aggregate Functions  
**Difficulty**: Easy

#### Description
Report the percentage of users who participated in at least one contest, rounded to 2 decimals.

#### Approach
Use COUNT(DISTINCT) for attended and total, then compute percentage.

#### Table Definitions
**Users**  
```sql
CREATE TABLE Users (
    user_id INT,
    user_name VARCHAR(255)
);
```

**Register**  
```sql
CREATE TABLE Register (
    contest_id INT,
    user_id INT
);
```

#### Code
```sql
SELECT ROUND(
  (SELECT COUNT(DISTINCT user_id) FROM Register) * 100.0 / COUNT(*), 2
) AS percentage
FROM Users;
```


### 169. Queries Quality and Percentage
**Category**: Basic Aggregate Functions  
**Difficulty**: Easy

#### Description
Return each query name with its average rating and the percentage of poor ratings (<3).

#### Approach
Use COUNT and AVG with conditional aggregation.

#### Table Definitions
**Queries**  
```sql
CREATE TABLE Queries (
    query_name VARCHAR(255),
    result ENUM('good', 'bad'),
    position INT,
    rating INT
);
```

#### Code
```sql
SELECT query_name,
       ROUND(AVG(rating / position), 2) AS quality,
       ROUND(SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS poor_query_percentage
FROM Queries
WHERE query_name IS NOT NULL
GROUP BY query_name;
```


### 170. Monthly Transactions I
**Category**: Basic Aggregate Functions  
**Difficulty**: Medium

#### Description
Count the number of approved transactions grouped by month and country.

#### Approach
Use DATE_FORMAT to extract year-month and GROUP BY both fields.

#### Table Definitions
**Transactions**  
```sql
CREATE TABLE Transactions (
    id INT,
    country VARCHAR(255),
    state ENUM('approved', 'declined'),
    amount INT,
    trans_date DATE
);
```

#### Code
```sql
SELECT LEFT(trans_date, 7) AS month, country,
       COUNT(*) AS trans_count,
       SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) AS approved_count,
       SUM(amount) AS trans_total_amount,
       SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_amount
FROM Transactions
GROUP BY month, country;
```


### 171. Immediate Food Delivery II
**Category**: Basic Aggregate Functions  
**Difficulty**: Medium

#### Description
Find the percentage of customers who received delivery on the same day they placed the order.

#### Approach
Use COUNT with CASE WHEN order_date = customer_pref_delivery_date.

#### Table Definitions
**Delivery**  
```sql
CREATE TABLE Delivery (
    delivery_id INT,
    customer_id INT,
    order_date DATE,
    customer_pref_delivery_date DATE
);
```

#### Code
```sql
SELECT ROUND(
    SUM(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2
) AS immediate_percentage
FROM Delivery;
```


### 172. Game Play Analysis IV
**Category**: Basic Aggregate Functions  
**Difficulty**: Medium

#### Description
Report the fraction of players who logged in again on the day after their first login.

#### Approach
Use self-join to compare login days per player.

#### Table Definitions
**Activity**  
```sql
CREATE TABLE Activity (
    player_id INT,
    device_id INT,
    event_date DATE,
    games_played INT
);
```

#### Code
```sql
SELECT ROUND(COUNT(DISTINCT player_id) * 1.0 / 
             (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM Activity A
JOIN Activity B 
  ON A.player_id = B.player_id 
 AND DATEDIFF(B.event_date, A.event_date) = 1
WHERE A.event_date = (
    SELECT MIN(event_date)
    FROM Activity AA
    WHERE AA.player_id = A.player_id
);
```


## Sorting and Grouping


### 173. Number of Unique Subjects Taught by Each Teacher
**Category**: Sorting and Grouping  
**Difficulty**: Easy

#### Description
Find the number of unique subjects each teacher teaches.

#### Approach
Use GROUP BY teacher_id and COUNT(DISTINCT subject_id).

#### Table Definitions
**Teacher**  
```sql
CREATE TABLE Teacher (
    teacher_id INT,
    subject_id INT,
    dept_id INT
);
```

#### Code
```sql
SELECT teacher_id, COUNT(DISTINCT subject_id) AS cnt
FROM Teacher
GROUP BY teacher_id;
```


### 174. User Activity for the Past 30 Days I
**Category**: Sorting and Grouping  
**Difficulty**: Easy

#### Description
Find the number of users active each day in the past 30 days from today.

#### Approach
GROUP BY activity_date and COUNT(DISTINCT user_id). Filter by DATEDIFF.

#### Table Definitions
**Activity**  
```sql
CREATE TABLE Activity (
    user_id INT,
    session_id INT,
    activity_date DATE,
    activity_type ENUM('open_session', 'end_session', 'scroll_down', 'send_message')
);
```

#### Code
```sql
SELECT activity_date, COUNT(DISTINCT user_id) AS active_users
FROM Activity
WHERE activity_date BETWEEN DATE_SUB(CURDATE(), INTERVAL 29 DAY) AND CURDATE()
GROUP BY activity_date;
```


### 175. Product Sales Analysis III
**Category**: Sorting and Grouping  
**Difficulty**: Medium

#### Description
Return the IDs of products that were sold in each of the first three months of 2019.

#### Approach
Use GROUP BY product_id and COUNT(DISTINCT MONTH).

#### Table Definitions
**Sales**  
```sql
CREATE TABLE Sales (
    sale_id INT,
    product_id INT,
    year INT,
    quantity INT,
    price INT
);
```

**Product**  
```sql
CREATE TABLE Product (
    product_id INT,
    product_name VARCHAR(255)
);
```

#### Code
```sql
SELECT product_id
FROM Sales
WHERE sale_date BETWEEN '2019-01-01' AND '2019-03-31'
GROUP BY product_id
HAVING COUNT(DISTINCT MONTH(sale_date)) = 3;
```


### 176. Classes With at Least 5 Students
**Category**: Sorting and Grouping  
**Difficulty**: Easy

#### Description
Return class IDs that have at least 5 students.

#### Approach
GROUP BY class and use HAVING COUNT(*) >= 5.

#### Table Definitions
**Courses**  
```sql
CREATE TABLE Courses (
    student VARCHAR(255),
    class INT
);
```

#### Code
```sql
SELECT class
FROM Courses
GROUP BY class
HAVING COUNT(student) >= 5;
```


### 177. Find Followers Count
**Category**: Sorting and Grouping  
**Difficulty**: Easy

#### Description
Return each user's ID and their total number of followers.

#### Approach
GROUP BY user_id and COUNT(follower_id).

#### Table Definitions
**Follow**  
```sql
CREATE TABLE Follow (
    user_id INT,
    follower_id INT
);
```

#### Code
```sql
SELECT user_id, COUNT(follower_id) AS followers_count
FROM Followers
GROUP BY user_id;
```


### 178. Biggest Single Number
**Category**: Sorting and Grouping  
**Difficulty**: Easy

#### Description
Return the largest number that only appears once in the table.

#### Approach
GROUP BY num HAVING COUNT(*) = 1, ORDER BY DESC LIMIT 1.

#### Table Definitions
**MyNumbers**  
```sql
CREATE TABLE MyNumbers (
    num INT
);
```

#### Code
```sql
SELECT MAX(num) AS num
FROM MyNumbers
GROUP BY num
HAVING COUNT(*) = 1;
```


### 179. Customers Who Bought All Products
**Category**: Sorting and Grouping  
**Difficulty**: Medium

#### Description
Return customers who bought all the products in the Products table.

#### Approach
Use COUNT(DISTINCT product_id) = total products per customer.

#### Table Definitions
**Customer**  
```sql
CREATE TABLE Customer (
    customer_id INT,
    product_key INT
);
```

**Product**  
```sql
CREATE TABLE Product (
    product_key INT
);
```

#### Code
```sql
SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product);
```


## Advanced Select and Joins


### 180. The Number of Employees Which Report to Each Employee
**Category**: Advanced Select and Joins  
**Difficulty**: Easy

#### Description
Find the number of direct reports each employee has.

#### Approach
Use GROUP BY managerId and COUNT(employee_id).

#### Table Definitions
**Employee**  
```sql
CREATE TABLE Employee (
    employee_id INT,
    name VARCHAR(255),
    reports_to INT,
    age INT
);
```

#### Code
```sql
SELECT e.employee_id, COUNT(r.employee_id) AS reports_count
FROM Employees e
LEFT JOIN Employees r ON e.employee_id = r.manager_id
GROUP BY e.employee_id;
```


### 181. Primary Department for Each Employee
**Category**: Advanced Select and Joins  
**Difficulty**: Easy

#### Description
Return each employee's primary department based on the highest salary.

#### Approach
Use ROW_NUMBER() or subquery with MAX(salary) partitioned by employee.

#### Table Definitions
**Employee**  
```sql
CREATE TABLE Employee (
    employee_id INT,
    department_id INT,
    primary_flag ENUM('Y', 'N')
);
```

**Department**  
```sql
CREATE TABLE Department (
    department_id INT,
    department_name VARCHAR(255)
);
```

#### Code
```sql
SELECT employee_id, department_id
FROM (
    SELECT *, 
           ROW_NUMBER() OVER (PARTITION BY employee_id ORDER BY salary DESC) AS rn
    FROM Employee
) ranked
WHERE rn = 1;
```


### 182. Triangle Judgement
**Category**: Advanced Select and Joins  
**Difficulty**: Easy

#### Description
Determine if the three sides form a valid triangle.

#### Approach
Use CASE WHEN A + B > C AND A + C > B AND B + C > A THEN 'Yes'.

#### Table Definitions
**Triangle**  
```sql
CREATE TABLE Triangle (
    x INT,
    y INT,
    z INT
);
```

#### Code
```sql
SELECT *,
       CASE 
           WHEN x + y > z AND x + z > y AND y + z > x THEN 'Yes'
           ELSE 'No'
       END AS triangle
FROM Triangle;
```


### 183. Consecutive Numbers
**Category**: Advanced Select and Joins  
**Difficulty**: Medium

#### Description
Find all numbers that appear at least three times consecutively.

#### Approach
Use self join or LEAD/LAG to compare current, next, and next+1 rows.

#### Table Definitions
**Logs**  
```sql
CREATE TABLE Logs (
    id INT,
    num INT
);
```

#### Code
```sql
SELECT DISTINCT l1.num AS ConsecutiveNums
FROM Logs l1
JOIN Logs l2 ON l1.id = l2.id - 1 AND l1.num = l2.num
JOIN Logs l3 ON l1.id = l3.id - 2 AND l1.num = l3.num;
```


### 184. Product Price at a Given Date
**Category**: Advanced Select and Joins  
**Difficulty**: Medium

#### Description
Find the price of each product on a specific date if available.

#### Approach
Use WHERE with BETWEEN start_date AND end_date and filter for date.

#### Table Definitions
**Products**  
```sql
CREATE TABLE Products (
    product_id INT,
    new_price INT,
    change_date DATE
);
```

#### Code
```sql
SELECT product_id, price
FROM Products
WHERE '2019-08-16' BETWEEN start_date AND end_date;
```


### 185. Last Person to Fit in the Bus
**Category**: Advanced Select and Joins  
**Difficulty**: Medium

#### Description
Given queue order and capacity, return the last person to fit in the bus.

#### Approach
Use running total window function and filter where capacity not exceeded.

#### Table Definitions
**Queue**  
```sql
CREATE TABLE Queue (
    person_id INT,
    person_name VARCHAR(255),
    weight INT,
    turn INT
);
```

#### Code
```sql
SELECT person_name
FROM (
    SELECT person_name, SUM(weight) OVER (ORDER BY turn) AS total_weight
    FROM Queue
) sub
WHERE total_weight <= 1000
ORDER BY total_weight DESC
LIMIT 1;
```


### 186. Count Salary Categories
**Category**: Advanced Select and Joins  
**Difficulty**: Medium

#### Description
Count how many employees fall into low, average, and high salary brackets.

#### Approach
Use CASE WHEN inside SUM for each category threshold.

#### Table Definitions
**Accounts**  
```sql
CREATE TABLE Accounts (
    account_id INT,
    income INT
);
```

#### Code
```sql
SELECT 
    SUM(CASE WHEN income < 20000 THEN 1 ELSE 0 END) AS low_salary,
    SUM(CASE WHEN income BETWEEN 20000 AND 50000 THEN 1 ELSE 0 END) AS average_salary,
    SUM(CASE WHEN income > 50000 THEN 1 ELSE 0 END) AS high_salary
FROM Accounts;
```


## Subqueries


### 187. Employees Whose Manager Left the Company
**Category**: Subqueries  
**Difficulty**: Easy

#### Description
Return the employees whose manager no longer works at the company.

#### Approach
Use a subquery to check if the manager_id does not exist in the current employee list.

#### Table Definitions
**Employees**  
```sql
CREATE TABLE Employees (
    id INT,
    name VARCHAR(255),
    salary INT,
    managerId INT
);
```

#### Code
```sql
SELECT employee_id
FROM Employees
WHERE manager_id IS NOT NULL 
  AND manager_id NOT IN (SELECT employee_id FROM Employees);
```


### 188. Exchange Seats
**Category**: Subqueries  
**Difficulty**: Medium

#### Description
Swap seats in pairs for students with consecutive seat ids.

#### Approach
Use CASE WHEN seat_id % 2 = 1 THEN seat_id + 1 ELSE seat_id - 1 ORDER BY seat_id.

#### Table Definitions
**Seat**  
```sql
CREATE TABLE Seat (
    id INT,
    student VARCHAR(255)
);
```

#### Code
```sql
SELECT CASE 
         WHEN id % 2 = 1 AND id != (SELECT MAX(id) FROM Seat) THEN id + 1
         WHEN id % 2 = 0 THEN id - 1
         ELSE id
       END AS id, student
FROM Seat
ORDER BY id;
```


### 189. Movie Rating
**Category**: Subqueries  
**Difficulty**: Medium

#### Description
Find movies with the highest average rating and users who rated the most in a month.

#### Approach
Use AVG and COUNT with subqueries to filter top-rated movies and active users.

#### Table Definitions
**Movies**  
```sql
CREATE TABLE Movies (
    movie_id INT,
    title VARCHAR(255)
);
```

**Users**  
```sql
CREATE TABLE Users (
    user_id INT,
    name VARCHAR(255)
);
```

**MovieRating**  
```sql
CREATE TABLE MovieRating (
    movie_id INT,
    user_id INT,
    rating INT,
    created_at DATE
);
```

#### Code
```sql
SELECT name
FROM Users
WHERE user_id = (
    SELECT user_id
    FROM MovieRating
    WHERE MONTH(created_at) = 2 AND YEAR(created_at) = 2020
    GROUP BY user_id
    ORDER BY COUNT(*) DESC, user_id ASC
    LIMIT 1
);

SELECT title
FROM Movies
WHERE movie_id = (
    SELECT movie_id
    FROM MovieRating
    GROUP BY movie_id
    ORDER BY AVG(rating) DESC, movie_id ASC
    LIMIT 1
);
```


### 190. Restaurant Growth
**Category**: Subqueries  
**Difficulty**: Medium

#### Description
Return month-on-month change in total order amount per user.

#### Approach
Join with a subquery that fetches previous month's amount and subtract.

#### Table Definitions
**Customer**  
```sql
CREATE TABLE Customer (
    customer_id INT,
    name VARCHAR(255),
    visited_on DATE,
    amount INT
);
```

#### Code
```sql
SELECT a.id, a.month, a.amount, 
       a.amount - IFNULL(b.amount, 0) AS growth
FROM Sales a
LEFT JOIN Sales b 
  ON a.id = b.id AND a.month = b.month + 1;
```


### 191. Friend Requests II: Who Has the Most Friends
**Category**: Subqueries  
**Difficulty**: Medium

#### Description
Return the user with the most number of accepted friend requests.

#### Approach
Use UNION or COUNT with GROUP BY to count all accepted connections.

#### Table Definitions
**RequestAccepted**  
```sql
CREATE TABLE RequestAccepted (
    requester_id INT,
    accepter_id INT,
    accept_date DATE
);
```

#### Code
```sql
SELECT id, COUNT(*) AS num
FROM (
    SELECT requester_id AS id FROM RequestAccepted
    UNION ALL
    SELECT accepter_id AS id FROM RequestAccepted
) AS all_ids
GROUP BY id
ORDER BY num DESC
LIMIT 1;
```


### 192. Investments in 2016
**Category**: Subqueries  
**Difficulty**: Medium

#### Description
Return all investment rounds in 2016 with the most money raised.

#### Approach
Use a subquery to filter by max raised_amount and year = 2016.

#### Table Definitions
**Insurance**  
```sql
CREATE TABLE Insurance (
    pid INT,
    tiv_2015 FLOAT,
    tiv_2016 FLOAT,
    lat FLOAT,
    lon FLOAT
);
```

#### Code
```sql
SELECT * 
FROM Investments
WHERE year = 2016 AND amount = (
    SELECT MAX(amount) 
    FROM Investments 
    WHERE year = 2016
);
```


### 193. Department Top Three Salaries
**Category**: Subqueries  
**Difficulty**: Hard

#### Description
Return top 3 salaries in each department.

#### Approach
Use DENSE_RANK or correlated subquery with LIMIT 3 per department.

#### Table Definitions
**Employee**  
```sql
CREATE TABLE Employee (
    id INT,
    name VARCHAR(255),
    salary INT,
    departmentId INT
);
```

**Department**  
```sql
CREATE TABLE Department (
    id INT,
    name VARCHAR(255)
);
```

#### Code
```sql
SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary
FROM (
    SELECT *,
           DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) AS rnk
    FROM Employee
) e
JOIN Department d ON e.departmentId = d.id
WHERE rnk <= 3;
```


## Advanced String Functions / Regex / Clause Problems


### 194. Fix Names in a Table
**Category**: Advanced String Functions / Regex / Clause Problems  
**Difficulty**: Easy

#### Description
Capitalize the first letter of the first and last name and lower the rest.

#### Approach
Use CONCAT, UPPER and LOWER along with SUBSTRING to format each part of the name.

#### Table Definitions
**Users**  
```sql
CREATE TABLE Users (
    user_id INT,
    name VARCHAR(255)
);
```

#### Code
```sql
SELECT user_id, 
       CONCAT(UPPER(LEFT(name, 1)), LOWER(SUBSTRING(name, 2))) AS name
FROM Users;
```


### 195. Patients With a Condition
**Category**: Advanced String Functions / Regex / Clause Problems  
**Difficulty**: Easy

#### Description
Return patients whose conditions contain the word 'DIAB1' as a whole word.

#### Approach
Use REGEXP to match the whole word condition with proper word boundaries.

#### Table Definitions
**Patients**  
```sql
CREATE TABLE Patients (
    patient_id INT,
    patient_name VARCHAR(255),
    conditions VARCHAR(255)
);
```

#### Code
```sql
SELECT patient_id, patient_name, conditions
FROM Patients
WHERE conditions REGEXP '\bDIAB1\b';
```


### 196. Delete Duplicate Emails
**Category**: Advanced String Functions / Regex / Clause Problems  
**Difficulty**: Easy

#### Description
Delete all duplicate emails keeping only the one with the smallest id.

#### Approach
Use DELETE with WHERE id NOT IN (subquery with MIN(id) for each email).

#### Table Definitions
**Person**  
```sql
CREATE TABLE Person (
    id INT,
    email VARCHAR(255)
);
```

#### Code
```sql
DELETE FROM Person
WHERE id NOT IN (
    SELECT * FROM (
        SELECT MIN(id)
        FROM Person
        GROUP BY email
    ) AS sub
);
```


### 197. Second Highest Salary
**Category**: Advanced String Functions / Regex / Clause Problems  
**Difficulty**: Medium

#### Description
Return the second highest salary from the Employee table.

#### Approach
Use DISTINCT with ORDER BY and OFFSET 1, or use subquery with MAX < MAX.

#### Table Definitions
**Employee**  
```sql
CREATE TABLE Employee (
    id INT,
    salary INT
);
```

#### Code
```sql
SELECT MAX(salary) AS SecondHighestSalary
FROM Employee
WHERE salary < (
    SELECT MAX(salary)
    FROM Employee
);
```


### 198. Group Sold Products By The Date
**Category**: Advanced String Functions / Regex / Clause Problems  
**Difficulty**: Easy

#### Description
Return the number of products sold grouped by date and product name.

#### Approach
Use GROUP BY sell_date, product, and COUNT(*) as total.

#### Table Definitions
**Activities**  
```sql
CREATE TABLE Activities (
    sell_date DATE,
    product VARCHAR(255)
);
```

#### Code
```sql
SELECT sell_date, COUNT(DISTINCT product) AS num_sold, 
       GROUP_CONCAT(DISTINCT product ORDER BY product) AS products
FROM Activities
GROUP BY sell_date
ORDER BY sell_date;
```


### 199. List the Products Ordered in a Period
**Category**: Advanced String Functions / Regex / Clause Problems  
**Difficulty**: Easy

#### Description
Return product IDs that were ordered between 2019-01-01 and 2019-03-31.

#### Approach
Use WHERE with BETWEEN clause on order_date and SELECT DISTINCT product_id.

#### Table Definitions
**Products**  
```sql
CREATE TABLE Products (
    product_id INT,
    product_name VARCHAR(255)
);
```

**Orders**  
```sql
CREATE TABLE Orders (
    product_id INT,
    order_date DATE
);
```

#### Code
```sql
SELECT DISTINCT product_id
FROM Orders
WHERE order_date BETWEEN '2019-01-01' AND '2019-03-31';
```


### 200. Find Users With Valid E-Mails
**Category**: Advanced String Functions / Regex / Clause Problems  
**Difficulty**: Easy

#### Description
Return users with valid emails based on custom regex rule.

#### Approach
Use REGEXP to check for pattern: alphanumerics + '@leetcode.com'.

#### Table Definitions
**Users**  
```sql
CREATE TABLE Users (
    user_id INT,
    name VARCHAR(255),
    mail VARCHAR(255)
);
```

#### Code
```sql
SELECT user_id, name, mail
FROM Users
WHERE mail REGEXP '^[a-zA-Z][a-zA-Z0-9_\.\-]*@leetcode\.com$';
```
